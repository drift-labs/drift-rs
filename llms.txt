# llms.txt for drift-labs/drift-rs
# Generated: 2025-12-08T17:29:29.633Z
# Total files in repository: 105

---

## File: README.md
```
<div align="center">
  <img height="120x" src="https://uploads-ssl.webflow.com/611580035ad59b20437eb024/616f97a42f5637c4517d0193_Logo%20(1)%20(1).png" />

  <h1 style="margin-top:20px;">drift-rs</h1>

  <p>
    <a href="https://crates.io/crates/drift-rs"><img alt="Crates.io" src="https://img.shields.io/crates/v/drift-rs.img" /></a>
    <a href="https://docs.drift.trade/developer-resources/sdk-documentation"><img alt="Docs" src="https://img.shields.io/badge/docs-tutorials-blueviolet" /></a>
    <a href="https://discord.com/channels/849494028176588802/878700556904980500"><img alt="Discord Chat" src="https://img.shields.io/discord/889577356681945098?color=blueviolet" /></a>
    <a href="https://opensource.org/licenses/Apache-2.0"><img alt="License" src="https://img.shields.io/github/license/project-serum/anchor?color=blueviolet" /></a>
  </p>
</div>

# drift-rs

Experimental, high performance Rust SDK for building offchain clients for [Drift V2](https://github.com/drift-labs/protocol-v2) protocol.

See the official [docs](https://docs.rs/drift-rs/latest/drift_rs/)

## Install
```toml
drift-rs = { git = "https://github.com/drift-labs/drift-rs", tag = "v1.0.0-alpha.16" }
```
_*_ crates.io requires [libdrift](https://github.com/drift-labs/drift-ffi-sys/?tab=readme-ov-file#from-source) is installed and linked locally


## Use
The `DriftClient` struct provides methods for reading drift program accounts and crafting transactions.  
It is built on a subscription model where live account updates are transparently cached and made accessible via accessor methods.  
The client may be subscribed either via Ws or gRPC.  

```rust
use drift_rs::{AccountFilter, DriftClient, Wallet, grpc::GrpcSubscribeOpts};
use solana_sdk::signature::Keypair;

async fn main() {
    let client = DriftClient::new(
        Context::MainNet,
        RpcClient::new("https://rpc-provider.com"),
        Keypair::new().into(),
    )
    .await
    .expect("connects");

    // Subscribe via WebSocket
    //
    // 1) Ws-based live market and price changes
    let markets = [MarketId::spot(1), MarketId::perp(0)];
    client.subscribe_markets(&markets).await.unwrap();
    client.subscribe_oracles(&markets).await.unwrap();
    client.subscribe_account("SUBACCOUNT_1");

    // OR 2) subscribe via gRPC (advanced)
    // gRPC automatically subscribes to all markets and oracles
    client.grpc_subscribe(
      "https://grpc.example.com".into(),
      "API-X-TOKEN".into(),
      GrpcSubscribeOpts::default()
        .user_accounts("SUBACCOUNT_1", "SUB_ACCOUNT_2")
        .on_slot(move |new_slot| {
          // do something on slot
        })
        .on_account(
          AccountFilter::partial().with_discriminator(User::DISCRIMINATOR),
          move |account| {
              // do something on user account updates
          })
    ).await;

    //
    // Fetch latest values
    ///
    let sol_perp_price = client.oracle_price(MarketId::perp(0));
    let subaccount_1: User = client.try_get_account("SUBACCOUNT_1"));
```
## Setup

### Mac

Install rosetta (m-series only) and configure Rust toolchain for `x86_64`  
⚠️ `1.76.0-x86_64` must also be installed alongside latest stable rust

```bash
softwareupdate --install-rosetta

# replace '1.85.0' with preferred latest stable version
rustup install 1.85.0-x86_64-apple-darwin 1.76.0-x86_64-apple-darwin --force-non-host

rustup override set 1.85.0-x86_64-apple-darwin
```

### Linux 
```bash
# replace '1.85.0' with preferred latest stable version
rustup install 1.85.0-x86_64-unknown-linux-gnu 1.76.0-x86_64-unknown-linux-gnu --force-non-host

rustup override set 1.85.0-x86_64-unknown-linux-gnu
```

⚠️ the non-x86_64 toolchains are incompatible due to memory layout differences between solana program (BPF) and aarch64 and will fail at runtime with deserialization errors like: `InvalidSize`.

## Local Development
drift-rs links to the drift program crate via FFI, build from source (default) by cloning git submodule or dynamically link with a version from [drift-ffi-sys](https://github.com/drift-labs/drift-ffi-sys/releases)

**clone repo and submodules**
```bash
git clone https://github.com/drift-labs/drift-rs &&\
cd drift-rs &&\
git submodule update --init --recursive
```

**build**
```bash
# Build from source (default)
CARGO_DRIFT_FFI_STATIC=1

# Provide a prebuilt drift_ffi_sys lib 
CARGO_DRIFT_FFI_PATH="/path/to/libdrift_ffi_sys"
```
## Development

## Release
`git tag v<MAJOR.MINOR.PATCH> && git push`

## Updating IDL types
from repo root dir:
```shell
./scripts/idl-update.sh
cargo check # build new IDL types
# commit changes...
```

```

## File: crates/drift-idl-gen/README.md
```
# drfit-idl-gen

⚠️ for drift-rs there's no need to run this manually. The `build.rs` script will trigger it.

Generates rust anchor structs from IDL json
This is implemented rather than another project for a couple reasons:

1) `#[repr(C)]` other IDL generation tools do not provide the ability to market structs with `repr(C)` which is necessary for ffi functionality throught the drift-rs project.
2) does not rely on anchor vendored solana crates. anchor is pinned to older versions of the solana crates. drift-rs seeks to be readily upgradable to use lastest solana crates.

## Dev Note ⚠️
- An important assumption in this code is that the underlying types (serialization and deserialization) does not change among solana crate versions i.e `solana_sdk_1.16::Pubkey == solana_sdk_2.x::Pubkey == anchor_lang::solana_sdk::Pubkey`
this allows the generated IDL code to ignore the anchor version of crates.
```

## File: crates/pubsub-client/README.md
```
Drop-in replacement for the Solana/Agave PubSubClient with better disconnection handling
```

## File: examples/dlob-matching/README.md
```
# DLOB L3 Methods Example

This example demonstrates how to use the DLOB L3 order retrieval methods with user provided oracle prices.
```

## File: examples/drift-client-callbacks/README.md
```
# DriftClient Callback Subscriptions Example

This example demonstrates how to subscribe to the DriftClient with callbacks and process market updates in real-time.

## Overview

This example shows how to:
- Subscribe to Drift market updates using the callback system
- Deserialize market account data 
- Access AMM fields like `base_asset_amount_with_amm`
- Handle market updates efficiently

## Usage

### Quick Start (Mainnet)
```bash
cd examples/drift-client-callbacks
cargo run
```

### With Custom RPC Endpoint
```bash
RPC_URL=https://your-rpc-endpoint.com cargo run
```

### Configuration Options
```bash
# Run for 60 seconds
cargo run -- --duration 60

RPC_URL=https://your-rpc-endpoint.com cargo run

# Debug logging
RUST_LOG=debug cargo run
```

## Callback Implementation

### Subscribing to Market Updates
```rust
// Subscribe to perp markets with a callback
client.subscribe_markets_with_callback(&markets, Some(|update| {
    // Process market update
    process_market_update(update);
})).await?;
```

### Processing Market Data
```rust
// Callback to process market updates
let callback = move |update: &AccountUpdate| {
    // Deserialize PerpMarket from account data
    match deserialize_perp_market(&update.data) {
        Ok(market) => {
            println!(
                "Market {}: base_asset_amount_with_amm = {}",
                market.market_index, 
                market.amm.base_asset_amount_with_amm
            );
        }
        Err(e) => {
            eprintln!("Failed to deserialize market: {}", e);
        }
    }
};
```

## Important Gotchas and Considerations

### 1. **Account Data Deserialization**
- Market account data can be deserialized directly using `try_deserialize`
- Handle deserialization errors gracefully - not all updates may be valid

### 2. **Callback Lifetime and State**
- Callbacks capture state by value or reference
- Use `Arc<Mutex<>>` for shared mutable state across callbacks
- Callbacks run on the subscription thread - avoid blocking operations

### 3. **Subscription Management**
- Always call `unsubscribe()` when done to clean up resources
- Subscriptions auto-reconnect on network issues
- Multiple callbacks can subscribe to the same market

### 4. **Performance Considerations**
- Callbacks execute synchronously - keep them fast
- Heavy computation should be offloaded to separate tasks
- Consider batching updates if processing is expensive

```

## File: examples/event-subscriber/README.md
```
# Event Subscriber Example

Shows how to use the `EventSubscriber`. Default will run with websocket, run with `--grpc` flag to use a Yellowstone grpc datasource. The example terminates after 50 fill events.

Run on mainnet
```shell
WS_RPC_ENDPOINT=wss://your-rpc-with-wss.com cargo run
```

or 

```shell
GRPC_ENDPOINT=https://your-rpc-with-grpc.com:2053 GRPC_X_TOKEN=00000000-0000-0000-0000-000000000000 cargo run -- --grpc
```

Enable logging with `RUST_LOG=debug`

alternatively use a `.env` file
```

## File: examples/market-maker/README.md
```
## Market Maker Example

Place and cancel fixed limit and floating limit orders

Run mainnet WebSocket example
```shell
PRIVATE_KEY="<base58 private key>" \
MAINNET=1 \
RPC_URL="mainnet-rpc.example.com" \
 cargo run --release
```

Run mainnet gRPC example
```shell
PRIVATE_KEY="<base58 private key>" \
MAINNET=1 \
RPC_URL="mainnet-rpc.example.com" \
GRPC_URL="" \
GRPC_X_TOKEN="" \
 cargo run --release -- --grpc
```

## JIT Making
Drift MMs can also provide Just in Time (JIT) matching via swift and jit-proxy helper program.
for examples see the `swift-maker` example and the jit-proxy example: https://github.com/drift-labs/jit-proxy/tree/master/rust

```

## File: examples/swift-maker/README.md
```
# Swift Example Maker

Example listens to incoming swift orders on a subset of markets: `["sui-perp", "eth-perp", "xrp-perp"]` and tries to fill them.
Runs on devnet by default

## Run
Run on devnet
```shell
PRIVATE_KEY="<base58 private key>" RUST_LOG=swift=debug cargo run --release
```

Run on mainnet
```shell
PRIVATE_KEY="<base58 private key>" MAINNET=1 RPC_URL="mainnet-rpc.example.com" RUST_LOG=swift=debug cargo run --release
```

alternatively use a `.env` file

---

## Logs
latency numbers show the diff between when taker order was accepted by swift server and
when received locally.
Most of the latency is internal to the swift server where the tx is simulated for
correctness before it is forwarded.

```log
uuid: F9gaynQV, latency: 74ms
```

The most accurate guage of network latency is the heartbeat msg (ms)
```log
[2025-03-06T06:05:58Z DEBUG swift] heartbeat latency: 0
```

```

## File: examples/swift-taker/README.md
```
# Swift Example Taker

Example swift taker client.
Runs on devnet by default

## Run
Run on devnet
```shell
PRIVATE_KEY="<base58 private key>" RUST_LOG=swift=debug cargo run --release

# Deposit Trade
PRIVATE_KEY="<base58 private key>" RUST_LOG=swift=debug cargo run --release -- --deposit-trade

```

Run on mainnet
```shell
PRIVATE_KEY="<base58 private key>" MAINNET=1 RPC_URL="mainnet-rpc.example.com" RUST_LOG=swift=debug cargo run --release
```

alternatively use a `.env` file

```

## File: Cargo.toml
```
[package]
name = "drift-rs"
version = "1.0.0-alpha.16"
edition = "2021"
build = "build.rs"
license = "Apache-2.0"
readme = "README.md"
repository = "https://github.com/drift-labs/drift-rs"
homepage = "https://drift.trade"
description = """
Rust SDK for Drift V2 Protocol on the Solana blockchain.
"""
categories = ["cryptography::cryptocurrencies", "api-bindings"]
keywords = ["solana", "dex", "drift", "sdk"]

[lib]
path = "crates/src/lib.rs"

[features]
# run integration tests against RPC nodes
rpc_tests = []
# make more variables public - use with caution
unsafe_pub = []
titan = ["titan-swap-api-client"] 

[dependencies]
abi_stable = { version = "0.11", default-features = false }
ahash = "0.8.12"
anchor-lang = { version = "0.32.1", features = ["derive"] }
arrayvec = "0.7.6"
base64 = "0.22"
bytemuck = "1.17"
crossbeam = "0.8.4"
dashmap = "6"
env_logger = "0.11"
futures-util = "0.3"
fxhash = "0.2.1"
hex = "0.4"
jupiter-swap-api-client = { git = "https://github.com/jup-ag/jupiter-swap-api-client", package = "jupiter-swap-api-client" }
log = "0.4"
pythnet-sdk = "2"
regex = "1.10"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
solana-account-decoder-client-types = "2"
solana-rpc-client = "2"
solana-rpc-client-api = "2"
solana-sdk = "2" 
solana-transaction-status = "2"
spl-associated-token-account = "7.0"
thiserror = "1"
tokio = { version = "1.48", features = ["full"] }
tokio-stream = "0.1.17"
tokio-tungstenite = { version = "0.28", features = ["native-tls"] }
yellowstone-grpc-client = { git = "https://github.com/rpcpool/yellowstone-grpc", rev = "660797" }
yellowstone-grpc-proto = { git = "https://github.com/rpcpool/yellowstone-grpc", rev = "660797" }
drift-pubsub-client = { version = "0.1.1", path = "crates/pubsub-client" }
titan-swap-api-client = { git = "https://github.com/0xahzam/titan-swap-api-client.git", optional = true }

[dev-dependencies]
bytes = "1"
hex-literal = "0.4"
solana-account-decoder = "2"
toml = "0.8"

[build-dependencies]
drift-idl-gen = { version = "0.2", path = "crates/drift-idl-gen" }

```

## File: crates/drift-idl-gen/src/custom_types.rs
```
// ****
// Custom type defintions
///
// these are not generated from IDL but are useful for better compatibility or utility
// ****

/// backwards compatible u128 deserializing data from rust <=1.76.0 when u/i128 was 8-byte aligned
/// https://solana.stackexchange.com/questions/7720/using-u128-without-sacrificing-alignment-8
#[derive(
    Default,
    PartialEq,
    AnchorSerialize,
    AnchorDeserialize,
    Serialize,
    Deserialize,
    Copy,
    Clone,
    bytemuck::Zeroable,
    bytemuck::Pod,
    Debug,
)]
#[repr(C)]
pub struct u128(pub [u8; 16]);

impl u128 {
    /// convert self into the std `u128` type
    pub fn as_u128(&self) -> std::primitive::u128 {
        std::primitive::u128::from_le_bytes(self.0)
    }
}

impl From<std::primitive::u128> for self::u128 {
    fn from(value: std::primitive::u128) -> Self {
        Self(value.to_le_bytes())
    }
}

/// backwards compatible i128 deserializing data from rust <=1.76.0 when u/i128 was 8-byte aligned
/// https://solana.stackexchange.com/questions/7720/using-u128-without-sacrificing-alignment-8
#[derive(
    Default,
    PartialEq,
    AnchorSerialize,
    AnchorDeserialize,
    Serialize,
    Deserialize,
    Copy,
    Clone,
    bytemuck::Zeroable,
    bytemuck::Pod,
    Debug,
)]
#[repr(C)]
pub struct i128(pub [u8; 16]);

impl i128 {
    /// convert self into the std `i128` type
    pub fn as_i128(&self) -> core::primitive::i128 {
        core::primitive::i128::from_le_bytes(self.0)
    }
}

impl From<core::primitive::i128> for i128 {
    fn from(value: core::primitive::i128) -> Self {
        Self(value.to_le_bytes())
    }
}

#[repr(transparent)]
#[derive(AnchorDeserialize, AnchorSerialize, Copy, Clone, PartialEq, Debug)]
pub struct Signature(pub [u8; 64]);

impl Default for Signature {
    fn default() -> Self {
        Self([0_u8; 64])
    }
}

impl serde::Serialize for Signature {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error> {
        serializer.serialize_bytes(&self.0)
    }
}

impl<'de> serde::Deserialize<'de> for Signature {
    fn deserialize<D: serde::Deserializer<'de>>(d: D) -> std::result::Result<Self, D::Error> {
        let s = <&[u8]>::deserialize(d)?;
        s.try_into()
            .map(Signature)
            .map_err(serde::de::Error::custom)
    }
}

impl anchor_lang::Space for Signature {
    const INIT_SPACE: usize = 8 * 64;
}

/// wrapper around fixed array types used for padding with `Default` implementation
#[repr(transparent)]
#[derive(AnchorDeserialize, AnchorSerialize, Copy, Clone, PartialEq)]
pub struct Padding<const N: usize>([u8; N]);
impl<const N: usize> Default for Padding<N> {
    fn default() -> Self {
        Self([0u8; N])
    }
}

impl<const N: usize> std::fmt::Debug for Padding<N> {
    fn fmt(&self, _f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // don't print anything for padding...
        Ok(())
    }
}

impl<const N: usize> anchor_lang::Space for Padding<N> {
    const INIT_SPACE: usize = 8 * N;
}

```

## File: crates/drift-idl-gen/src/lib.rs
```
use std::{
    fs::{self},
    io::Write,
    path::Path,
    process::{Command, Stdio},
};

use proc_macro2::TokenStream;
use quote::quote;
use serde::{Deserialize, Serialize};
use sha2::Digest;
use syn::{Ident, Type};

#[derive(Debug, Serialize, Deserialize)]
struct Idl {
    version: String,
    name: String,
    instructions: Vec<Instruction>,
    types: Vec<TypeDef>,
    accounts: Vec<AccountDef>,
    events: Vec<EventDef>,
    errors: Vec<ErrorDef>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Instruction {
    name: String,
    accounts: Vec<Account>,
    args: Vec<Arg>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Account {
    name: String,
    #[serde(rename = "isMut")]
    is_mut: bool,
    #[serde(rename = "isSigner")]
    is_signer: bool,
}

#[derive(Debug, Serialize, Deserialize)]
struct Arg {
    name: String,
    #[serde(rename = "type")]
    arg_type: ArgType,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
enum ArgType {
    Simple(String),
    Defined { defined: String },
    Array { array: (Box<ArgType>, usize) },
    Option { option: Box<ArgType> },
    Vec { vec: Box<ArgType> },
}

impl ArgType {
    fn to_rust_type(&self) -> String {
        match self {
            ArgType::Simple(t) => {
                // special cases likely from manual edits to IDL
                if t == "publicKey" {
                    "Pubkey".to_string()
                } else if t == "bytes" {
                    "Vec<u8>".to_string()
                } else if t == "string" {
                    "String".to_string()
                } else {
                    t.clone()
                }
            }
            ArgType::Defined { defined } => defined.clone(),
            ArgType::Array { array: (t, len) } => {
                let rust_type = t.to_rust_type();
                // this is a common signature representation
                if *len == 64_usize && rust_type == "u8" {
                    // [u8; 64] does not have a Default impl
                    "Signature".into()
                } else {
                    format!("[{}; {}]", t.to_rust_type(), len)
                }
            }
            ArgType::Option { option } => format!("Option<{}>", option.to_rust_type()),
            ArgType::Vec { vec } => format!("Vec<{}>", vec.to_rust_type()),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct TypeDef {
    name: String,
    #[serde(rename = "type")]
    type_def: TypeData,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "kind")]
enum TypeData {
    #[serde(rename = "struct")]
    Struct { fields: Vec<StructField> },
    #[serde(rename = "enum")]
    Enum { variants: Vec<EnumVariant> },
}

#[derive(Debug, Serialize, Deserialize)]
struct StructField {
    name: String,
    #[serde(rename = "type")]
    field_type: ArgType,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
enum EnumVariant {
    // NB: this must come before `Simple` (harder match -> easiest match)
    Complex {
        name: String,
        fields: Vec<StructField>,
    },
    Simple {
        name: String,
    },
}

#[derive(Debug, Serialize, Deserialize)]
struct AccountDef {
    name: String,
    #[serde(rename = "type")]
    account_type: AccountType,
}

#[derive(Debug, Serialize, Deserialize)]
struct AccountType {
    kind: String, // Typically "struct"
    fields: Vec<StructField>,
}

#[derive(Debug, Serialize, Deserialize)]
struct ErrorDef {
    code: u32,
    name: String,
    msg: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct EventDef {
    name: String,
    fields: Vec<EventField>,
}

#[derive(Debug, Serialize, Deserialize)]
struct EventField {
    name: String,
    #[serde(rename = "type")]
    field_type: ArgType,
    index: bool,
}

fn generate_idl_types(idl: &Idl) -> String {
    let mut instructions_tokens = quote! {};
    let mut types_tokens = quote! {};
    let mut accounts_tokens = quote! {};
    let mut errors_tokens = quote! {};
    let mut events_tokens = quote! {};
    let idl_version = syn::LitStr::new(&idl.version, proc_macro2::Span::call_site());

    // Generate enums and structs from the types section
    for type_def in &idl.types {
        let type_name = Ident::new(
            &capitalize_first_letter(&type_def.name),
            proc_macro2::Span::call_site(),
        );
        let type_tokens = match &type_def.type_def {
            TypeData::Enum { variants } => {
                let has_complex_first_variant = variants.iter().next().is_some_and(|v| match v {
                    EnumVariant::Complex { .. } => true,
                    _ => false,
                });

                let variant_tokens =
                    variants
                        .iter()
                        .enumerate()
                        .map(|(i, variant)| match variant {
                            EnumVariant::Simple { name } => {
                                let variant_name = Ident::new(name, proc_macro2::Span::call_site());
                                if i == 0 {
                                    quote! {
                                        #[default]
                                        #variant_name,
                                    }
                                } else {
                                    quote! {
                                        #variant_name,
                                    }
                                }
                            }
                            EnumVariant::Complex { name, fields } => {
                                let variant_name = Ident::new(name, proc_macro2::Span::call_site());
                                let field_tokens = fields.iter().map(|field| {
                                    let field_name = Ident::new(
                                        &to_snake_case(&field.name),
                                        proc_macro2::Span::call_site(),
                                    );
                                    let field_type: Type =
                                        syn::parse_str(&field.field_type.to_rust_type()).unwrap();
                                    quote! {
                                        #field_name: #field_type,
                                    }
                                });
                                if i == 0 && !has_complex_first_variant {
                                    quote! {
                                        #[default]
                                        #variant_name {
                                            #(#field_tokens)*
                                        },
                                    }
                                } else {
                                    quote! {
                                        #variant_name {
                                            #(#field_tokens)*
                                        },
                                    }
                                }
                            }
                        });

                if has_complex_first_variant {
                    quote! {
                        #[derive(AnchorSerialize, AnchorDeserialize, InitSpace, Serialize, Deserialize, Copy, Clone, Debug, PartialEq)]
                        pub enum #type_name {
                            #(#variant_tokens)*
                        }
                    }
                } else {
                    // TODO: need more work to derive 'Default' on complex enums, not currently required
                    quote! {
                        #[derive(AnchorSerialize, AnchorDeserialize, InitSpace, Serialize, Deserialize, Copy, Clone, Default, Debug, PartialEq)]
                        pub enum #type_name {
                            #(#variant_tokens)*
                        }
                    }
                }
            }
            TypeData::Struct { fields } => {
                let struct_name =
                    Ident::new(type_def.name.as_str(), proc_macro2::Span::call_site());
                let struct_fields = fields.iter().map(|field| {
                    let field_name =
                        Ident::new(&to_snake_case(&field.name), proc_macro2::Span::call_site());
                    let mut field_type: syn::Type =
                        syn::parse_str(&field.field_type.to_rust_type()).unwrap();

                    let mut serde_decorator = TokenStream::default();
                    // workaround for padding types preventing outertype from deriving 'Default'
                    if field_name.to_string().starts_with("padding") {
                        if let ArgType::Array { array: (_t, len) } = &field.field_type {
                            field_type = syn::parse_str(&format!("Padding<{len}>")).unwrap();
                            serde_decorator = quote! {
                                #[serde(skip)]
                            };
                        }
                    }

                    quote! {
                        #serde_decorator
                        pub #field_name: #field_type,
                    }
                });

                quote! {
                    #[repr(C)]
                    #[derive(AnchorSerialize, AnchorDeserialize, InitSpace, Serialize, Deserialize, Copy, Clone, Default, Debug, PartialEq)]
                    pub struct #struct_name {
                        #(#struct_fields)*
                    }
                }
            }
        };

        types_tokens = quote! {
            #types_tokens
            #type_tokens
        };
    }

    // Generate structs for accounts section
    for account in &idl.accounts {
        let struct_name = Ident::new(&account.name, proc_macro2::Span::call_site());

        let mut has_vec_field = false;
        let struct_fields: Vec<TokenStream> = account
            .account_type
            .fields
            .iter()
            .map(|field| {
                let field_name =
                    Ident::new(&to_snake_case(&field.name), proc_macro2::Span::call_site());
                if let ArgType::Vec { .. } = field.field_type {
                    has_vec_field = true;
                }
                let mut serde_decorator = TokenStream::new();
                let mut field_type: Type =
                    syn::parse_str(&field.field_type.to_rust_type()).unwrap();
                // workaround for padding types preventing outertype from deriving 'Default'
                if field_name.to_string().starts_with("padding") {
                    if let ArgType::Array { array: (_t, len) } = &field.field_type {
                        field_type = syn::parse_str(&format!("Padding<{len}>")).unwrap();
                        serde_decorator = quote! {
                            #[serde(skip)]
                        };
                    }
                }

                quote! {
                    #serde_decorator
                    pub #field_name: #field_type,
                }
            })
            .collect();

        let derive_tokens = if !has_vec_field {
            quote! {
                #[derive(AnchorSerialize, AnchorDeserialize, InitSpace, Serialize, Deserialize, Copy, Clone, Default, Debug, PartialEq)]
            }
        } else {
            // can't derive `Copy` on accounts with `Vec` field
            // `InitSpace` requires a 'max_len' but no point enforcing here if unset on program side
            quote! {
                #[derive(AnchorSerialize, AnchorDeserialize, Serialize, Deserialize, Clone, Default, Debug, PartialEq)]
            }
        };

        let zc_tokens = if !has_vec_field {
            // without copy can't derive the ZeroCopy trait
            quote! {
                #[automatically_derived]
                unsafe impl anchor_lang::__private::bytemuck::Pod for #struct_name {}
                #[automatically_derived]
                unsafe impl anchor_lang::__private::bytemuck::Zeroable for #struct_name {}
                #[automatically_derived]
                impl anchor_lang::ZeroCopy for #struct_name {}
            }
        } else {
            Default::default()
        };

        let discriminator: TokenStream = format!("{:?}", sighash("account", &account.name))
            .parse()
            .unwrap();
        let struct_def = quote! {
            #[repr(C)]
            #derive_tokens
            pub struct #struct_name {
                #(#struct_fields)*
            }
            #[automatically_derived]
            impl anchor_lang::Discriminator for #struct_name {
                const DISCRIMINATOR: &[u8] = &#discriminator;
            }
            #zc_tokens
            #[automatically_derived]
            impl anchor_lang::AccountSerialize for #struct_name {
                fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
                    if writer.write_all(Self::DISCRIMINATOR).is_err() {
                        return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                    }

                    if AnchorSerialize::serialize(self, writer).is_err() {
                        return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                    }

                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::AccountDeserialize for #struct_name {
                fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                    let given_disc = &buf[..8];
                    if Self::DISCRIMINATOR != given_disc {
                        return Err(anchor_lang::error!(anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch));
                    }
                    Self::try_deserialize_unchecked(buf)
                }

                fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                    let mut data: &[u8] = &buf[8..];
                    AnchorDeserialize::deserialize(&mut data)
                        .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
                }
            }
        };

        accounts_tokens = quote! {
            #accounts_tokens
            #struct_def
        };
    }

    // Generate structs for instructions
    for instr in &idl.instructions {
        let name = capitalize_first_letter(&instr.name);
        let fn_name = to_snake_case(&instr.name);
        let struct_name = Ident::new(&name, proc_macro2::Span::call_site());
        let fields = instr.args.iter().map(|arg| {
            let field_name = Ident::new(&to_snake_case(&arg.name), proc_macro2::Span::call_site());
            let field_type: Type = syn::parse_str(&arg.arg_type.to_rust_type()).unwrap();
            quote! {
                pub #field_name: #field_type,
            }
        });
        // https://github.com/coral-xyz/anchor/blob/e48e7e60a64de77d878cdb063965cf125bec741a/lang/syn/src/codegen/program/instruction.rs#L32
        let discriminator: TokenStream = format!("{:?}", sighash("global", &fn_name))
            .parse()
            .unwrap();
        let struct_def = quote! {
            #[derive(AnchorSerialize, AnchorDeserialize, Clone, Default)]
            pub struct #struct_name {
                #(#fields)*
            }
            #[automatically_derived]
            impl anchor_lang::Discriminator for #struct_name {
                const DISCRIMINATOR: &[u8] = &#discriminator;
            }
            #[automatically_derived]
            impl anchor_lang::InstructionData for #struct_name {}
        };

        instructions_tokens = quote! {
            #instructions_tokens
            #struct_def
        };

        let accounts = instr.accounts.iter().map(|acc| {
            let account_name =
                Ident::new(&to_snake_case(&acc.name), proc_macro2::Span::call_site());
            quote! {
                pub #account_name: Pubkey,
            }
        });

        let to_account_metas = instr.accounts.iter().map(|acc| {
            let account_name_str = to_snake_case(&acc.name);
            let account_name =
                Ident::new(&account_name_str, proc_macro2::Span::call_site());
            let is_mut: TokenStream = acc.is_mut.to_string().parse().unwrap();
            let is_signer: TokenStream = acc.is_signer.to_string().parse().unwrap();
            quote! {
                AccountMeta { pubkey: self.#account_name, is_signer: #is_signer, is_writable: #is_mut },
            }
        });

        let discriminator: TokenStream =
            format!("{:?}", sighash("account", &name)).parse().unwrap();
        let account_struct_def = quote! {
            #[repr(C)]
            #[derive(Copy, Clone, Default, AnchorSerialize, AnchorDeserialize, Serialize, Deserialize)]
            pub struct #struct_name {
                #(#accounts)*
            }
            #[automatically_derived]
            impl anchor_lang::Discriminator for #struct_name {
                const DISCRIMINATOR: &[u8] = &#discriminator;
            }
            #[automatically_derived]
            unsafe impl anchor_lang::__private::bytemuck::Pod for #struct_name {}
            #[automatically_derived]
            unsafe impl anchor_lang::__private::bytemuck::Zeroable for #struct_name {}
            #[automatically_derived]
            impl anchor_lang::ZeroCopy for #struct_name {}
            #[automatically_derived]
            impl anchor_lang::InstructionData for #struct_name {}
            #[automatically_derived]
            impl ToAccountMetas for #struct_name {
                fn to_account_metas(
                    &self,
                ) -> Vec<AccountMeta> {
                   vec![
                        #(#to_account_metas)*
                    ]
                }
            }
            #[automatically_derived]
            impl anchor_lang::AccountSerialize for #struct_name {
                fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
                    if writer.write_all(Self::DISCRIMINATOR).is_err() {
                        return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                    }

                    if AnchorSerialize::serialize(self, writer).is_err() {
                        return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                    }

                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::AccountDeserialize for #struct_name {
                fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                    let given_disc = &buf[..8];
                    if Self::DISCRIMINATOR != given_disc {
                        return Err(anchor_lang::error!(anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch));
                    }
                    Self::try_deserialize_unchecked(buf)
                }

                fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                    let mut data: &[u8] = &buf[8..];
                    AnchorDeserialize::deserialize(&mut data)
                        .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
                }
            }
        };

        accounts_tokens = quote! {
            #accounts_tokens
            #account_struct_def
        };
    }

    // Generate enum for errors
    let error_variants = idl.errors.iter().map(|error| {
        let variant_name = Ident::new(&error.name, proc_macro2::Span::call_site());
        let error_msg = &error.msg;
        quote! {
            #[msg(#error_msg)]
            #variant_name,
        }
    });

    let error_enum = quote! {
        #[derive(PartialEq)]
        #[error_code]
        pub enum ErrorCode {
            #(#error_variants)*
        }
    };

    errors_tokens = quote! {
        #errors_tokens
        #error_enum
    };

    // Generate event structs from the events section
    for event in &idl.events {
        let struct_name = Ident::new(&event.name, proc_macro2::Span::call_site());
        let fields = event.fields.iter().map(|field| {
            let field_name =
                Ident::new(&to_snake_case(&field.name), proc_macro2::Span::call_site());
            let field_type: Type = syn::parse_str(&field.field_type.to_rust_type()).unwrap();
            quote! {
                pub #field_name: #field_type,
            }
        });

        let struct_def = quote! {
            #[derive(Clone, Debug, PartialEq, Default)]
            #[event]
            pub struct #struct_name {
                #(#fields)*
            }
        };

        events_tokens = quote! {
            #events_tokens
            #struct_def
        };
    }

    let custom_types: TokenStream = include_str!("custom_types.rs")
        .parse()
        .expect("custom_types valid rust");

    // Wrap generated code in modules with necessary imports
    let output = quote! {
        #![allow(unused_imports)]
        //!
        //! Auto-generated IDL types, manual edits do not persist (see `crates/drift-idl-gen`)
        //!
        use anchor_lang::{prelude::{account, AnchorSerialize, AnchorDeserialize, InitSpace, event, error_code, msg, borsh::{self}}, Discriminator};
        // use solana-sdk Pubkey, the vendored anchor-lang Pubkey maybe behind
        use solana_sdk::{instruction::AccountMeta, pubkey::Pubkey};
        use serde::{Serialize, Deserialize};

        pub const IDL_VERSION: &str = #idl_version;

        use self::traits::ToAccountMetas;
        pub mod traits {
            use solana_sdk::instruction::AccountMeta;

            /// This is distinct from the anchor_lang version of the trait
            /// reimplemented to ensure the types used are from `solana`` crates _not_ the anchor_lang vendored versions which may be lagging behind
            pub trait ToAccountMetas {
                fn to_account_metas(&self) -> Vec<AccountMeta>;
            }
        }

        pub mod instructions {
            //! IDL instruction types
            use super::{*, types::*};

            #instructions_tokens
        }

        pub mod types {
            //! IDL types
            use std::ops::Mul;

            use super::*;
            #custom_types

            #types_tokens
        }

        pub mod accounts {
            //! IDL Account types
            use super::{*, types::*};

            #accounts_tokens
        }

        pub mod errors {
            //! IDL error types
            use super::{*, types::*};

            #errors_tokens
        }

        pub mod events {
            //! IDL event types
            use super::{*, types::*};
            #events_tokens
        }
    };

    output.to_string()
}

fn sighash(namespace: &str, name: &str) -> [u8; 8] {
    let preimage = format!("{namespace}:{name}");
    let mut hasher = sha2::Sha256::default();
    let mut sighash = <[u8; 8]>::default();
    hasher.update(preimage.as_bytes());
    let digest = hasher.finalize();
    sighash.copy_from_slice(&digest.as_slice()[..8]);

    sighash
}

fn to_snake_case(s: &str) -> String {
    let mut snake_case = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i != 0 {
                snake_case.push('_');
            }
            snake_case.push(c.to_ascii_lowercase());
        } else {
            snake_case.push(c);
        }
    }
    snake_case
}

fn capitalize_first_letter(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

fn format_rust_code(code: &str) -> String {
    let mut rustfmt = Command::new("rustfmt")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to run rustfmt");
    {
        let stdin = rustfmt.stdin.as_mut().expect("Failed to open stdin");
        stdin
            .write_all(code.as_bytes())
            .expect("Failed to write to stdin");
    }

    let output = rustfmt
        .wait_with_output()
        .expect("Failed to read rustfmt output");

    String::from_utf8(output.stdout).expect("rustfmt output is not valid UTF-8")
}

/// Generate rust types from IDL json
///
/// Returns (IDL Version, IDL rs code)
pub fn generate_rust_types(idl_path: &Path) -> Result<String, Box<dyn std::error::Error>> {
    // Load the JSON file
    let data = fs::read_to_string(idl_path)?;
    let idl: Idl = serde_json::from_str(&data)?;

    // Generate Rust structs organized into modules
    let rust_idl_types = format_rust_code(&generate_idl_types(&idl));
    Ok(rust_idl_types)
}

```

## File: crates/pubsub-client/src/lib.rs
```
use std::{collections::BTreeMap, time::Duration};

use futures_util::{
    future::{ready, BoxFuture, FutureExt},
    sink::SinkExt,
    stream::{self, BoxStream, StreamExt},
};
use log::*;
use serde::de::DeserializeOwned;
use serde_json::{json, Value};
use solana_account_decoder_client_types::UiAccount;
use solana_rpc_client_api::{
    config::{
        RpcAccountInfoConfig, RpcBlockSubscribeConfig, RpcBlockSubscribeFilter,
        RpcProgramAccountsConfig, RpcSignatureSubscribeConfig, RpcTransactionLogsConfig,
        RpcTransactionLogsFilter,
    },
    error_object::RpcErrorObject,
    response::{
        Response as RpcResponse, RpcBlockUpdate, RpcKeyedAccount, RpcLogsResponse,
        RpcSignatureResult, RpcVote, SlotInfo, SlotUpdate,
    },
};
use solana_sdk::{clock::Slot, pubkey::Pubkey, signature::Signature};
use thiserror::Error;
use tokio::{
    sync::{
        mpsc::{self, UnboundedSender},
        oneshot,
    },
    task::JoinHandle,
};
use tokio_stream::wrappers::UnboundedReceiverStream;
use tokio_tungstenite::{
    connect_async,
    tungstenite::{
        protocol::frame::{coding::CloseCode, CloseFrame},
        Message,
    },
};
use url::Url;

pub type PubsubClientResult<T = ()> = Result<T, PubsubClientError>;

#[derive(Debug, Error)]
pub enum PubsubClientError {
    #[error("url parse error")]
    UrlParseError(#[from] url::ParseError),

    #[error("unable to connect to server")]
    ConnectionError(tokio_tungstenite::tungstenite::Error),

    #[error("websocket error")]
    WsError(#[from] tokio_tungstenite::tungstenite::Error),

    #[error("connection closed (({0})")]
    ConnectionClosed(String),

    #[error("json parse error")]
    JsonParseError(#[from] serde_json::error::Error),

    #[error("subscribe failed: {reason}")]
    SubscribeFailed { reason: String, message: String },

    #[error("unexpected message format: {0}")]
    UnexpectedMessageError(String),

    #[error("request failed: {reason}")]
    RequestFailed { reason: String, message: String },

    #[error("request error: {0}")]
    RequestError(String),

    #[error("could not find subscription id: {0}")]
    UnexpectedSubscriptionResponse(String),

    #[error("could not find node version: {0}")]
    UnexpectedGetVersionResponse(String),
}

type UnsubscribeFn = Box<dyn FnOnce() -> BoxFuture<'static, ()> + Send>;
type SubscribeResponseMsg =
    Result<(mpsc::UnboundedReceiver<Value>, UnsubscribeFn), PubsubClientError>;
type SubscribeRequestMsg = (String, Value, oneshot::Sender<SubscribeResponseMsg>);
type SubscribeResult<'a, T> = PubsubClientResult<(BoxStream<'a, T>, UnsubscribeFn)>;
type RequestMsg = (
    String,
    Value,
    oneshot::Sender<Result<Value, PubsubClientError>>,
);

#[derive(Clone)]
struct SubscriptionInfo {
    sender: UnboundedSender<Value>,
    payload: String,
}

/// A client for subscribing to messages from the RPC server.
///
/// See the [module documentation][self].
#[derive(Debug)]
pub struct PubsubClient {
    subscribe_sender: mpsc::UnboundedSender<SubscribeRequestMsg>,
    _request_sender: mpsc::UnboundedSender<RequestMsg>,
    shutdown_sender: oneshot::Sender<()>,
    ws: JoinHandle<Result<(), PubsubClientError>>,
    url: Url,
}

impl PubsubClient {
    pub async fn new(url: &str) -> PubsubClientResult<Self> {
        let url = Url::parse(url)?;

        let (subscribe_sender, subscribe_receiver) = mpsc::unbounded_channel();
        let (_request_sender, request_receiver) = mpsc::unbounded_channel();
        let (shutdown_sender, shutdown_receiver) = oneshot::channel();

        // spawn Ws manager task
        let ws_handle = tokio::spawn(PubsubClient::run_ws(
            url.clone(),
            subscribe_receiver,
            request_receiver,
            shutdown_receiver,
        ));

        #[allow(clippy::used_underscore_binding)]
        Ok(Self {
            subscribe_sender,
            _request_sender,
            shutdown_sender,
            ws: ws_handle,
            url,
        })
    }

    /// Returns the URL of the underlying Ws
    pub fn url(&self) -> Url {
        self.url.clone()
    }

    /// Returns true if the underlying Ws connection task is running
    ///
    /// NB: the actual Ws may be either connected or reconnecting
    pub fn is_running(&self) -> bool {
        !self.ws.is_finished()
    }

    pub async fn shutdown(self) -> PubsubClientResult {
        let _ = self.shutdown_sender.send(());
        self.ws.await.unwrap() // WS future should not be cancelled or panicked
    }

    async fn subscribe<'a, T>(&self, operation: &str, params: Value) -> SubscribeResult<'a, T>
    where
        T: DeserializeOwned + Send + 'a,
    {
        let (response_sender, response_receiver) = oneshot::channel();
        self.subscribe_sender
            .send((operation.to_string(), params.clone(), response_sender))
            .map_err(|err| PubsubClientError::ConnectionClosed(err.to_string()))?;

        let (notifications, unsubscribe) = response_receiver
            .await
            .map_err(|err| PubsubClientError::ConnectionClosed(err.to_string()))??;

        Ok((
            UnboundedReceiverStream::new(notifications)
                .filter_map(|value| ready(serde_json::from_value::<T>(value).ok()))
                .boxed(),
            unsubscribe,
        ))
    }

    /// Subscribe to account events.
    ///
    /// Receives messages of type [`UiAccount`] when an account's lamports or data changes.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`accountSubscribe`] RPC method.
    ///
    /// [`accountSubscribe`]: https://solana.com/docs/rpc/websocket#accountsubscribe
    pub async fn account_subscribe(
        &self,
        pubkey: &Pubkey,
        config: Option<RpcAccountInfoConfig>,
    ) -> SubscribeResult<'_, RpcResponse<UiAccount>> {
        let params = json!([pubkey.to_string(), config]);
        self.subscribe("account", params).await
    }

    /// Subscribe to block events.
    ///
    /// Receives messages of type [`RpcBlockUpdate`] when a block is confirmed or finalized.
    ///
    /// This method is disabled by default. It can be enabled by passing
    /// `--rpc-pubsub-enable-block-subscription` to `agave-validator`.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`blockSubscribe`] RPC method.
    ///
    /// [`blockSubscribe`]: https://solana.com/docs/rpc/websocket#blocksubscribe
    pub async fn block_subscribe(
        &self,
        filter: RpcBlockSubscribeFilter,
        config: Option<RpcBlockSubscribeConfig>,
    ) -> SubscribeResult<'_, RpcResponse<RpcBlockUpdate>> {
        self.subscribe("block", json!([filter, config])).await
    }

    /// Subscribe to transaction log events.
    ///
    /// Receives messages of type [`RpcLogsResponse`] when a transaction is committed.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`logsSubscribe`] RPC method.
    ///
    /// [`logsSubscribe`]: https://solana.com/docs/rpc/websocket#logssubscribe
    pub async fn logs_subscribe(
        &self,
        filter: RpcTransactionLogsFilter,
        config: RpcTransactionLogsConfig,
    ) -> SubscribeResult<'_, RpcResponse<RpcLogsResponse>> {
        self.subscribe("logs", json!([filter, config])).await
    }

    /// Subscribe to program account events.
    ///
    /// Receives messages of type [`RpcKeyedAccount`] when an account owned
    /// by the given program changes.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`programSubscribe`] RPC method.
    ///
    /// [`programSubscribe`]: https://solana.com/docs/rpc/websocket#programsubscribe
    pub async fn program_subscribe(
        &self,
        pubkey: &Pubkey,
        config: Option<RpcProgramAccountsConfig>,
    ) -> SubscribeResult<'_, RpcResponse<RpcKeyedAccount>> {
        let params = json!([pubkey.to_string(), config]);
        self.subscribe("program", params).await
    }

    /// Subscribe to vote events.
    ///
    /// Receives messages of type [`RpcVote`] when a new vote is observed. These
    /// votes are observed prior to confirmation and may never be confirmed.
    ///
    /// This method is disabled by default. It can be enabled by passing
    /// `--rpc-pubsub-enable-vote-subscription` to `agave-validator`.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`voteSubscribe`] RPC method.
    ///
    /// [`voteSubscribe`]: https://solana.com/docs/rpc/websocket#votesubscribe
    pub async fn vote_subscribe(&self) -> SubscribeResult<'_, RpcVote> {
        self.subscribe("vote", json!([])).await
    }

    /// Subscribe to root events.
    ///
    /// Receives messages of type [`Slot`] when a new [root] is set by the
    /// validator.
    ///
    /// [root]: https://solana.com/docs/terminology#root
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`rootSubscribe`] RPC method.
    ///
    /// [`rootSubscribe`]: https://solana.com/docs/rpc/websocket#rootsubscribe
    pub async fn root_subscribe(&self) -> SubscribeResult<'_, Slot> {
        self.subscribe("root", json!([])).await
    }

    /// Subscribe to transaction confirmation events.
    ///
    /// Receives messages of type [`RpcSignatureResult`] when a transaction
    /// with the given signature is committed.
    ///
    /// This is a subscription to a single notification. It is automatically
    /// cancelled by the server once the notification is sent.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`signatureSubscribe`] RPC method.
    ///
    /// [`signatureSubscribe`]: https://solana.com/docs/rpc/websocket#signaturesubscribe
    pub async fn signature_subscribe(
        &self,
        signature: &Signature,
        config: Option<RpcSignatureSubscribeConfig>,
    ) -> SubscribeResult<'_, RpcResponse<RpcSignatureResult>> {
        let params = json!([signature.to_string(), config]);
        self.subscribe("signature", params).await
    }

    /// Subscribe to slot events.
    ///
    /// Receives messages of type [`SlotInfo`] when a slot is processed.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`slotSubscribe`] RPC method.
    ///
    /// [`slotSubscribe`]: https://solana.com/docs/rpc/websocket#slotsubscribe
    pub async fn slot_subscribe(&self) -> SubscribeResult<'_, SlotInfo> {
        self.subscribe("slot", json!([])).await
    }

    /// Subscribe to slot update events.
    ///
    /// Receives messages of type [`SlotUpdate`] when various updates to a slot occur.
    ///
    /// Note that this method operates differently than other subscriptions:
    /// instead of sending the message to a receiver on a channel, it accepts a
    /// `handler` callback that processes the message directly. This processing
    /// occurs on another thread.
    ///
    /// # RPC Reference
    ///
    /// This method corresponds directly to the [`slotUpdatesSubscribe`] RPC method.
    ///
    /// [`slotUpdatesSubscribe`]: https://solana.com/docs/rpc/websocket#slotsupdatessubscribe
    pub async fn slot_updates_subscribe(&self) -> SubscribeResult<'_, SlotUpdate> {
        self.subscribe("slotsUpdates", json!([])).await
    }

    async fn run_ws(
        url: Url,
        mut subscribe_receiver: mpsc::UnboundedReceiver<SubscribeRequestMsg>,
        mut request_receiver: mpsc::UnboundedReceiver<RequestMsg>,
        mut shutdown_receiver: oneshot::Receiver<()>,
    ) -> PubsubClientResult {
        // manage Ws requests and forward subscription messages to subscribers
        // this loop will retry indefinitely unless the consumer invokes `shutdown` or successive failures exceed maximum
        let max_retry_count = 3;
        let mut retry_count = 0;

        // all existing subscriptions here
        let mut request_id: u64 = 0;
        let mut subscriptions = BTreeMap::<u64, SubscriptionInfo>::new();
        let mut request_id_to_sid = BTreeMap::<u64, u64>::new();
        let (unsubscribe_sender, mut unsubscribe_receiver) = mpsc::unbounded_channel();

        'reconnect: loop {
            log::debug!(target: "ws", "PubsubClient connecting: {:?}", url.as_str());
            let mut ws = match connect_async(url.as_str()).await {
                Ok((ws, response)) => {
                    if response.status().is_server_error() || response.status().is_client_error() {
                        log::warn!(target: "ws", "couldn't reconnect: {response:?}");
                        retry_count += 1;
                        let delay = 2_u64.pow(2 + retry_count);
                        info!(target: "ws", "PubsubClient trying reconnect after {delay}s, attempt: {retry_count}/{max_retry_count}");
                        tokio::time::sleep(Duration::from_secs(delay)).await;
                        continue 'reconnect;
                    }

                    retry_count = 0;
                    ws
                }
                Err(err) => {
                    log::warn!(target: "ws", "couldn't reconnect: {err:?}");
                    if retry_count >= max_retry_count {
                        log::error!(target: "ws", "reached max reconnect attempts: {err:?}");
                        panic!("PubsubCliwnt reached max reconnect attempts: {err:?}");
                    }
                    retry_count += 1;
                    let delay = 2_u64.pow(2 + retry_count);
                    info!(target: "ws", "PubsubClient trying reconnect after {delay}s, attempt: {retry_count}/{max_retry_count}");
                    tokio::time::sleep(Duration::from_secs(delay)).await;
                    continue 'reconnect;
                }
            };

            let mut inflight_subscribes =
                BTreeMap::<u64, (String, String, oneshot::Sender<SubscribeResponseMsg>)>::new();
            let mut inflight_unsubscribes = BTreeMap::<u64, oneshot::Sender<()>>::new();
            let mut inflight_requests = BTreeMap::<u64, oneshot::Sender<_>>::new();

            // resend subscriptions
            if !subscriptions.is_empty() {
                info!(target: "ws", "resubscribing: {:?}", subscriptions.values().map(|x| x.payload.clone()).collect::<Vec<String>>());
                if let Err(err) = ws
                    .send_all(&mut stream::iter(
                        subscriptions
                            .values()
                            .cloned()
                            .map(|s| Ok(Message::text(s.payload))),
                    ))
                    .await
                {
                    error!(target: "ws", "PubsubClient failed resubscribing: {err:?}");
                    continue 'reconnect;
                }
            }

            let mut liveness_check = tokio::time::interval(Duration::from_secs(60));
            let _ = liveness_check.tick().await;

            let mut heartbeat = tokio::time::interval(Duration::from_secs(30));
            let _ = heartbeat.tick().await;

            'manager: loop {
                tokio::select! {
                    biased;
                    // Send close on shutdown signal
                    _ = (&mut shutdown_receiver) => {
                        log::info!(target: "ws", "PubsubClient received shutdown");
                        let frame = CloseFrame { code: CloseCode::Normal, reason: "".into() };
                        let _ = ws.send(Message::Close(Some(frame))).await;
                        let _ = ws.flush().await;
                        break 'reconnect Ok(());
                    },
                    // Read incoming WebSocket message
                    next_msg = ws.next() => {
                        liveness_check.reset();
                        let msg = match next_msg {
                            Some(Ok(msg)) => msg,
                            Some(Err(err)) => {
                                log::warn!(target: "ws", "PubsubClient disconnected: {err:?}");
                                break 'manager
                            }
                            None => {
                                log::debug!(target: "ws", "PubsubClient disconnected");
                                break 'manager
                            },
                        };
                        trace!("ws.next(): {:?}", &msg);

                        // Get text from the message
                        let text = match msg {
                            Message::Text(ref text) => text,
                            Message::Close(_frame) => break 'manager,
                            Message::Ping(_) | Message::Pong(_) | Message::Binary(_) | Message::Frame(_) => continue 'manager,
                        };

                        // Notification, example:
                        // `{"jsonrpc":"2.0","method":"logsNotification","params":{"result":{...},"subscription":3114862}}`
                        let params = gjson::get(text, "params");
                        if params.exists() {
                            let sid = params.get("subscription").u64();
                            let mut unsubscribe_required = false;

                            if let Some(sub) = subscriptions.get(&sid) {
                                let result = params.get("result");
                                if result.exists() && sub.sender.send(serde_json::from_str(result.json()).expect("valid json")).is_err() {
                                    unsubscribe_required = true;
                                }
                            } else {
                                unsubscribe_required = true;
                            }

                            if unsubscribe_required {
                                let method = gjson::get(text, "method");
                                if let Some(operation) = method.str().strip_suffix("Notification") {
                                    let (response_sender, _response_receiver) = oneshot::channel();
                                    let _ = unsubscribe_sender.send((operation.to_string(), sid, response_sender));
                                }
                            }
                            // done processing notification
                            continue 'manager;
                        }

                        // Subscribe/Unsubscribe response, example:
                        // `{"jsonrpc":"2.0","result":5308752,"id":1}`
                        let id = gjson::get(text, "id");
                        if id.exists() {
                            let err = gjson::get(text, "error");
                            let err = if err.exists() {
                                match serde_json::from_str::<RpcErrorObject>(err.json()) {
                                    Ok(rpc_error_object) => {
                                        Some(format!("{} ({})",  rpc_error_object.message, rpc_error_object.code))
                                    }
                                    Err(e) => Some(format!(
                                        "Failed to deserialize RPC error response: {} [{e}]", err.str(),
                                    ))
                                }
                            } else {
                                None
                            };

                            let id = id.u64();
                            if let Some(response_sender) = inflight_requests.remove(&id) {
                                match err {
                                    Some(reason) => {
                                        let _ = response_sender.send(Err(PubsubClientError::RequestFailed { reason, message: text.to_string()}));
                                    },
                                    None => {
                                        let json_result = gjson::get(text, "result");
                                        let json_result_value = if json_result.exists() {
                                            Ok(serde_json::from_str::<Value>(json_result.json()).unwrap())
                                        } else {
                                            Err(PubsubClientError::RequestFailed { reason: "missing `result` field".into(), message: text.to_string() })
                                        };

                                        if let Err(err) = response_sender.send(json_result_value) {
                                            log::warn!(target: "ws", "Ws request failed: {err:?}");
                                            break 'manager;
                                        }
                                    }
                                }
                            } else if let Some(response_sender) = inflight_unsubscribes.remove(&id) {
                                let _ = response_sender.send(()); // do not care if receiver is closed
                            } else if let Some((operation, payload, response_sender)) = inflight_subscribes.remove(&id) {
                                match err {
                                    Some(reason) => {
                                        let _ = response_sender.send(Err(PubsubClientError::SubscribeFailed { reason, message: text.to_string()}));
                                    },
                                    None => {
                                        // Subscribe Id
                                        let sid = gjson::get(text, "result");
                                        if !sid.exists() {
                                            return Err(PubsubClientError::SubscribeFailed { reason: "invalid `result` field".into(), message: text.to_string() });
                                        }
                                        let sid = sid.u64();

                                        // Create notifications channel and unsubscribe function
                                        let (notifications_sender, notifications_receiver) = mpsc::unbounded_channel();
                                        let unsubscribe_sender = unsubscribe_sender.clone();
                                        let unsubscribe = Box::new(move || async move {
                                            let (response_sender, response_receiver) = oneshot::channel();
                                            // do nothing if ws already closed
                                            if unsubscribe_sender.send((operation, id, response_sender)).is_ok() {
                                                let _ = response_receiver.await; // channel can be closed only if ws is closed
                                            }
                                        }.boxed());

                                        if response_sender.send(Ok((notifications_receiver, unsubscribe))).is_err() {
                                            break 'manager;
                                        }
                                        log::debug!(target: "ws", "subscription added: {sid:?}");
                                        request_id_to_sid.insert(id, sid);
                                        subscriptions.insert(sid, SubscriptionInfo {
                                            sender: notifications_sender,
                                            payload,
                                        });
                                    }
                                }
                            } else if let Some(previous_sid) = request_id_to_sid.remove(&id) {
                                match err {
                                    Some(reason) => {
                                        log::error!(target: "ws", "resubscription failed: {:?}, {reason:?}", text);
                                        panic!();
                                    },
                                    None => {
                                        // Subscribe Id
                                        let sid = gjson::get(text, "result");
                                        if !sid.exists() {
                                            log::error!(target: "ws", "resubscription failed. invalid `result` field: {:?}", text);
                                            panic!();
                                        }
                                        let new_sid = sid.u64();

                                        info!(target: "ws", "resubscribed: {previous_sid:>} => {new_sid:?}");
                                        request_id_to_sid.insert(id, new_sid);
                                        let info = subscriptions.remove(&previous_sid).unwrap();
                                        subscriptions.insert(
                                            new_sid,
                                            info
                                        );
                                    }
                                }
                            } else {
                                error!(target: "ws", "PubSubClient received unknown request id: {id}");
                                break 'manager;
                            }
                            continue 'manager;
                        }
                    }
                    // Read message for subscribe
                    subscribe = subscribe_receiver.recv() => {
                        let (operation, params, response_sender) = subscribe.expect("subscribe channel");
                        request_id += 1;
                        let method = format!("{operation}Subscribe");
                        let text = json!({"jsonrpc":"2.0","id":request_id,"method":method,"params":params}).to_string();
                        if let Err(ref err) = ws.send(Message::Text(text.clone().into())).await {
                            log::warn!(target: "ws", "sending subscribe failed, {text}, {err:?}");
                            break 'manager;
                        }
                        inflight_subscribes.insert(request_id, (operation, text, response_sender));
                    },
                    // Read message for unsubscribe
                   unsubscribe = unsubscribe_receiver.recv() => {
                        let (operation, id, response_sender) = unsubscribe.expect("unsub channel");
                        if let Some(sid) = request_id_to_sid.remove(&id) {
                            subscriptions.remove(&sid);
                            request_id += 1;
                            let method = format!("{operation}Unsubscribe");
                            let text = json!({"jsonrpc":"2.0","id":request_id,"method":method,"params":[sid]}).to_string();
                            if let Err(err) = ws.send(Message::Text(text.clone().into())).await {
                                log::warn!(target: "ws", "sending unsubscribe failed: {text}, {err:?}");
                            }
                            inflight_unsubscribes.insert(request_id, response_sender);
                        }
                    },
                    // Read message for other requests
                    request = request_receiver.recv() => {
                        let (method, params, response_sender) = request.expect("request channel");
                        request_id += 1;
                        let text = json!({"jsonrpc":"2.0","id":request_id,"method":method,"params":params}).to_string();
                        if let Err(err) = ws.send(Message::Text(text.into())).await {
                            log::warn!(target: "ws", "sending request failed. {err:?}");
                        }
                        inflight_requests.insert(request_id, response_sender);
                    },
                    _ = heartbeat.tick() => {
                        ws.send(Message::Ping(Default::default())).await?;
                    },
                    _ = liveness_check.tick() => {
                        warn!(target: "ws", "PubsubClient timed out");
                        break 'manager;
                    }
                }
            }
            log::debug!(target: "ws", "manager finished");
        }
    }
}

```

## File: crates/src/account_map.rs
```
//! Hybrid solana account map backed by Ws or RPC polling
use std::{
    ops::Deref,
    sync::{Arc, Mutex},
    time::Duration,
};

use anchor_lang::Discriminator;
use bytemuck::Pod;
use dashmap::DashMap;
use drift_pubsub_client::PubsubClient;
use log::debug;
use solana_account_decoder_client_types::UiAccountEncoding;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_rpc_client_api::{
    config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},
    filter::RpcFilterType,
};
use solana_sdk::{clock::Slot, commitment_config::CommitmentConfig, pubkey::Pubkey};

use crate::{
    constants::PROGRAM_ID,
    grpc::AccountUpdate,
    polled_account_subscriber::PolledAccountSubscriber,
    types::{DataAndSlot, EMPTY_ACCOUNT_CALLBACK},
    websocket_account_subscriber::WebsocketAccountSubscriber,
    SdkResult, UnsubHandle,
};

const LOG_TARGET: &str = "accountmap";

#[derive(Clone, Default)]
pub struct AccountSlot {
    raw: Arc<[u8]>,
    slot: Slot,
}

/// Set of subscriptions to network accounts
///
/// Accounts are subscribed by either Ws or polling at fixed intervals
pub struct AccountMap {
    pubsub: Arc<PubsubClient>,
    rpc: Arc<RpcClient>,
    commitment: CommitmentConfig,
    inner: Arc<DashMap<Pubkey, AccountSlot, ahash::RandomState>>,
    subscriptions: Arc<DashMap<Pubkey, AccountSub<Subscribed>, ahash::RandomState>>,
}

impl AccountMap {
    pub fn new(
        pubsub: Arc<PubsubClient>,
        rpc: Arc<RpcClient>,
        commitment: CommitmentConfig,
    ) -> Self {
        Self {
            pubsub,
            rpc,
            commitment,
            inner: Arc::default(),
            subscriptions: Arc::default(),
        }
    }
    pub fn iter_accounts_with<'a, T: Pod + Discriminator>(
        &self,
        mut f: impl FnMut(&Pubkey, &T, u64),
    ) {
        self.inner
            .iter()
            .filter(|x| &x.raw[..8] == T::DISCRIMINATOR)
            .for_each(|x| f(x.key(), crate::utils::deser_zero_copy(&x.raw), x.slot))
    }
    /// Subscribe account with Ws
    ///
    /// * `account` pubkey to subscribe
    ///
    pub async fn subscribe_account(&self, account: &Pubkey) -> SdkResult<()> {
        self.subscribe_account_inner(account, EMPTY_ACCOUNT_CALLBACK)
            .await
    }

    /// Subscribe account with Ws callback
    ///
    /// * `account` pubkey to subscribe
    /// * `on_account` callback function
    ///
    pub async fn subscribe_account_with_callback<F>(
        &self,
        account: &Pubkey,
        on_account: F,
    ) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        self.subscribe_account_inner(account, on_account).await
    }

    /// Subscribe account with Ws - inner implementation
    ///
    /// * `account` pubkey to subscribe
    /// * `on_account` callback function
    ///
    async fn subscribe_account_inner<F>(&self, account: &Pubkey, on_account: F) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        if self.inner.contains_key(account) {
            return Ok(());
        }
        debug!(target: LOG_TARGET, "subscribing: {account:?}");

        let user = AccountSub::new(Arc::clone(&self.pubsub), self.commitment, *account);
        let sub = user.subscribe(Arc::clone(&self.inner), on_account).await?;
        self.subscriptions.insert(*account, sub);

        Ok(())
    }

    /// Subscribe account with RPC polling
    ///
    /// * `account` pubkey to subscribe
    /// * `interval` to poll the account
    ///
    pub async fn subscribe_account_polled(
        &self,
        account: &Pubkey,
        interval: Option<Duration>,
    ) -> SdkResult<()> {
        self.subscribe_account_polled_inner(account, interval, EMPTY_ACCOUNT_CALLBACK)
            .await
    }

    pub async fn subscribe_account_polled_with_callback<F>(
        &self,
        account: &Pubkey,
        interval: Option<Duration>,
        on_account: F,
    ) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        self.subscribe_account_polled_inner(account, interval, on_account)
            .await
    }

    /// Subscribe account with RPC polling - inner implementation
    ///
    /// * `account` pubkey to subscribe
    /// * `interval` to poll the account
    /// * `on_account` callback function
    ///
    async fn subscribe_account_polled_inner<F>(
        &self,
        account: &Pubkey,
        interval: Option<Duration>,
        on_account: F,
    ) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        if self.inner.contains_key(account) {
            return Ok(());
        }
        debug!(
            target: LOG_TARGET,
            "subscribing: {account:?} @ {interval:?}"
        );

        let user = AccountSub::polled(Arc::clone(&self.rpc), *account, interval);
        let sub = user.subscribe(Arc::clone(&self.inner), on_account).await?;
        self.subscriptions.insert(*account, sub);

        Ok(())
    }

    /// On account hook for gRPC subscriber
    pub fn on_account_fn(&self) -> impl Fn(&AccountUpdate) {
        let accounts = Arc::clone(&self.inner);
        let subscriptions = Arc::clone(&self.subscriptions);
        move |update| {
            if update.lamports == 0 {
                accounts.remove(&update.pubkey);
                return;
            }
            accounts
                .entry(update.pubkey)
                .and_modify(|x| {
                    x.slot = update.slot;
                    x.raw = Arc::from(update.data);
                })
                .or_insert({
                    subscriptions.insert(
                        update.pubkey,
                        AccountSub {
                            pubkey: update.pubkey,
                            subscription: SubscriptionImpl::Grpc,
                            state: Subscribed {
                                unsub: Mutex::default(),
                            },
                        },
                    );
                    AccountSlot {
                        slot: update.slot,
                        raw: Arc::from(update.data),
                    }
                });
        }
    }
    /// Unsubscribe user account
    pub fn unsubscribe_account(&self, account: &Pubkey) {
        if let Some((acc, sub)) = self.subscriptions.remove(account) {
            debug!(target: LOG_TARGET, "unsubscribing: {acc:?}");
            self.inner.remove(account);
            let _ = sub.unsubscribe();
        }
    }
    /// Return data of the given `account` as T, if it exists
    pub fn account_data<T: Pod>(&self, account: &Pubkey) -> Option<T> {
        self.account_data_and_slot(account).map(|x| x.data)
    }
    /// Return data of the given `account` as T and slot, if it exists
    pub fn account_data_and_slot<T: Pod>(&self, account: &Pubkey) -> Option<DataAndSlot<T>> {
        self.inner.get(account).map(|x| {
            let arc = Arc::clone(&x.raw);
            DataAndSlot {
                slot: x.slot,
                data: *AccountRef {
                    arc,
                    _marker: std::marker::PhantomData,
                },
            }
        })
    }

    pub async fn sync_stats_accounts(&self) -> SdkResult<()> {
        // TODO: rust sdk does not surface with_context slot on GPA
        let slot = self
            .rpc
            .get_slot_with_commitment(CommitmentConfig::confirmed())
            .await?;
        let stats_sync_result = self
            .rpc
            .get_program_accounts_with_config(
                &PROGRAM_ID,
                RpcProgramAccountsConfig {
                    filters: Some(vec![crate::memcmp::get_user_stats_filter()]),
                    account_config: RpcAccountInfoConfig {
                        encoding: Some(UiAccountEncoding::Base64Zstd),
                        ..Default::default()
                    },
                    ..Default::default()
                },
            )
            .await?;

        for (pubkey, account) in stats_sync_result {
            self.on_account_fn()(&AccountUpdate {
                pubkey,
                data: &account.data,
                lamports: account.lamports,
                owner: PROGRAM_ID,
                rent_epoch: u64::MAX,
                executable: false,
                slot,
            });
        }
        Ok(())
    }

    pub async fn sync_user_accounts(&self, mut filters: Vec<RpcFilterType>) -> SdkResult<()> {
        // TODO: rust sdk does not surface with_context slot on GPA
        let slot = self
            .rpc
            .get_slot_with_commitment(CommitmentConfig::confirmed())
            .await?;
        filters.insert(0, crate::memcmp::get_user_filter());

        let sync_result = self
            .rpc
            .get_program_accounts_with_config(
                &PROGRAM_ID,
                RpcProgramAccountsConfig {
                    filters: Some(filters),
                    account_config: RpcAccountInfoConfig {
                        encoding: Some(UiAccountEncoding::Base64Zstd),
                        ..Default::default()
                    },
                    ..Default::default()
                },
            )
            .await?;

        for (pubkey, account) in sync_result {
            self.on_account_fn()(&AccountUpdate {
                pubkey,
                data: &account.data,
                lamports: account.lamports,
                owner: PROGRAM_ID,
                rent_epoch: u64::MAX,
                executable: false,
                slot,
            });
        }

        Ok(())
    }
}

struct Subscribed {
    unsub: Mutex<Option<UnsubHandle>>,
}
struct Unsubscribed;

/// A subscription to a solana account
pub struct AccountSub<S> {
    /// account pubkey
    pub pubkey: Pubkey,
    /// underlying subscription
    subscription: SubscriptionImpl,
    /// subscription state
    state: S,
}

impl AccountSub<Unsubscribed> {
    pub const SUBSCRIPTION_ID: &'static str = "account";

    /// Create a new Ws account subscriber
    pub fn new(pubsub: Arc<PubsubClient>, commitment: CommitmentConfig, pubkey: Pubkey) -> Self {
        let subscription = WebsocketAccountSubscriber::new(pubsub, pubkey, commitment);

        Self {
            pubkey,
            subscription: SubscriptionImpl::Ws(subscription),
            state: Unsubscribed {},
        }
    }

    /// Create a new polled account subscriber
    pub fn polled(rpc: Arc<RpcClient>, pubkey: Pubkey, interval: Option<Duration>) -> Self {
        let subscription =
            PolledAccountSubscriber::new(pubkey, interval.unwrap_or(Duration::from_secs(5)), rpc);

        Self {
            pubkey,
            subscription: SubscriptionImpl::Polled(subscription),
            state: Unsubscribed {},
        }
    }

    /// Start the subscriber task
    pub async fn subscribe<F>(
        self,
        accounts: Arc<DashMap<Pubkey, AccountSlot, ahash::RandomState>>,
        on_account: F,
    ) -> SdkResult<AccountSub<Subscribed>>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        let unsub = match self.subscription {
            SubscriptionImpl::Ws(ref ws) => {
                let on_account = on_account.clone();
                let unsub = ws
                    .subscribe(Self::SUBSCRIPTION_ID, true, move |update| {
                        if update.lamports == 0 {
                            accounts.remove(&update.pubkey);
                            return;
                        }
                        accounts
                            .entry(update.pubkey)
                            .and_modify(|x| {
                                x.slot = update.slot;
                                x.raw = Arc::from(update.data.as_slice());
                            })
                            .or_insert(AccountSlot {
                                raw: Arc::from(update.data.as_slice()),
                                slot: update.slot,
                            });

                        on_account(update);
                    })
                    .await?;
                Some(unsub)
            }
            SubscriptionImpl::Polled(ref poll) => {
                let on_account = on_account.clone();
                let unsub = poll.subscribe(move |update| {
                    if update.lamports == 0 {
                        accounts.remove(&update.pubkey);
                        return;
                    }
                    accounts
                        .entry(update.pubkey)
                        .and_modify(|x| {
                            x.slot = update.slot;
                            x.raw = Arc::from(update.data.as_slice());
                        })
                        .or_insert(AccountSlot {
                            raw: Arc::from(update.data.as_slice()),
                            slot: update.slot,
                        });

                    on_account(update);
                });
                Some(unsub)
            }
            SubscriptionImpl::Grpc => None,
        };

        Ok(AccountSub {
            pubkey: self.pubkey,
            subscription: self.subscription,
            state: Subscribed {
                unsub: Mutex::new(unsub),
            },
        })
    }
}

impl AccountSub<Subscribed> {
    /// Stop the user subscriber task, if it exists
    pub fn unsubscribe(self) -> AccountSub<Unsubscribed> {
        let mut guard = self.state.unsub.lock().expect("acquire");
        if let Some(unsub) = guard.take() {
            if unsub.send(()).is_err() {
                log::error!("couldn't unsubscribe");
            }
        }

        AccountSub {
            pubkey: self.pubkey,
            subscription: self.subscription,
            state: Unsubscribed,
        }
    }
}

enum SubscriptionImpl {
    Ws(WebsocketAccountSubscriber),
    Polled(PolledAccountSubscriber),
    Grpc,
}

/// Wrapper type that keeps the Arc alive and provides access to T
pub struct AccountRef<T> {
    arc: Arc<[u8]>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: Pod> Deref for AccountRef<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        bytemuck::from_bytes(&self.arc[8..]) // strip discriminator
    }
}

#[cfg(test)]
mod tests {
    use std::time::Duration;

    use solana_sdk::pubkey;

    use super::*;
    use crate::{
        accounts::User,
        constants::{state_account, DEFAULT_PUBKEY},
        types::accounts::State,
        utils::{get_ws_url, test_envs::mainnet_endpoint},
        Wallet,
    };

    #[tokio::test]
    async fn test_user_subscribe() {
        let _ = env_logger::try_init();
        let pubsub = Arc::new(
            PubsubClient::new(&get_ws_url(&mainnet_endpoint()).unwrap())
                .await
                .expect("ws connects"),
        );
        let rpc = Arc::new(RpcClient::new(mainnet_endpoint()));
        let account_map = AccountMap::new(pubsub, rpc, CommitmentConfig::confirmed());
        let user_1 = Wallet::derive_user_account(
            &pubkey!("DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2"),
            0,
        );
        let user_2 = Wallet::derive_user_account(
            &pubkey!("Drift7AMLeq3FoKBMpT9wzqyMM3HVvvZFtsn81iSSkWV"),
            0,
        );

        let (res1, res2, res3) = tokio::join!(
            account_map.subscribe_account(&user_1),
            account_map.subscribe_account(&user_2),
            account_map.subscribe_account_polled(state_account(), Some(Duration::from_secs(2))),
        );
        assert!(res1.and(res2).and(res3).is_ok());

        let handle = tokio::spawn(async move {
            tokio::time::sleep(Duration::from_secs(8)).await;
            let account_data = account_map.account_data::<User>(&user_1);
            assert!(account_data.is_some_and(|x| x.authority != DEFAULT_PUBKEY));
            account_map.unsubscribe_account(&user_1);

            let account_data = account_map.account_data::<User>(&user_1);
            assert!(account_data.is_none());

            let account_data = account_map.account_data::<User>(&user_2);
            assert!(account_data.is_some_and(|x| x.authority != DEFAULT_PUBKEY));

            let state_account = account_map.account_data::<State>(state_account());
            assert!(state_account.is_some());
        });

        assert!(handle.await.is_ok());
    }
}

```

## File: crates/src/async_utils.rs
```
//! utils for async functions

use std::time::Duration;

use futures_util::{
    future::{ready, BoxFuture},
    Future, FutureExt,
};
use tokio::task::JoinHandle;

use self::retry_policy::TaskRetryPolicy;

pub mod retry_policy {
    //! retry policies for async tasks
    use super::*;

    /// Defines whether an async task should be retried or not
    pub trait TaskRetryPolicy: Send + Sync + 'static {
        /// called pre-retry, returns whether retry should proceed or not
        fn check(&mut self, _attempts: u32) -> BoxFuture<'_, bool>;
    }
    /// Create a new fail fast policy
    pub fn never() -> FailFast {
        FailFast {}
    }

    /// Create a new exponential backoff policy
    pub fn exponential_backoff(max_attempts: u32) -> ExponentialBackoff {
        ExponentialBackoff { max_attempts }
    }

    /// Create a new never ending retry policy
    pub fn forever(delay_s: u32) -> InfiniteRetry {
        InfiniteRetry { delay_s }
    }

    /// TaskFails on first retry
    pub struct FailFast;

    impl TaskRetryPolicy for FailFast {
        fn check(&mut self, _attempts: u32) -> BoxFuture<'_, bool> {
            ready(false).boxed()
        }
    }

    /// Exponential back-off policy up to `max_attempts`
    pub struct ExponentialBackoff {
        max_attempts: u32,
    }

    impl TaskRetryPolicy for ExponentialBackoff {
        fn check(&mut self, attempts: u32) -> BoxFuture<'_, bool> {
            async move {
                if attempts > self.max_attempts {
                    false
                } else {
                    tokio::time::sleep(Duration::from_secs(2_u64.pow(attempts))).await;
                    true
                }
            }
            .boxed()
        }
    }

    /// A policy that retries a task indefinitely, with constant delay between successive retries
    pub struct InfiniteRetry {
        delay_s: u32,
    }

    impl TaskRetryPolicy for InfiniteRetry {
        fn check(&mut self, _attempts: u32) -> BoxFuture<'_, bool> {
            async move {
                tokio::time::sleep(Duration::from_secs(self.delay_s as u64)).await;
                true
            }
            .boxed()
        }
    }
}
/// Spawns a new tokio task with udf retry behaviour
///
/// - `task_fn` generator function for the task future
///
/// ```example
/// let task_gen = move || {
///     async move {
///         1 + 1
///     }
/// };
///
/// spawn_retry_task(task_gen, FailFast {})
/// ```
pub fn spawn_retry_task<F, G>(task_fn: G, mut retry_policy: impl TaskRetryPolicy) -> JoinHandle<()>
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
    G: Fn() -> F + Send + Sync + 'static,
{
    tokio::spawn(async move {
        let mut attempts = 0;
        loop {
            task_fn().await;
            if !retry_policy.check(attempts).await {
                panic!("task reached retry limit");
            }
            attempts += 1;
        }
    })
}

```

## File: crates/src/auction_subscriber.rs
```
use std::sync::Mutex;

use solana_account_decoder_client_types::UiAccountEncoding;
use solana_sdk::commitment_config::CommitmentConfig;

use crate::{
    drift_idl::accounts::User,
    memcmp::{get_user_filter, get_user_with_auction_filter},
    types::SdkResult,
    websocket_program_account_subscriber::{
        ProgramAccountUpdate, WebsocketProgramAccountOptions, WebsocketProgramAccountSubscriber,
    },
    SdkError, UnsubHandle,
};

pub struct AuctionSubscriberConfig {
    pub commitment: CommitmentConfig,
    pub resub_timeout_ms: Option<u64>,
    pub url: String,
}

/// Subscribes to all user auction events across all markets
///
/// DEV: take care it is not dropped or the Auction stream will unsubscribe
pub struct AuctionSubscriber {
    subscriber: WebsocketProgramAccountSubscriber,
    unsub: Mutex<Option<UnsubHandle>>,
}

impl AuctionSubscriber {
    pub const SUBSCRIPTION_ID: &'static str = "auction";

    pub fn new(config: AuctionSubscriberConfig) -> Self {
        let filters = vec![get_user_filter(), get_user_with_auction_filter()];
        let websocket_options = WebsocketProgramAccountOptions {
            filters,
            commitment: config.commitment,
            encoding: UiAccountEncoding::Base64Zstd,
        };

        Self {
            subscriber: WebsocketProgramAccountSubscriber::new(config.url, websocket_options),
            unsub: Mutex::new(None),
        }
    }

    /// Start the auction subscription task
    ///
    /// * `handler_fn` - fn to invoke on each update
    ///
    /// this class sends the entire User account, the callback is required to
    /// interpret the diff e.g orders added/removed
    ///
    pub fn subscribe<F>(&self, handler_fn: F)
    where
        F: 'static + Send + Fn(&ProgramAccountUpdate<User>),
    {
        let mut guard = self.unsub.try_lock().expect("uncontested");
        let unsub = self.subscriber.subscribe(Self::SUBSCRIPTION_ID, handler_fn);
        guard.replace(unsub);
    }

    /// Unsubscribe stopping the auction subscription task
    pub fn unsubscribe(self) -> SdkResult<()> {
        let mut guard = self.unsub.lock().expect("acquired");
        if let Some(unsub) = guard.take() {
            if unsub.send(()).is_err() {
                log::error!("unsub failed");
                return Err(SdkError::CouldntUnsubscribe);
            }
        }

        Ok(())
    }
}

#[cfg(feature = "rpc_tests")]
mod tests {
    use super::*;
    use crate::utils::test_envs::mainnet_endpoint;

    #[tokio::test]
    async fn test_auction_subscriber() {
        env_logger::init();

        let config = AuctionSubscriberConfig {
            commitment: CommitmentConfig::confirmed(),
            resub_timeout_ms: None,
            url: mainnet_endpoint(),
        };

        let mut auction_subscriber = AuctionSubscriber::new(config);

        let emitter = auction_subscriber.event_emitter.clone();

        emitter.subscribe(move |event| {
            log::info!("{:?}", event.now.elapsed());
        });

        let _ = auction_subscriber.subscribe().await;

        tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;

        let _ = auction_subscriber.unsubscribe().await;

        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
    }
}

```

## File: crates/src/blockhash_subscriber.rs
```
use std::{
    collections::VecDeque,
    sync::{Arc, Mutex, RwLock},
    time::Duration,
};

use log::warn;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::hash::Hash;
use tokio::sync::oneshot;

use crate::UnsubHandle;

/// Subscribes to latest network blockhashes
pub struct BlockhashSubscriber {
    refresh_frequency: Duration,
    last_twenty_hashes: Arc<RwLock<VecDeque<Hash>>>,
    rpc_client: Arc<RpcClient>,
    unsub: Mutex<Option<UnsubHandle>>,
}

impl BlockhashSubscriber {
    /// Create a new blockhash subscriber
    /// It must be started by calling `subscribe()`
    pub fn new(refresh_frequency: Duration, rpc_client: Arc<RpcClient>) -> Self {
        BlockhashSubscriber {
            last_twenty_hashes: Arc::new(RwLock::new(VecDeque::with_capacity(20))),
            rpc_client: Arc::clone(&rpc_client),
            refresh_frequency,
            unsub: Mutex::default(),
        }
    }

    /// Start the blockhash subscriber task
    pub fn subscribe(&self) {
        let (unsub_tx, mut unsub_rx) = oneshot::channel();
        {
            let mut guard = self.unsub.try_lock().expect("uncontested");
            if guard.is_some() {
                return;
            }
            guard.replace(unsub_tx);
        }

        tokio::spawn({
            let rpc_client = Arc::clone(&self.rpc_client);
            let last_twenty_hashes = Arc::clone(&self.last_twenty_hashes);
            let mut refresh = tokio::time::interval(self.refresh_frequency);

            let max_attempts = 3;
            let mut attempts = 0;
            async move {
                loop {
                    let _ = refresh.tick().await;
                    match rpc_client.get_latest_blockhash().await {
                        Ok(blockhash) => {
                            attempts = 0;
                            let mut hashes = last_twenty_hashes.write().expect("acquired");
                            hashes.push_back(blockhash);
                            if hashes.len() > 20 {
                                let _ = hashes.pop_front();
                            }
                        }
                        Err(err) => {
                            warn!("blockhash subscriber missed update: {err:?}");
                            attempts += 1;
                            if attempts > max_attempts {
                                panic!("unable to fetch blockhash");
                            }
                        }
                    }

                    if unsub_rx.try_recv().is_ok() {
                        warn!("unsubscribing from blockhashes");
                        break;
                    }
                }

                let mut lock = last_twenty_hashes.write().expect("acquired");
                lock.clear();
            }
        });
    }

    /// Return most recent polled blockhash
    pub fn get_latest_blockhash(&self) -> Option<Hash> {
        let lock = self.last_twenty_hashes.read().expect("acquired");
        lock.back().copied()
    }

    /// Return oldest valid blockhash (more likely finalized)
    pub fn get_valid_blockhash(&self) -> Option<Hash> {
        let lock = self.last_twenty_hashes.read().expect("acquired");
        lock.front().copied()
    }

    /// Stop the blockhash subscriber task, if it exists    ``
    pub fn unsubscribe(&self) {
        let mut guard = self.unsub.lock().expect("uncontested");
        if let Some(unsub) = guard.take() {
            if unsub.send(()).is_err() {
                log::error!("couldn't unsubscribe");
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use serde_json::json;
    use solana_rpc_client::rpc_client::Mocks;
    use solana_rpc_client_api::request::RpcRequest;

    use super::*;

    #[tokio::test]
    async fn blockhash_subscriber_updates() {
        let _ = env_logger::try_init();
        let mut response_mocks = Mocks::default();
        let latest_block_hash = Hash::new_unique();
        let oldest_block_hash = Hash::new_unique();

        response_mocks.insert(
            RpcRequest::GetLatestBlockhash,
            json!({
                "context": {
                    "slot": 12345,
                },
                "value": {
                    "blockhash": latest_block_hash.to_string(),
                    "lastValidBlockHeight": 1,
                }
            }),
        );

        let mock_rpc = RpcClient::new_mock_with_mocks(
            "https://api.mainnet-beta.solana.com".into(),
            response_mocks,
        );

        let blockhash_subscriber = BlockhashSubscriber {
            last_twenty_hashes: Arc::new(RwLock::new(VecDeque::from_iter(
                [oldest_block_hash]
                    .into_iter()
                    .chain(std::iter::repeat(Hash::new_unique()).take(20)),
            ))),
            unsub: Mutex::default(),
            rpc_client: Arc::new(mock_rpc),
            refresh_frequency: Duration::from_secs(4),
        };

        // valid hash is oldest (most finalized)
        assert_eq!(
            blockhash_subscriber.get_valid_blockhash().unwrap(),
            oldest_block_hash
        );
        assert!(blockhash_subscriber.get_latest_blockhash().unwrap() != latest_block_hash);

        // after subscribe blockhashes, next update is observable
        blockhash_subscriber.subscribe();
        tokio::time::sleep(Duration::from_secs(2)).await;
        assert_eq!(
            blockhash_subscriber.get_latest_blockhash().unwrap(),
            latest_block_hash
        );

        // oldest hash updated as buffer updates
        assert!(blockhash_subscriber.get_valid_blockhash().unwrap() != oldest_block_hash);

        // after unsub, returns none
        blockhash_subscriber.unsubscribe();
        tokio::time::sleep(Duration::from_secs(4)).await;
        assert!(blockhash_subscriber.get_latest_blockhash().is_none());
    }
}

```

## File: crates/src/constants.rs
```
use std::sync::OnceLock;

use solana_sdk::{address_lookup_table::AddressLookupTableAccount, pubkey::Pubkey};

use crate::{
    drift_idl::accounts::{PerpMarket, SpotMarket},
    types::{accounts::State, Context},
    MarketId, MarketType, OracleSource,
};

/// https://github.com/solana-labs/solana-web3.js/blob/4e9988cfc561f3ed11f4c5016a29090a61d129a8/src/sysvar.ts#L11
pub const SYSVAR_INSTRUCTIONS_PUBKEY: Pubkey =
    solana_sdk::pubkey!("Sysvar1nstructions1111111111111111111111111");

/// https://github.com/solana-foundation/solana-web3.js/blob/4e9988cfc561f3ed11f4c5016a29090a61d129a8/src/sysvar.ts#L19
pub const SYSVAR_RENT_PUBKEY: Pubkey =
    solana_sdk::pubkey!("SysvarRent111111111111111111111111111111111");

/// Drift program address
pub const PROGRAM_ID: Pubkey = solana_sdk::pubkey!("dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH");

/// Vault program address
pub const VAULT_PROGRAM_ID: Pubkey =
    solana_sdk::pubkey!("vAuLTsyrvSfZRuRB3XgvkPwNGgYSs9YRYymVebLKoxR");

/// JIT proxy program address
pub const JIT_PROXY_ID: Pubkey =
    solana_sdk::pubkey!("J1TnP8zvVxbtF5KFp5xRmWuvG9McnhzmBd9XGfCyuxFP");
/// Empty pubkey
pub const DEFAULT_PUBKEY: Pubkey = solana_sdk::pubkey!("11111111111111111111111111111111");

pub const SYSTEM_PROGRAM_ID: Pubkey = DEFAULT_PUBKEY;

pub const PYTH_LAZER_STORAGE_ACCOUNT_KEY: Pubkey =
    solana_sdk::pubkey!("3rdJbqfnagQ4yx9HXJViD4zc4xpiSqmFsKpPuSCQVyQL");

static STATE_ACCOUNT: OnceLock<Pubkey> = OnceLock::new();
static HIGH_LEVERAGE_MODE_ACCOUNT: OnceLock<Pubkey> = OnceLock::new();

/// Address of the SPL Token program
pub const TOKEN_PROGRAM_ID: Pubkey =
    solana_sdk::pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

/// Address of the SPL Token 2022 program
pub const TOKEN_2022_PROGRAM_ID: Pubkey =
    solana_sdk::pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");

/// Address of Associated Token Program
pub const ASSOCIATED_TOKEN_PROGRAM_ID: Pubkey =
    solana_sdk::pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");

/// Drift market lookup table (DevNet)
pub const LUTS_DEVNET: &[Pubkey] = &[solana_sdk::pubkey!(
    "FaMS3U4uBojvGn5FSDEPimddcXsCfwkKsFgMVVnDdxGb"
)];
/// Drift market lookup table (MainNet)
pub const LUTS_MAINNET: &[Pubkey] = &[
    solana_sdk::pubkey!("Fpys8GRa5RBWfyeN7AaDUwFGD1zkDCA4z3t4CJLV8dfL"),
    solana_sdk::pubkey!("EiWSskK5HXnBTptiS5DH6gpAJRVNQ3cAhTKBGaiaysAb"),
];

/// Drift state account
pub fn state_account() -> &'static Pubkey {
    STATE_ACCOUNT.get_or_init(|| {
        let (state_account, _seed) =
            Pubkey::find_program_address(&[&b"drift_state"[..]], &PROGRAM_ID);
        state_account
    })
}

/// Returns the program's HLM config address
pub fn high_leverage_mode_account() -> &'static Pubkey {
    HIGH_LEVERAGE_MODE_ACCOUNT.get_or_init(|| {
        let (account_drift_pda, _seed) =
            Pubkey::find_program_address(&[&b"high_leverage_mode_config"[..]], &PROGRAM_ID);
        account_drift_pda
    })
}

/// calculate the PDA of a drift spot market given index
pub fn derive_spot_market_account(market_index: u16) -> Pubkey {
    let (account, _seed) = Pubkey::find_program_address(
        &[&b"spot_market"[..], &market_index.to_le_bytes()],
        &PROGRAM_ID,
    );
    account
}

/// calculate the PDA of a drift perp market given index
pub fn derive_perp_market_account(market_index: u16) -> Pubkey {
    let (account, _seed) = Pubkey::find_program_address(
        &[&b"perp_market"[..], &market_index.to_le_bytes()],
        &PROGRAM_ID,
    );
    account
}

/// calculate the PDA for a drift spot market vault given index
pub fn derive_spot_market_vault(market_index: u16) -> Pubkey {
    let (account, _seed) = Pubkey::find_program_address(
        &[&b"spot_market_vault"[..], &market_index.to_le_bytes()],
        &PROGRAM_ID,
    );
    account
}

/// calculate the PDA for the drift signer
pub fn derive_drift_signer() -> Pubkey {
    let (account, _seed) = Pubkey::find_program_address(&[&b"drift_signer"[..]], &PROGRAM_ID);
    account
}

pub fn derive_revenue_share(authority: &Pubkey) -> Pubkey {
    let (account, _seed) =
        Pubkey::find_program_address(&[&b"REV_SHARE"[..], authority.as_ref()], &PROGRAM_ID);
    account
}

pub fn derive_revenue_share_escrow(authority: &Pubkey) -> Pubkey {
    let (account, _seed) =
        Pubkey::find_program_address(&[&b"REV_ESCROW"[..], authority.as_ref()], &PROGRAM_ID);
    account
}

/// Helper methods for market data structs
pub trait MarketExt {
    fn market_type(&self) -> &'static str;
    fn symbol(&self) -> &str;
}

impl MarketExt for PerpMarket {
    fn market_type(&self) -> &'static str {
        "perp"
    }
    fn symbol(&self) -> &str {
        unsafe { core::str::from_utf8_unchecked(&self.name) }.trim_end()
    }
}

impl MarketExt for SpotMarket {
    fn market_type(&self) -> &'static str {
        "spot"
    }
    fn symbol(&self) -> &str {
        unsafe { core::str::from_utf8_unchecked(&self.name) }.trim_end()
    }
}

/// Static-ish metadata from onchain drift program
///
/// useful for market info suchas as pubkeys, decimal places, which rarely change.
///
/// it should not be relied upon for live values such as OI, total borrows, etc.
/// instead subscribe to a marketmap
#[derive(Clone)]
pub struct ProgramData {
    spot_markets: &'static [SpotMarket],
    perp_markets: &'static [PerpMarket],
    pub lookup_tables: &'static [AddressLookupTableAccount],
    // drift state account
    state: State,
}

impl ProgramData {
    /// Return an uninitialized instance of `ProgramData` (useful for bootstrapping)
    pub const fn uninitialized() -> Self {
        Self {
            spot_markets: &[],
            perp_markets: &[],
            lookup_tables: &[],
            state: unsafe { std::mem::zeroed() },
        }
    }
    /// Initialize `ProgramData`
    pub fn new(
        mut spot: Vec<SpotMarket>,
        mut perp: Vec<PerpMarket>,
        lookup_tables: Vec<AddressLookupTableAccount>,
        state: State,
    ) -> Self {
        spot.sort_by(|a, b| a.market_index.cmp(&b.market_index));
        perp.sort_by(|a, b| a.market_index.cmp(&b.market_index));
        // other code relies on aligned indexes for fast lookups
        assert!(
            spot.iter()
                .enumerate()
                .all(|(idx, x)| idx == x.market_index as usize),
            "spot indexes unaligned"
        );
        assert!(
            perp.iter()
                .enumerate()
                .all(|(idx, x)| idx == x.market_index as usize),
            "perp indexes unaligned"
        );

        Self {
            spot_markets: Box::leak(spot.into_boxed_slice()),
            perp_markets: Box::leak(perp.into_boxed_slice()),
            lookup_tables: Box::leak(lookup_tables.into_boxed_slice()),
            state,
        }
    }

    /// Return drift `State` account (cached)
    ///
    /// prefer live
    pub fn state(&self) -> &State {
        &self.state
    }

    /// Return known spot markets
    pub fn spot_market_configs(&self) -> &'static [SpotMarket] {
        self.spot_markets
    }

    /// Return known perp markets
    pub fn perp_market_configs(&self) -> &'static [PerpMarket] {
        self.perp_markets
    }

    /// Return the spot market config given a market index
    ///
    /// Useful for static metadata e.g. token program address
    pub fn spot_market_config_by_index(&self, market_index: u16) -> Option<&'static SpotMarket> {
        self.spot_markets.get(market_index as usize)
    }

    /// Return the perp market config given a market index
    ///
    /// Useful for static metadata e.g. token program address
    pub fn perp_market_config_by_index(&self, market_index: u16) -> Option<&'static PerpMarket> {
        self.perp_markets.get(market_index as usize)
    }

    /// Given some drift `MarketId`'s maps them to associated public keys
    pub fn markets_to_accounts(&self, markets: &[MarketId]) -> Vec<Pubkey> {
        let accounts: Vec<Pubkey> = markets
            .iter()
            .filter_map(|x| match x.kind() {
                MarketType::Spot => self
                    .spot_market_config_by_index(x.index())
                    .map(|x| x.pubkey),
                MarketType::Perp => self
                    .perp_market_config_by_index(x.index())
                    .map(|x| x.pubkey),
            })
            .collect();

        accounts
    }
}

/// Map oracle `source` to its owner pubkey (network dependent)
pub fn oracle_source_to_owner(context: Context, source: OracleSource) -> Pubkey {
    match source {
        OracleSource::Pyth
        | OracleSource::Pyth1K
        | OracleSource::Pyth1M
        | OracleSource::PythStableCoin => context.pyth(),
        OracleSource::PythPull
        | OracleSource::Pyth1KPull
        | OracleSource::Pyth1MPull
        | OracleSource::PythStableCoinPull => ids::drift_oracle_receiver_program::ID,
        OracleSource::Switchboard => ids::switchboard_program::ID,
        OracleSource::SwitchboardOnDemand => ids::switchboard_on_demand::ID,
        OracleSource::QuoteAsset => DEFAULT_PUBKEY,
        OracleSource::Prelaunch
        | OracleSource::PythLazer
        | OracleSource::PythLazer1K
        | OracleSource::PythLazer1M
        | OracleSource::PythLazerStableCoin => PROGRAM_ID,
    }
}

pub mod ids {
    pub mod pyth_program {
        use solana_sdk::pubkey::Pubkey;
        pub const ID: Pubkey = solana_sdk::pubkey!("FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH");
        pub const ID_DEVNET: Pubkey =
            solana_sdk::pubkey!("gSbePebfvPy7tRqimPoVecS2UsBvYv46ynrzWocc92s");
    }

    pub mod wormhole_program {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("HDwcJBJXjL9FpJ7UBsYBtaDjsBUhuLCUYoz3zr8SWWaQ");
    }

    pub mod drift_oracle_receiver_program {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("G6EoTTTgpkNBtVXo96EQp2m6uwwVh2Kt6YidjkmQqoha");
    }

    pub mod switchboard_program {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("SW1TCH7qEPTdLsDHRgPuMQjbQxKdH2aBStViMFnt64f");
    }

    pub mod switchboard_on_demand {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("SBondMDrcV3K4kxZR1HNVT7osZxAHVHgYXL5Ze1oMUv");
    }

    pub mod bonk_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("8ihFLu5FimgTQ1Unh4dVyEHUGodJ5gJQCrQf4KUVB9bN");
    }

    pub mod bonk_pull_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("GojbSnJuPdKDT1ZuHuAM5t9oz6bxTo1xhUKpTua2F72p");
    }

    pub mod pepe_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("FSfxunDmjjbDV2QxpyxFCAPKmYJHSLnLuvQXDLkMzLBm");
    }

    pub mod pepe_pull_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("CLxofhtzvLiErpn25wvUzpZXEqBhuZ6WMEckEraxyuGt");
    }

    pub mod wen_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("6Uo93N83iF5U9KwC8eQpogx4XptMT4wSKfje7hB1Ufko");
    }

    pub mod wen_pull_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("F47c7aJgYkfKXQ9gzrJaEpsNwUKHprysregTWXrtYLFp");
    }

    pub mod usdc_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("Gnt27xtC473ZT2Mw5u8wZ68Z3gULkSTb5DuxJy7eJotD");
    }

    pub mod usdc_pull_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("En8hkHLkRe9d9DraYmBTrus518BvmVH448YcvmrFM6Ce");
    }

    pub mod jupiter_mainnet_6 {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4");
    }
    pub mod jupiter_mainnet_4 {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB");
    }
    pub mod jupiter_mainnet_3 {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("JUP3c2Uh3WA4Ng34tw6kPd2G4C5BB21Xo36Je1s32Ph");
    }

    pub mod marinade_mainnet {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD");
    }

    pub mod usdt_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("3vxLXJqLqF3JG5TCbYycbKWRBbCJQLxQmBGCkyqEEefL");
    }

    pub mod usdt_pull_oracle {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("BekJ3P5G3iFeC97sXHuKnUHofCFj9Sbo7uyF2fkKwvit");
    }

    pub mod admin_hot_wallet {
        use solana_sdk::pubkey::Pubkey;

        pub const ID: Pubkey = solana_sdk::pubkey!("5hMjmxexWu954pX9gB9jkHxMqdjpxArQS2XdvkaevRax");
    }
}

macro_rules! generate_pyth_lazer_mappings {
    (
        const $array_name:ident: [ $( ($feed_id:expr, $market_index:expr) ),* $(,)? ];
        fn $feed_to_market:ident;
        fn $market_to_feed:ident;
    ) => {
        pub const $array_name: &[(u32, u16)] = &[
            $( ($feed_id, $market_index), )*
        ];

        /// Map from pyth lazer `feed_id `to mainnet spot/perp market index
        pub const fn $feed_to_market(feed_id: u32) -> Option<u16> {
            match feed_id {
                $(
                    $feed_id => Some($market_index),
                )*
                _ => None,
            }
        }

        /// Map from mainnet spot/perp market index to pyth lazer `feed_id`
        pub const fn $market_to_feed(market_index: u16) -> Option<u32> {
            match market_index {
                $(
                    $market_index => Some($feed_id),
                )*
                _ => None,
            }
        }
    };
}

generate_pyth_lazer_mappings! {
    const PYTH_LAZER_FEED_ID_TO_PERP_MARKET_MAINNET: [
        (6, 0),     // SOL
        (1, 1),     // BTC
        (2, 2),     // ETH
        (28, 3),    // APT
        (9, 4),     // 1MBONK
        (32, 5),    // POL
        (37, 6),    // ARB
        (13, 7),    // DOGE
        (15, 8),    // BNB
        (11, 9),    // SUI
        (4, 10),    // 1MPEPE
        (41, 11),   // OP
        (34, 12),   // RENDER
        (14, 13),   // XRP
        (168, 14),  // HNT
        (46, 15),   // INJ
        (19, 16),   // LINK
        (3, 18),    // PYTH
        (48, 19),   // TIA
        (91, 20),   // JTO
        (51, 21),   // SEI
        (18, 22),   // AVAX
        (10, 23),   // WIF
        (92, 24),   // JUP
        (83, 25),   // DYM
        (36, 26),   // TAO
        (102, 27),  // W
        (464, 28),  // KMNO
        (99, 29),   // TNSR
        (249, 30),  // DRIFT
        (404, 31),  // CLOUD
        (90, 32),   // IO
        (130, 34),  // POPCAT
        (12, 42),   // TON
        (501, 44),  // MOTHER
        (500, 45),  // MOODENG
        (437, 53),  // GOAT
        (77, 55),   // PNUT
        (54, 56),   // RAY
        (110, 59),  // HYPE
        (26, 60),   // LTC
        (93, 61),   // ME
        (97, 62),   // PENGU
        (171, 63),  // AI16Z
        (203, 64),  // TRUMP
        (145, 65),  // MELANIA
        (308, 66),  // BERA
        (306, 69),  // KAITO
        (309, 70),  // IP
        (182, 71),  // FARTCOIN
        (16, 72),   // ADA
        (163, 73),  // PAXG
        // (1578, 75), // PUMP
        (2310, 76), // ASTER
        (2312, 77), // XPL
        (2316, 78), // 2Z
        (66, 79),   // ZEC
        (199, 80),  // MNT
        (1578, 81), // 1KPUMP
        (2382, 82), // MET
        (2396, 83), // 1KMON
    ];
    fn pyth_lazer_feed_id_to_perp_market_index;
    fn perp_market_index_to_pyth_lazer_feed_id;
}

generate_pyth_lazer_mappings! {
    const PYTH_LAZER_FEED_ID_TO_SPOT_MARKET_MAINNET: [
        (7, 0),    // USDC
        (6, 1),    // SOL
        (503, 2),  // mSOL
        (103, 3),  // wBTC
        (8, 5),    // USDT
        (458, 6),  // jitoSOL
        (3, 7),    // PYTH
        (91, 9),   // JTO
        (10, 10),  // WIF
        (92, 11),  // JUP
        (34, 12),  // RENDER
        (102, 13), // W
        (99, 14),  // TNSR
        (249, 15), // DRIFT
        (276, 18), // USDY
        (459, 19), // JLP
        (130, 20), // POPCAT
        (404, 21), // CLOUD
        (156, 22), // PYUSD
        (204, 23), // USDe
        (582, 24), // sUSDe
        (384, 25), // BNSOL
        (501, 26), // MOTHER
        (611, 28), // USDS
        (93, 30),  // ME
        (97, 31),  // PENGU
        (9, 32),   // BONK
        // (7, 34),   // USDC-1
        (203, 36), // TRUMP
        (145, 37), // MELANIA
        (367, 38), // AUSD
        (182, 39), // FARTCOIN
        (640, 45), // zBTC
        (643, 46), // ZEUS
        // (7, 47),   // USDC-4
        // (8, 48),   // USDT-4
        (240, 54), // EURC
        (1578, 56), // PUMP
        (2316, 59), // 2Z
        (2382, 60), // MET
        (2323, 61), // CASH
    ];
    fn pyth_lazer_feed_id_to_spot_market_index;
    fn spot_market_index_to_pyth_lazer_feed_id;
}

```

## File: crates/src/dlob/builder.rs
```
use solana_sdk::pubkey::Pubkey;

use crate::{
    account_map::AccountMap,
    accounts::User,
    dlob::{DLOBNotifier, DLOB},
    grpc::AccountUpdate,
    types::MarketId,
    DriftClient, Wallet,
};

/// Convenience builder for constructing and managing an event driven [`DLOB`] instance.
/// It should be plugged into a gRPC subscription to receive live order updates and slot changes.
///
/// ```example(no_run)
/// use drift_rs::dlob::builder::DLOBBuilder;
/// use drift_rs::types::MarketId;
///
/// // Construct the DLOBBuilder
/// let builder = DLOBBuilder::new(market_ids);
///
/// // setup grpc client...
///     let _res = drift
///     .grpc_subscribe(
///         grpc_url,
///         grpc_x_token,
///         GrpcSubscribeOpts::default()
///             .commitment(CommitmentLevel::Processed)
///             .usermap_on()
///             .on_user_account(builder.account_update_handler(drift.backend().account_map()))
///             .on_slot(builder.slot_update_handler()),
///         true, // sync all the accounts on startup (required to populate the usermap)
///     )
///    .await;
///
/// // Access the underlying DLOB
/// let dlob = builder.dlob();
/// ```
pub struct DLOBBuilder<'a> {
    dlob: &'a DLOB,
    notifier: DLOBNotifier,
}

impl<'a> DLOBBuilder<'a> {
    /// Initialize a new DLOBBuilder instance from an AccountMap
    ///
    /// ## Params
    ///
    /// * `account_map` - account_map with initial User accounts (i.e orders) to bootstrap orderbook
    ///
    pub fn new(account_map: &AccountMap) -> Self {
        let dlob = Box::leak(Box::new(DLOB::default()));
        let notifier = dlob.spawn_notifier();

        let notifier_ref = notifier.clone();
        account_map.iter_accounts_with::<User>(move |pubkey, user, slot| {
            notifier_ref.user_update(*pubkey, None, &user, slot);
        });

        Self { dlob, notifier }
    }

    /// Initialize a new DLOBBuilder instance from some iterable list of User accounts
    ///
    /// ## Params
    ///
    /// * `users` - initial User accounts (i.e orders) to bootstrap orderbook
    /// * `slot` - slot users were retrieved
    ///
    pub fn new_with_users<'u>(users: impl Iterator<Item = &'u User>, slot: u64) -> Self {
        let dlob = Box::leak(Box::new(DLOB::default()));
        let notifier = dlob.spawn_notifier();

        let notifier_ref = notifier.clone();
        for user in users {
            notifier_ref.user_update(
                Wallet::derive_user_account(&user.authority, user.sub_account_id),
                None,
                user,
                slot,
            );
        }

        Self { dlob, notifier }
    }

    /// Return the DLOB instance
    pub fn dlob(&self) -> &'a DLOB {
        self.dlob
    }

    /// Returns a handler suitable for use in grpc_subscribe's on_account
    ///
    /// This will notify the DLOB of order changes based on User account updates
    pub fn account_update_handler<'b>(
        &self,
        account_map: &'b AccountMap,
    ) -> impl Fn(&AccountUpdate) + Send + Sync + 'b {
        let notifier = self.notifier.clone();
        move |update| {
            let new_user = crate::utils::deser_zero_copy(update.data);
            let old_user = account_map
                .account_data_and_slot::<User>(&update.pubkey)
                .map(|x| x.data);
            notifier.user_update(update.pubkey, old_user.as_ref(), new_user, update.slot);
        }
    }

    /// Load an individual user account to the DLOB
    pub fn load_user(&self, pubkey: Pubkey, user: &User, slot: u64) {
        self.notifier.user_update(pubkey, None, user, slot);
    }

    /// Returns a handler suitable for use in grpc_subscribe's on_slot
    ///
    /// This will notify the DLOB of slot/price updates for the given markets.
    pub fn slot_update_handler(
        &self,
        drift: DriftClient,
        markets: Vec<MarketId>,
    ) -> impl Fn(u64) + Send + Sync + 'static {
        let notifier = self.notifier.clone();
        move |new_slot| {
            for market in markets.iter() {
                let oracle_price_data = drift
                    .try_get_mmoracle_for_perp_market(market.index(), new_slot)
                    .expect("got oracle price");

                notifier.slot_and_oracle_update(
                    *market,
                    new_slot,
                    oracle_price_data.price.unsigned_abs(),
                );
            }
        }
    }
}

```

## File: crates/src/dlob/mod.rs
```
use std::{
    cmp::Reverse,
    collections::BTreeMap,
    fmt::Debug,
    iter::Peekable,
    sync::{
        atomic::{AtomicBool, AtomicU64},
        Arc,
    },
    time::{SystemTime, UNIX_EPOCH},
};

use arrayvec::ArrayVec;
use dashmap::{mapref::one::RefMut, DashMap};
use fxhash::FxBuildHasher;
use solana_sdk::pubkey::Pubkey;

use crate::{
    constants::ProgramData,
    dlob::util::order_hash,
    types::{
        accounts::{PerpMarket, User},
        MarketId, MarketType, Order, OrderStatus, OrderTriggerCondition, OrderType,
        PositionDirection,
    },
};

pub mod builder;
#[cfg(test)]
mod tests;
pub mod types;
pub mod util;

pub use types::*;
pub use util::OrderDelta;

/// log target
const TARGET: &str = "dlob";

type Direction = PositionDirection;
type MetadataMap = DashMap<u64, OrderMetadata, FxBuildHasher>;

/// Collection of orders
#[derive(Debug)]
struct Orders<T: OrderKey + Debug + Clone> {
    pub bids: BTreeMap<Reverse<T::Key>, T>,
    pub asks: BTreeMap<T::Key, T>,
}

impl<T: OrderKey + Clone + Debug> Default for Orders<T> {
    fn default() -> Self {
        Self {
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
        }
    }
}

impl<T: Clone + Debug + From<(u64, Order)> + OrderKey> Orders<T> {
    fn insert_raw(&mut self, is_bid: bool, order: T) {
        if is_bid {
            self.bids.insert(Reverse(order.key()), order);
        } else {
            self.asks.insert(order.key(), order);
        }
    }
    pub fn insert(&mut self, order_id: u64, order: Order) {
        self.insert_raw(Direction::Long == order.direction, (order_id, order).into());
    }

    pub fn remove(&mut self, order_id: u64, order: Order) -> bool {
        match order.direction {
            Direction::Long => {
                let order: T = (order_id, order).into();
                self.bids.remove(&Reverse(order.key())).is_some()
            }
            Direction::Short => {
                let order: T = (order_id, order).into();
                self.asks.remove(&order.key()).is_some()
            }
        }
    }

    /// Returns true if update replaced an existing order
    pub fn update(&mut self, order_id: u64, new_order: Order, old_order: Order) -> bool {
        let old_order_for_key: T = (order_id, old_order).into();
        let old_key = old_order_for_key.key();
        let order: T = (order_id, new_order).into();
        match new_order.direction {
            Direction::Long => {
                let replaced = self.bids.remove(&Reverse(old_key)).is_some();
                if replaced {
                    self.insert_raw(true, order);
                }
                replaced
            }
            Direction::Short => {
                let replaced = self.asks.remove(&old_key).is_some();
                if replaced {
                    self.insert_raw(false, order);
                }
                replaced
            }
        }
    }
}

/// Orderbook for a specific market
///
/// Orders are kept in lists of similar types for efficient comparisons
///
/// aggregated L2 and L3 views are also maintained
#[derive(Default)]
struct Orderbook {
    /// market auctions with fixed price bounds, changes by slot
    market_orders: Orders<MarketOrder>,
    /// oracle auctions with dynamic price bounds, changes by slot
    oracle_orders: Orders<OracleOrder>,
    /// orders to fill at fixed price
    resting_limit_orders: Orders<LimitOrder>,
    /// orders to fill at offset from oracle price
    floating_limit_orders: Orders<FloatingLimitOrder>,
    /// list of (un)triggered orders
    /// triggered orders are moved to market_orders or oracle_orders
    trigger_orders: Orders<TriggerOrder>,
    /// L2 book snapshot
    l2_snapshot: Snapshot<L2Book>,
    /// L3 book snapshot
    l3_snapshot: Snapshot<L3Book>,
    /// market tick size
    market_tick_size: u64,
    /// slot where dynamic orders where last checked
    last_modified_slot: u64,
    /// market index of this book
    market: MarketId,
}

impl Orderbook {
    /// Create a new Orderbook with object pools for efficient memory management
    pub fn new(market: MarketId, market_tick_size: u64) -> Self {
        Self {
            market_orders: Orders::default(),
            oracle_orders: Orders::default(),
            resting_limit_orders: Orders::default(),
            floating_limit_orders: Orders::default(),
            trigger_orders: Orders::default(),
            market_tick_size,
            last_modified_slot: 0,
            market,
            l2_snapshot: Default::default(),
            l3_snapshot: Default::default(),
        }
    }

    /// Update the L2 snapshot
    pub fn update_l2_view(&self, oracle_price: u64) {
        self.l2_snapshot.write(|b| {
            b.load_orderbook(&self, oracle_price);
        });
    }

    /// Update the L3 snapshot
    pub fn update_l3_view(&self, oracle_price: u64, metadata: &MetadataMap) {
        self.l3_snapshot.write(|b| {
            b.load_orderbook(&self, oracle_price, metadata);
        });
    }

    /// Update auction order prices to new `slot`
    pub fn update_slot(&mut self, slot: u64) {
        log::trace!(target: TARGET,"update book slot. market:{},slot:{slot}", self.market.index());
        self.expire_auction_orders(slot);
        self.last_modified_slot = slot;
    }

    /// Expire all auctions past current `slot`
    ///
    /// limit orders with finishing auctions are moved to resting orders
    fn expire_auction_orders(&mut self, slot: u64) {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        self.market_orders.asks.retain(|_, x| {
            let mut keep = true;
            let is_auction_complete = x.is_auction_complete(slot);
            if is_auction_complete {
                if x.is_limit {
                    log::trace!(target: TARGET, "market auction => resting: {}@{}", x.id, slot);
                    self.resting_limit_orders
                        .insert_raw(false, x.to_limit_order());
                    keep = false;
                } else if x.is_expired(now) {
                    log::trace!(target: TARGET, "market auction expired: {}@{}", x.id, slot);
                    keep = false;
                }
            }
            keep
        });
        self.market_orders.bids.retain(|_, x| {
            let mut keep = true;
            let is_auction_complete = x.is_auction_complete(slot);
            if is_auction_complete {
                if x.is_limit {
                    log::trace!(target: TARGET, "market auction => resting:: {}@{}", x.id, slot);
                    self.resting_limit_orders
                        .insert_raw(true, x.to_limit_order());
                    keep = false;
                } else if x.is_expired(now) {
                    log::trace!(target: TARGET, "market auction expired: {}@{}", x.id, slot);
                    keep = false;
                }
            }
            keep
        });
        self.oracle_orders.asks.retain(|_, x| {
            let mut keep = true;
            let is_auction_complete = x.is_auction_complete(slot);
            if is_auction_complete {
                if x.is_limit {
                    log::trace!(target: TARGET, "oracle auction => resting:: {}@{}", x.id, slot);
                    self.floating_limit_orders
                        .insert_raw(false, x.to_floating_limit_order());
                    keep = false;
                } else if x.is_expired(now) {
                    log::trace!(target: TARGET, "oracle auction expired:: {}@{}", x.id, slot);
                    keep = false;
                }
            }
            keep
        });
        self.oracle_orders.bids.retain(|_, x| {
            let mut keep = true;
            let is_auction_complete = x.is_auction_complete(slot);
            if is_auction_complete {
                if x.is_limit {
                    log::trace!(target: TARGET, "oracle auction => resting:: {}@{}", x.id, slot);
                    self.floating_limit_orders
                        .insert_raw(true, x.to_floating_limit_order());
                    keep = false;
                } else if x.is_expired(now) {
                    log::trace!(target: TARGET, "oracle auction expired:: {}@{}", x.id, slot);
                    keep = false;
                }
            }
            keep
        });
    }
}

/// Channel for sending User order updates to DLOB instance
#[derive(Clone)]
pub struct DLOBNotifier {
    sender: crossbeam::channel::Sender<DLOBEvent>,
}

impl DLOBNotifier {
    pub fn new(sender: crossbeam::channel::Sender<DLOBEvent>) -> Self {
        Self { sender }
    }

    /// Updates the DLOB with user account changes by comparing old and new user states.
    ///
    /// This method processes user account updates and sends appropriate DLOB events to maintain
    /// the order book state. It handles two scenarios:
    /// 1. **User Update**: When both old and new user states are provided, it compares the orders
    ///    and sends delta events for changes (creates, updates, removes)
    /// 2. **New User**: When only a new user is provided, it creates events for all open orders
    ///
    /// # Parameters
    ///
    /// * `pubkey` - The public key of the user account being updated
    /// * `old_user` - The previous state of the user account, if any. `None` indicates a new user
    /// * `new_user` - The current state of the user account
    /// * `slot` - The slot number when this update occurred
    ///
    /// # Panics
    ///
    /// This method will panic if it cannot send events to the DLOB channel, which typically
    /// indicates the DLOB processing thread has been dropped or the channel is full.
    ///
    /// # Example
    ///
    /// ```rust
    /// // Update existing user
    /// notifier.user_update(user_pubkey, Some(&old_user), &new_user, current_slot);
    ///
    /// // Add new user
    /// notifier.user_update(user_pubkey, None, &new_user, current_slot);
    /// ```
    pub fn user_update(&self, pubkey: Pubkey, old_user: Option<&User>, new_user: &User, slot: u64) {
        let deltas = match old_user {
            Some(old_user) => crate::dlob::util::compare_user_orders(pubkey, old_user, new_user),
            None => new_user
                .orders
                .iter()
                .filter(|o| {
                    o.status == OrderStatus::Open
                        && o.base_asset_amount > o.base_asset_amount_filled
                })
                .map(|o| OrderDelta::Create {
                    order: *o,
                    user: pubkey,
                })
                .collect(),
        };
        self.sender
            .send(DLOBEvent::Deltas { deltas, slot })
            .expect("Failed to send DLOB event - channel may be closed");
    }

    #[inline]
    pub fn slot_and_oracle_update(&self, market: MarketId, slot: u64, oracle_price: u64) {
        self.sender
            .send(DLOBEvent::SlotAndOracleUpdate {
                slot,
                oracle_price,
                market,
            })
            .expect("Failed to send slot update event - channel may be closed");
    }
}

/// Aggregates orderbooks for multiple markets
///
/// The DLOB is incrementally built and event driven, consumers spawn the notifier and submit slot and user order updates
/// to maintain live orderbook state.
///
/// Users can call [`get_l3_snapshot`](DLOB::get_l3_snapshot) to obtain an L3 snapshot
/// and inspect the bids and asks through the returned `L3Book`.
pub struct DLOB {
    /// Map from market to orderbook
    markets: DashMap<MarketId, Orderbook, FxBuildHasher>,
    /// Map from DLOB internal order ID to order metadata
    metadata: MetadataMap,
    /// static drift program data e.g market tick sizes
    program_data: &'static ProgramData,
    /// last slot update
    last_modified_slot: AtomicU64,
    // Maintain live L2 snapshots (default: false)
    enable_l2_snapshot: AtomicBool,
    // Maintain live L3 snapshots (default: true)
    enable_l3_snapshot: AtomicBool,
}

impl Default for DLOB {
    fn default() -> Self {
        Self {
            markets: DashMap::default(),
            metadata: DashMap::default(),
            program_data: Box::leak(Box::new(ProgramData::uninitialized())),
            last_modified_slot: Default::default(),
            enable_l2_snapshot: AtomicBool::new(false),
            enable_l3_snapshot: AtomicBool::new(true),
        }
    }
}

impl DLOB {
    /// Enable live L2 snapshots for all orderbooks (default: disabled)
    pub fn enable_l2_snapshot(&self) {
        self.enable_l2_snapshot
            .store(true, std::sync::atomic::Ordering::Relaxed);
    }
    /// Disable live L3 snapshots for all orderbooks (default: enabled)
    pub fn disable_l3_snapshot(&self) {
        self.enable_l3_snapshot
            .store(false, std::sync::atomic::Ordering::Relaxed);
    }

    /// Provides a writer channel into the DLOB which acts as a sink for external events
    pub fn spawn_notifier(&'static self) -> DLOBNotifier {
        let (tx, rx) = crossbeam::channel::bounded(2048);
        std::thread::spawn(move || {
            while let Ok(event) = rx.recv() {
                match event {
                    DLOBEvent::SlotAndOracleUpdate {
                        market,
                        slot,
                        oracle_price,
                    } => {
                        self.update_slot_and_oracle_price(market, slot, oracle_price);
                    }
                    DLOBEvent::Deltas { slot, deltas } => {
                        for delta in deltas {
                            match delta {
                                OrderDelta::Create { user, order } => {
                                    self.insert_order(&user, slot, order);
                                }
                                OrderDelta::Update {
                                    user,
                                    new_order,
                                    old_order,
                                } => {
                                    self.update_order(&user, slot, new_order, old_order);
                                }
                                OrderDelta::Remove { user, order } => {
                                    self.remove_order(&user, slot, order);
                                }
                            }
                        }
                    }
                }
            }
            log::error!(target: TARGET, "notifier thread finished");
        });

        DLOBNotifier::new(tx)
    }

    /// run function on a market Orderbook
    fn with_orderbook_mut(&self, market_id: &MarketId, f: impl Fn(RefMut<MarketId, Orderbook>)) {
        let ob = self.markets.entry(*market_id).or_insert({
            // initialize book on first write
            let market_tick_size: u64 = match market_id.kind() {
                MarketType::Perp => self
                    .program_data
                    .perp_market_config_by_index(market_id.index())
                    .map(|m| m.amm.order_tick_size)
                    .unwrap_or(1),
                MarketType::Spot => self
                    .program_data
                    .spot_market_config_by_index(market_id.index())
                    .map(|m| m.order_tick_size)
                    .unwrap_or(1),
            };
            Orderbook::new(*market_id, market_tick_size)
        });
        f(ob);
    }

    /// Update orderbook slot and oracle price for market
    fn update_slot_and_oracle_price(&self, market: MarketId, slot: u64, oracle_price: u64) {
        let last_modified_slot = self
            .last_modified_slot
            .load(std::sync::atomic::Ordering::Relaxed);

        if slot < last_modified_slot {
            log::warn!(
                target: TARGET, "ignoring out of order slot update: update:{slot},ours:{last_modified_slot}",
            );
            return;
        }

        self.with_orderbook_mut(&market, |mut book| {
            book.update_slot(slot);
            if self
                .enable_l2_snapshot
                .load(std::sync::atomic::Ordering::Relaxed)
            {
                book.update_l2_view(oracle_price);
            }
            if self
                .enable_l3_snapshot
                .load(std::sync::atomic::Ordering::Relaxed)
            {
                book.update_l3_view(oracle_price, &self.metadata);
            }
        });

        self.last_modified_slot
            .store(slot, std::sync::atomic::Ordering::Relaxed)
    }

    /// Get an L2 book of current orders
    ///
    /// It is valid at the current slot
    pub fn get_l2_snapshot(&self, market_index: u16, market_type: MarketType) -> Arc<L2Book> {
        let book = self
            .markets
            .get(&MarketId::new(market_index, market_type))
            .expect("orderbook exists for market");
        book.l2_snapshot.read()
    }

    /// Get an L3 book of current orders
    ///
    /// It is valid at the current slot
    pub fn get_l3_snapshot(&self, market_index: u16, market_type: MarketType) -> Arc<L3Book> {
        let book = self
            .markets
            .get(&MarketId::new(market_index, market_type))
            .expect("orderbook exists for market");
        book.l3_snapshot.read()
    }

    pub fn find_crossing_region(
        &self,
        oracle_price: u64,
        market_index: u16,
        market_type: MarketType,
        perp_market: Option<&PerpMarket>,
    ) -> Option<CrossingRegion> {
        let book = self.get_l3_snapshot(market_index, market_type);

        let mut bids = book.bids(Some(oracle_price), perp_market, None);
        let mut asks = book.asks(Some(oracle_price), perp_market, None);

        let best_bid = bids.next()?.price;
        let best_ask = asks.next()?.price;

        if best_bid < best_ask {
            return None;
        }

        let crossing_bids: Vec<L3Order> = bids
            .take_while(|b| b.price > best_ask)
            .map(|x| x.clone())
            .collect();
        let crossing_asks: Vec<L3Order> = asks
            .take_while(|a| a.price < best_bid)
            .map(|x| x.clone())
            .collect();

        if crossing_asks.is_empty() && crossing_bids.is_empty() {
            return None;
        }

        Some(CrossingRegion {
            slot: book.slot,
            crossing_bids,
            crossing_asks,
        })
    }

    fn update_order(&self, user: &Pubkey, slot: u64, new_order: Order, old_order: Order) {
        let order_id = order_hash(user, new_order.order_id);
        log::trace!(target: TARGET, "update order: {order_id},{},{:?} @ {slot}", old_order.order_id, new_order.order_type);

        if new_order.status != OrderStatus::Open {
            log::info!(target: TARGET, "update into remove: {order_id:?}");
            self.remove_order(user, slot, new_order);
            return;
        }

        self.with_orderbook_mut(&MarketId::new(new_order.market_index, new_order.market_type), |mut orderbook| {
            let mut new_meta_kind: Option<OrderKind> = None;
            if let Some(metadata) = self.metadata.get(&order_id) {
                log::trace!(target: TARGET, "update ({order_id}): {:?}", metadata.kind);
                let mut updated = false;

                match metadata.kind {
                    OrderKind::Market | OrderKind::MarketTriggered => {
                        updated = orderbook.market_orders.update(order_id, new_order, old_order);
                    }
                    OrderKind::Oracle | OrderKind::OracleTriggered => {
                        updated = orderbook.oracle_orders.update(order_id, new_order, old_order);
                    }
                    OrderKind::LimitAuction | OrderKind::LimitTriggered => {
                        // if the auction completed, check if order moved to resting
                        let auction_in_progress = old_order.slot + old_order.auction_duration as u64 > slot;
                        if auction_in_progress {
                            log::trace!(target: TARGET, "update limit auction: {order_id}");
                            updated = orderbook.market_orders.update(order_id, new_order, old_order);
                        }

                        if !updated {
                            log::trace!(target: TARGET, "update limit auction (resting): {order_id}");
                            // Remove from market_orders and insert into resting_limit_orders
                            orderbook.market_orders.remove(order_id, old_order);
                            orderbook.resting_limit_orders.insert(order_id, new_order);
                            updated = true;
                            new_meta_kind = Some(OrderKind::Limit);
                        }
                    }
                    OrderKind::FloatingLimitAuction => {
                        // if the auction completed, check if order moved to resting
                        let auction_in_progress = old_order.slot + old_order.auction_duration as u64 > slot;
                        if auction_in_progress {
                            log::trace!(target: TARGET, "update oracle limit: {order_id}");
                            updated = orderbook.oracle_orders.update(order_id, new_order, old_order);
                        }

                        if !updated {
                            log::trace!(target: TARGET, "update oracle limit (resting): {order_id}");
                            // Remove from oracle_orders and insert into floating_limit_orders
                            orderbook.oracle_orders.remove(order_id, old_order);
                            orderbook.floating_limit_orders.insert(order_id, new_order);
                            updated = true;
                            new_meta_kind = Some(OrderKind::FloatingLimit);
                        }
                    }
                    OrderKind::Limit => {
                        updated = orderbook.resting_limit_orders.update(order_id, new_order, old_order);
                    }
                    OrderKind::FloatingLimit => {
                        updated = orderbook.floating_limit_orders.update(order_id, new_order, old_order);
                    }
                    OrderKind::TriggerMarket => {
                        log::trace!(target: TARGET, "update trigger market order: {order_id},{:?}", new_order);
                        match new_order.trigger_condition {
                            OrderTriggerCondition::Above | OrderTriggerCondition::Below => {
                                updated = orderbook.trigger_orders.update(order_id, new_order, old_order);
                            }
                            OrderTriggerCondition::TriggeredAbove | OrderTriggerCondition::TriggeredBelow => {
                                // order has been triggered, its an ordinary auction order now
                                 orderbook.trigger_orders.remove(order_id, old_order);
                                let new_kind = if new_order.is_oracle_trigger_market() {
                                     orderbook.oracle_orders.insert(order_id, new_order);
                                    OrderKind::OracleTriggered
                                } else {
                                     orderbook.market_orders.insert(order_id, new_order);
                                    OrderKind::MarketTriggered
                                };
                                updated = true;
                                new_meta_kind = Some(new_kind);
                            }
                        }
                    }
                    OrderKind::TriggerLimit => {
                        log::trace!(target: TARGET, "update trigger limit order: {order_id},{:?}", new_order);
                        match new_order.trigger_condition {
                            OrderTriggerCondition::Above | OrderTriggerCondition::Below => {
                                updated = orderbook.trigger_orders.update(order_id, new_order, old_order);
                            }
                            OrderTriggerCondition::TriggeredAbove | OrderTriggerCondition::TriggeredBelow => {
                                // order has been triggered, its an ordinary auction order now
                                log::trace!(target: TARGET, "trigger limit => market auction: {order_id}");
                                orderbook.trigger_orders.remove(order_id, old_order);
                                orderbook.market_orders.insert(order_id, new_order);
                                updated = true;
                                new_meta_kind = Some(OrderKind::LimitTriggered);
                            }
                        }
                    }
                }

                if !updated {
                    log::warn!(target: TARGET, "update order failed: {order_id}, {:?}, {old_order:?}, {new_order:?}", metadata.value());
                }
            }
            if let Some(kind) = new_meta_kind {
                self.metadata.insert(order_id, OrderMetadata::new(*user, kind, new_order.order_id, new_order.max_ts.unsigned_abs()));
            }
        });
    }

    fn remove_order(&self, user: &Pubkey, slot: u64, order: Order) {
        let order_id = order_hash(user, order.order_id);

        self.with_orderbook_mut(&MarketId::new(order.market_index, order.market_type), |mut orderbook| {
            if let Some((_, metadata)) = self.metadata.remove(&order_id) {
                let mut order_removed;
                log::trace!(target: TARGET, "remove order: {order_id} @ status: {:?}, kind: {:?}/{:?}, slot: {slot}", order.status, metadata.kind, order.order_type);

                match metadata.kind {
                    OrderKind::Market | OrderKind::MarketTriggered => {
                        order_removed = orderbook.market_orders.remove(order_id, order);
                    }
                    OrderKind::Oracle | OrderKind::OracleTriggered => {
                        order_removed = orderbook.oracle_orders.remove(order_id, order);
                    }
                    OrderKind::LimitAuction | OrderKind::LimitTriggered => {
                        // if the auction completed, check if order moved to resting
                        log::trace!(target: TARGET, "remove auction limit order: {order_id}");
                        order_removed = orderbook.market_orders.remove(order_id, order);
                        if !order_removed {
                            log::trace!(target: TARGET, "remove auction limit order (resting): {order_id}");
                            order_removed = orderbook.resting_limit_orders.remove(order_id, order);
                        }
                    }
                    OrderKind::FloatingLimitAuction => {
                        // if the auction completed, check if order moved to resting
                        log::trace!(target: TARGET, "remove oracle order: {order_id}, order.slot: {}, order.duration: {}", order.slot, order.auction_duration);
                        order_removed = orderbook.oracle_orders.remove(order_id, order);
                        if !order_removed {
                            log::trace!(target: TARGET, "remove limit order: {order_id}");
                            order_removed = orderbook.floating_limit_orders.remove(order_id, order);
                        }
                    }
                    OrderKind::Limit => {
                        order_removed = orderbook.resting_limit_orders.remove(order_id, order);
                    }
                    OrderKind::FloatingLimit => {
                        order_removed = orderbook.floating_limit_orders.remove(order_id, order);
                    }
                    OrderKind::TriggerMarket | OrderKind::TriggerLimit => {
                        log::trace!(target: TARGET, "trigger order: {order_id},{:?}", order.trigger_condition);
                        order_removed = orderbook.trigger_orders.remove(order_id, order);
                    }
                }

                if !order_removed && order.max_ts.unsigned_abs() > SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() {
                    log::warn!(
                        target: TARGET,
                        "remove order failed: {order_id} not removed. kind: {:?}, user: {}, order_id: {}",
                        metadata.kind,
                        metadata.user,
                        metadata.order_id,
                    );
                }
            }
        });
    }

    fn insert_order(&self, user: &Pubkey, slot: u64, order: Order) {
        let order_id = order_hash(user, order.order_id);
        log::trace!(target: TARGET, "insert order: {order_id} @ {slot}");

        if order.base_asset_amount <= order.base_asset_amount_filled {
            log::trace!(target: TARGET, "skipping fully filled order: {order:?}");
            return;
        }

        self.with_orderbook_mut(
            &MarketId::new(order.market_index, order.market_type),
            |mut orderbook| {
               let kind = match order.order_type {
                    OrderType::Market => {
                        orderbook.market_orders.insert(order_id, order);
                        OrderKind::Market
                    }
                    OrderType::Oracle => {
                        orderbook.oracle_orders.insert(order_id, order);
                        OrderKind::Oracle
                    }
                    OrderType::Limit => {
                        /*
                        maker orders:
                            - limit order with POST_ONLY=true
                            - limit order with POST_ONLY=false and auction is completed*
                        crossing:
                            - limit orders with both POST_ONLY=true cannot cross
                            - limit orders with both POST_ONLY=FALSE can cross, *older order becomes maker
                            - limit order with POST_ONLY=TRUE can become maker for POST_ONLY=FALSE
                        */
                        let is_floating = order.oracle_price_offset != 0;
                        let is_post_only = order.post_only;
                        let is_auction = order.auction_duration != 0;
                        let order_kind = if !is_post_only {
                            match (is_auction, is_floating) {
                                (true, true) => {
                                    orderbook.oracle_orders.insert(order_id, order);
                                    OrderKind::FloatingLimitAuction
                                }
                                (true, false) => {
                                    orderbook.market_orders.insert(order_id, order);
                                    OrderKind::LimitAuction
                                }
                                (false, true) => {
                                    orderbook.floating_limit_orders.insert(order_id, order);
                                    OrderKind::FloatingLimit
                                }
                                (false, false) => {
                                    orderbook.resting_limit_orders.insert(order_id, order);
                                    OrderKind::Limit
                                }
                            }
                        } else {
                            // post only cannot have an auction (maker side only)
                            if is_floating {
                                orderbook.floating_limit_orders.insert(order_id, order);
                                OrderKind::FloatingLimit
                            } else {
                                orderbook.resting_limit_orders.insert(order_id, order);
                                OrderKind::Limit
                            }
                        };
                        log::trace!(target: TARGET, "insert limit order: {order_id},{:?}", order_kind);
                        order_kind
                    }
                    OrderType::TriggerMarket => match order.trigger_condition {
                        OrderTriggerCondition::Above | OrderTriggerCondition::Below => {
                            log::trace!(target: TARGET, "insert trigger market order: {order_id}");
                            orderbook.trigger_orders.insert(order_id, order);
                            OrderKind::TriggerMarket

                        }
                        OrderTriggerCondition::TriggeredAbove | OrderTriggerCondition::TriggeredBelow => {
                            if order.is_oracle_trigger_market() {
                                log::trace!(target: TARGET, "insert triggered oracle order: {order_id}");
                                orderbook.oracle_orders.insert(order_id, order);
                                OrderKind::OracleTriggered
                            } else {
                                log::trace!(target: TARGET, "insert triggered market order: {order_id}");
                                orderbook.market_orders.insert(order_id, order);
                                OrderKind::MarketTriggered
                           }
                        }
                    },
                    OrderType::TriggerLimit => match order.trigger_condition {
                        OrderTriggerCondition::Above | OrderTriggerCondition::Below => {
                            log::trace!(target: TARGET, "insert trigger limit order: {order_id}");
                            orderbook.trigger_orders.insert(order_id, order);
                            OrderKind::TriggerLimit
                        }
                        OrderTriggerCondition::TriggeredAbove
                        | OrderTriggerCondition::TriggeredBelow => {
                            log::trace!(target: TARGET, "insert triggered limit order: {order_id}");
                            orderbook.market_orders.insert(order_id, order);
                            OrderKind::LimitTriggered
                        }
                    },
                };
                self.metadata.insert(order_id, OrderMetadata::new(*user, kind, order.order_id, order.max_ts.unsigned_abs()));
            },
        );
    }

    /// Helper to find a crossing pair of limit orders at the top of the book, if any.
    ///
    /// The crossing orders could from the same user account and so un-fillable
    fn find_limit_cross(&self, bid: &L3Order, ask: &L3Order) -> Option<(L3Order, L3Order)> {
        if bid.price < ask.price || bid.user == ask.user {
            return None;
        }
        match (bid.is_post_only(), ask.is_post_only()) {
            (true, false) => Some((ask.clone(), bid.clone())),
            (false, true) => Some((bid.clone(), ask.clone())),
            (false, false) => {
                // TODO: use slot
                if bid.max_ts < ask.max_ts {
                    Some((bid.clone(), ask.clone()))
                } else {
                    Some((ask.clone(), bid.clone()))
                }
            }
            (true, true) => None,
        }
    }

    /// At the current slot return all auctions crossing resting limit orders (i.e uncross)
    ///
    /// ## Panics
    ///
    /// if market_index,market_type has not been initialized on this dlob instance
    ///
    pub fn find_crosses_for_auctions(
        &self,
        market_index: u16,
        market_type: MarketType,
        slot: u64,
        oracle_price: u64,
        perp_market: Option<&PerpMarket>,
        depth: Option<usize>,
    ) -> CrossesAndTopMakers {
        let book = self.get_l3_snapshot(market_index, market_type);
        let mut all_crosses = Vec::with_capacity(16);

        let vamm_bid = perp_market.map(|m| m.bid_price(None));
        let vamm_ask = perp_market.map(|m| m.ask_price(None));
        log::trace!(target: TARGET, "VAMM market={} bid={vamm_bid:?} ask={vamm_ask:?}", market_index);

        let (taker_asks, resting_asks): (Vec<L3Order>, Vec<L3Order>) = book
            .top_asks(depth.unwrap_or(64), Some(oracle_price), perp_market, None)
            .map(|x| x.clone())
            .partition(|x| x.is_taker());

        let (taker_bids, resting_bids): (Vec<L3Order>, Vec<L3Order>) = book
            .top_bids(depth.unwrap_or(64), Some(oracle_price), perp_market, None)
            .map(|x| x.clone())
            .partition(|x| x.is_taker());

        let mut vamm_taker_ask = None;
        let mut vamm_taker_bid = None;

        let mut limit_crosses = None;
        if let (Some(best_bid), Some(best_ask)) = (resting_bids.first(), resting_asks.first()) {
            // check for crossing resting limit orders
            limit_crosses = self.find_limit_cross(best_bid, best_ask);
            // check for VAMM crossing resting limit orders
            if vamm_bid.is_some_and(|v| v > best_ask.price && best_ask.is_post_only())
                && perp_market.is_some_and(|m| best_ask.size > m.amm.min_order_size)
            {
                vamm_taker_bid = Some(best_ask.clone());
            }
            if vamm_ask.is_some_and(|v| v < best_bid.price && best_bid.is_post_only())
                && perp_market.is_some_and(|m| best_bid.size > m.amm.min_order_size)
            {
                vamm_taker_ask = Some(best_bid.clone());
            }
        }

        let top_3_maker_bids: ArrayVec<Pubkey, 3> =
            resting_bids.iter().take(3).map(|o| o.user).collect();

        // Check for crosses between auction bids and resting asks
        for taker_bid in taker_bids {
            let new_crosses = self.find_crosses_for_taker_order_inner(
                slot,
                taker_bid.price,
                taker_bid.size,
                taker_bid.is_long(),
                resting_asks.iter().peekable(),
                vamm_ask,
            );

            if !new_crosses.is_empty() {
                all_crosses.push((taker_bid, new_crosses));
            } else {
                break;
            }
        }

        let top_3_maker_asks: ArrayVec<Pubkey, 3> =
            resting_asks.iter().take(3).map(|o| o.user).collect();

        // Check for crosses between auction asks and resting bids
        for taker_ask in taker_asks {
            let new_crosses = self.find_crosses_for_taker_order_inner(
                slot,
                taker_ask.price,
                taker_ask.size,
                taker_ask.is_long(),
                resting_bids.iter().peekable(),
                vamm_bid,
            );

            if !new_crosses.is_empty() {
                all_crosses.push((taker_ask, new_crosses));
            } else {
                break;
            }
        }

        CrossesAndTopMakers {
            top_maker_asks: top_3_maker_asks,
            top_maker_bids: top_3_maker_bids,
            crosses: all_crosses,
            limit_crosses,
            vamm_taker_ask,
            vamm_taker_bid,
        }
    }

    /// At the current slot and oracle price return all orders crossing a given taker order
    ///
    /// # Parameters
    ///
    /// * `current_slot` - The current slot number, used for time-sensitive order logic.
    /// * `oracle_price` - The current oracle price, used for price calculations and trigger conditions.
    /// * `taker_order` - The taker order for which to find matching maker orders. Contains price, size, direction, and market info.
    /// * `perp_market` - PerpMarket struct provides vamm price, fallback price, and trigger price
    /// * `depth` - Optional order depth to consider for matches. default: 20
    ///
    /// ## Panics
    ///
    /// if market_index,market_type has not been initialized on this dlob instance
    ///
    /// # Returns
    ///
    /// Returns a `MakerCrosses` struct containing the list of matched maker orders, the slot, whether the match is partial, and if a vAMM cross occurred.
    pub fn find_crosses_for_taker_order(
        &self,
        current_slot: u64,
        oracle_price: u64,
        taker_order: TakerOrder,
        perp_market: Option<&PerpMarket>,
        depth: Option<usize>,
    ) -> MakerCrosses {
        let (resting_orders, vamm_price) = match taker_order.direction {
            Direction::Long => {
                let book = self.get_l3_snapshot(taker_order.market_index, taker_order.market_type);
                let orders: Vec<L3Order> = book
                    .top_asks(depth.unwrap_or(20), Some(oracle_price), perp_market, None)
                    .cloned()
                    .collect();
                (orders, perp_market.map(|p| p.ask_price(None)))
            }
            Direction::Short => {
                let book = self.get_l3_snapshot(taker_order.market_index, taker_order.market_type);
                let orders: Vec<L3Order> = book
                    .top_bids(depth.unwrap_or(20), Some(oracle_price), perp_market, None)
                    .cloned()
                    .collect();
                (orders, perp_market.map(|p| p.bid_price(None)))
            }
        };

        let is_long = taker_order.direction == PositionDirection::Long;
        self.find_crosses_for_taker_order_inner(
            current_slot,
            taker_order.price,
            taker_order.size,
            is_long,
            resting_orders.iter().peekable(),
            vamm_price,
        )
    }

    /// Find crosses for given `taker_order` consuming or updating `resting_limit_orders` upon finding a match
    fn find_crosses_for_taker_order_inner<'a>(
        &self,
        current_slot: u64,
        taker_price: u64,
        taker_size: u64,
        is_long: bool,
        mut resting_limit_orders: Peekable<impl Iterator<Item = &'a L3Order>>,
        vamm_price: Option<u64>,
    ) -> MakerCrosses {
        let mut candidates = ArrayVec::<(L3Order, u64), 16>::new();
        let mut remaining_size = taker_size;

        let price_crosses = if is_long {
            |taker_price: u64, maker_price: u64| taker_price > maker_price
        } else {
            |taker_price: u64, maker_price: u64| taker_price < maker_price
        };

        while let Some(maker_order) = resting_limit_orders.peek() {
            if !price_crosses(taker_price, maker_order.price) {
                break;
            }

            let fill_size = remaining_size.min(maker_order.size);

            candidates.push(((*maker_order).clone(), fill_size));
            remaining_size -= fill_size;

            if fill_size == maker_order.size {
                // Fully consumed — advance the iterator
                resting_limit_orders.next();
            } else {
                // Partially filled, allow subsequent matches against this maker order
                break;
            }
            if candidates.len() == candidates.capacity() {
                log::debug!(target: TARGET, "reached max number crosses");
                break;
            }
            if remaining_size == 0 {
                break;
            }
        }

        MakerCrosses {
            has_vamm_cross: vamm_price.is_some_and(|v| price_crosses(taker_price, v)),
            orders: candidates,
            slot: current_slot,
            is_partial: remaining_size != 0,
            taker_direction: if is_long {
                Direction::Long
            } else {
                Direction::Short
            },
        }
    }
}

/// L3 Orderbook view
#[derive(Debug, Default, Clone)]
pub struct L3Book {
    pub slot: u64,
    /// oracle price used to construct the snapshot
    oracle_price: u64,
    /// bids with fixed price
    bids: Vec<L3Order>,
    /// bids offset from oracle
    floating_bids: Vec<L3Order>,
    /// taker only bids at VAMM price
    vamm_bids: Vec<L3Order>,
    /// trigger orders (bids) - sorted by trigger price, post-trigger price calculated dynamically
    trigger_bids: Vec<L3Order>,
    /// asks with fixed price
    asks: Vec<L3Order>,
    /// asks offset from oracle
    floating_asks: Vec<L3Order>,
    /// taker only asks at VAMM price
    vamm_asks: Vec<L3Order>,
    /// trigger orders (asks) - sorted by trigger price, post-trigger price calculated dynamically
    trigger_asks: Vec<L3Order>,
}

impl L3Book {
    /// Return iterator over list of trigger-able bids at given `trigger_price`
    pub fn trigger_bids(&self, trigger_price: u64) -> impl Iterator<Item = &L3Order> {
        self.trigger_bids.iter().filter(move |x| {
            (x.is_trigger_above() && trigger_price > x.price)
                || (!x.is_trigger_above() && trigger_price < x.price)
        })
    }
    /// Return iterator over list of trigger-able asks at given `trigger_price`
    pub fn trigger_asks(&self, trigger_price: u64) -> impl Iterator<Item = &L3Order> {
        self.trigger_asks.iter().filter(move |x| {
            (x.is_trigger_above() && trigger_price > x.price)
                || (!x.is_trigger_above() && trigger_price < x.price)
        })
    }
    /// Get all L3 bids
    ///
    /// # Parameters
    /// - `oracle_price`: oracle price for floating order price calculations
    /// - `perp_market`: Used to calculate VAMM fallback price of market/oracle (taker) auctions.
    ///    use `None` if only interested in maker orders
    /// - `trigger_price`: Optional trigger price for calculating post-trigger prices of trigger orders.
    ///    If provided, trigger orders will be included and sorted by their post-trigger price.
    ///
    /// # Returns
    /// Returns an iterator over the bids
    pub fn bids<'b>(
        &self,
        oracle_price: Option<u64>,
        perp_market: Option<&'b PerpMarket>,
        trigger_price: Option<u64>,
    ) -> impl Iterator<Item = &L3Order> + use<'_, 'b> {
        let mut bids_iter = self.bids.iter().peekable();
        let mut floating_iter = self.floating_bids.iter().peekable();
        let mut vamm_iter = self.vamm_bids.iter().peekable();
        let mut trigger_iter = self.trigger_bids.iter().peekable();
        let oracle_diff: i64 =
            (oracle_price.unwrap_or_default() as i64).saturating_sub(self.oracle_price as i64);

        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        let slot = self.slot;
        let oracle_price_for_vamm = oracle_price.unwrap_or(self.oracle_price) as i64;

        // Skip non-triggering trigger orders
        if let Some(trig_price) = trigger_price {
            while let Some(x) = trigger_iter.peek() {
                let would_trigger = (x.is_trigger_above() && trig_price > x.price)
                    || (!x.is_trigger_above() && trig_price < x.price);
                if would_trigger {
                    break;
                }
                trigger_iter.next();
            }
        }

        enum Src {
            Fixed,
            Floating,
            Vamm,
            Trigger,
        }

        let next_from = move || {
            let a = bids_iter.peek();
            let f = floating_iter.peek();
            let t = trigger_iter.peek();
            let v = vamm_iter.peek();

            let mut best_price = u64::MIN;
            let mut best_src = None;

            if let Some(x) = a {
                best_price = x.price;
                best_src = Some(Src::Fixed);
            }

            if let Some(x) = f {
                let price = (x.price as i64 + oracle_diff) as u64;
                if price > best_price {
                    best_price = price;
                    best_src = Some(Src::Floating);
                }
            }

            if let Some(market) = perp_market {
                // include trigger orders at their post-trigger price
                if let (Some(x), Some(trig_price)) = (t, trigger_price) {
                    let would_trigger = (x.is_trigger_above() && trig_price > x.price)
                        || (!x.is_trigger_above() && trig_price < x.price);
                    if would_trigger {
                        if let Some(post_trigger_price) =
                            x.post_trigger_price(slot, trig_price, market)
                        {
                            if post_trigger_price > best_price {
                                best_price = post_trigger_price;
                                best_src = Some(Src::Trigger);
                            }
                        }
                    }
                }

                if let Some(x) = v {
                    if let Ok(vamm_price) = market.fallback_price(
                        Direction::Long,
                        oracle_price_for_vamm,
                        x.max_ts.saturating_sub(now) as i64,
                    ) {
                        if vamm_price > best_price {
                            best_src = Some(Src::Vamm);
                        }
                    }
                }
            }

            match best_src {
                Some(Src::Fixed) => bids_iter.next(),
                Some(Src::Floating) => floating_iter.next(),
                Some(Src::Vamm) => vamm_iter.next(),
                Some(Src::Trigger) => trigger_iter.next(),
                None => None,
            }
        };

        std::iter::from_fn(next_from)
    }
    /// Get the top N bids
    ///
    /// # Parameters
    /// - `count`: Maximum number of bids to return
    /// - `oracle_price`: Current oracle price for floating order price adjustments
    /// - `perp_market`: Used to calculate VAMM fallback price of market/oracle (taker) auctions.
    ///    use `None` if only interested in maker orders
    /// - `trigger_price`: Optional trigger price for calculating post-trigger prices of trigger orders.
    ///
    /// # Returns
    /// Returns an iterator over the highest-priced bids
    pub fn top_bids<'b>(
        &self,
        count: usize,
        oracle_price: Option<u64>,
        perp_market: Option<&'b PerpMarket>,
        trigger_price: Option<u64>,
    ) -> impl Iterator<Item = &L3Order> + use<'_, 'b> {
        self.bids(oracle_price, perp_market, trigger_price)
            .take(count)
    }

    /// Get all L3 asks
    ///
    /// # Parameters
    /// - `oracle_price`: oracle price for floating order price calculations
    /// - `perp_market`: Used to calculate VAMM fallback price of market/oracle (taker) auctions. i.e finished their
    ///   auction period and did not specify a custom limit price
    /// - `trigger_price`: Optional trigger price for calculating post-trigger prices of trigger orders.
    ///    If provided, trigger orders will be included and sorted by their post-trigger price.
    ///
    /// # Returns
    /// Returns an iterator over the asks
    pub fn asks<'b>(
        &self,
        oracle_price: Option<u64>,
        perp_market: Option<&'b PerpMarket>,
        trigger_price: Option<u64>,
    ) -> impl Iterator<Item = &L3Order> + use<'_, 'b> {
        let mut asks_iter = self.asks.iter().peekable();
        let mut floating_iter = self.floating_asks.iter().peekable();
        let mut vamm_iter = self.vamm_asks.iter().peekable();
        let mut trigger_iter = self.trigger_asks.iter().peekable();

        let oracle_diff: i64 =
            (oracle_price.unwrap_or_default() as i64).saturating_sub(self.oracle_price as i64);
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        // Skip non-triggering trigger orders
        if let Some(trig_price) = trigger_price {
            while let Some(x) = trigger_iter.peek() {
                let would_trigger = (x.is_trigger_above() && trig_price > x.price)
                    || (!x.is_trigger_above() && trig_price < x.price);
                if would_trigger {
                    break;
                }
                trigger_iter.next();
            }
        }

        let slot = self.slot;
        let oracle_price_for_vamm = oracle_price.unwrap_or(self.oracle_price) as i64;

        enum Src {
            Fixed,
            Floating,
            Vamm,
            Trigger,
        }

        let next_from = move || {
            let a = asks_iter.peek();
            let f = floating_iter.peek();
            let v = vamm_iter.peek();
            let t = trigger_iter.peek();

            let mut best_price = u64::MAX;
            let mut best_src = None;

            if let Some(x) = a {
                best_price = x.price;
                best_src = Some(Src::Fixed);
            }

            if let Some(x) = f {
                let price = (x.price as i64 + oracle_diff) as u64;
                if price < best_price {
                    best_price = price;
                    best_src = Some(Src::Floating);
                }
            }

            if let Some(market) = perp_market {
                // include trigger orders at their post-trigger price
                if let (Some(x), Some(trig_price)) = (t, trigger_price) {
                    let would_trigger = (x.is_trigger_above() && trig_price > x.price)
                        || (!x.is_trigger_above() && trig_price < x.price);
                    if would_trigger {
                        if let Some(post_trigger_price) =
                            x.post_trigger_price(slot, trig_price, market)
                        {
                            if post_trigger_price < best_price {
                                best_src = Some(Src::Trigger);
                                best_price = post_trigger_price;
                            }
                        }
                    }
                }

                if let Some(x) = v {
                    if let Ok(vamm_price) = market.fallback_price(
                        Direction::Short,
                        oracle_price_for_vamm,
                        x.max_ts.saturating_sub(now) as i64,
                    ) {
                        if vamm_price < best_price {
                            best_src = Some(Src::Vamm);
                        }
                    }
                }
            }

            match best_src {
                Some(Src::Fixed) => asks_iter.next(),
                Some(Src::Floating) => floating_iter.next(),
                Some(Src::Trigger) => trigger_iter.next(),
                Some(Src::Vamm) => vamm_iter.next(),
                None => None,
            }
        };

        std::iter::from_fn(next_from)
    }

    /// Get the top N asks
    ///
    /// # Parameters
    /// - `count`: Maximum number of asks to return
    /// - `oracle_price`: oracle price for floating order price adjustments
    /// - `perp_market`: Used to calculate VAMM fallback price of market/oracle (taker) auctions. i.e finished their
    ///   auction period and did not specify a custom limit price
    /// - `trigger_price`: Optional trigger price for calculating post-trigger prices of trigger orders.
    ///
    /// # Returns
    /// Returns an iterator over the lowest-priced asks
    pub fn top_asks<'b>(
        &self,
        count: usize,
        oracle_price: Option<u64>,
        perp_market: Option<&'b PerpMarket>,
        trigger_price: Option<u64>,
    ) -> impl Iterator<Item = &L3Order> + use<'_, 'b> {
        self.asks(oracle_price, perp_market, trigger_price)
            .take(count)
    }

    /// Populate an `L3Book` instance given an `Orderbook` and `metadata`
    fn load_orderbook(&mut self, orderbook: &Orderbook, oracle_price: u64, metadata: &MetadataMap) {
        self.bids.clear();
        self.asks.clear();
        self.floating_bids.clear();
        self.floating_asks.clear();
        self.vamm_bids.clear();
        self.vamm_asks.clear();
        self.trigger_bids.clear();
        self.trigger_asks.clear();

        self.slot = orderbook.last_modified_slot;
        self.oracle_price = oracle_price;
        let market_tick_size = orderbook.market_tick_size;

        // Debug counters: track orders with missing metadata
        let mut missing_metadata_count = 0u32;
        let mut total_orders_count = 0u32;

        // Add resting limit orders
        for order in orderbook.resting_limit_orders.bids.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                self.bids.push(L3Order {
                    price: order.get_price(),
                    size: order.size,
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8))
                        | L3Order::IS_LONG
                        | (L3Order::IS_POST_ONLY * (order.post_only as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    kind: meta.kind,
                    max_ts: order.max_ts,
                });
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        for order in orderbook.resting_limit_orders.asks.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                self.asks.push(L3Order {
                    price: order.get_price(),
                    size: order.size,
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8))
                        | (L3Order::IS_POST_ONLY * (order.post_only as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    kind: meta.kind,
                    max_ts: order.max_ts,
                });
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        // Add trigger orders
        //
        // Store trigger orders separately - they will be sorted by post-trigger price
        // dynamically when asks/bids() is called with a trigger_price parameter.
        // We include all trigger orders here (not just those near oracle) since
        // the trigger_price parameter in queries may differ from the oracle_price used here.
        for order in orderbook.trigger_orders.bids.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                self.trigger_bids.push(L3Order {
                    price: order.price, // This is the trigger price, not the post-trigger price
                    size: order.size,
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8))
                        | L3Order::IS_LONG
                        | (L3Order::IS_TRIGGER_ABOVE
                            * ((order.condition == OrderTriggerCondition::Above) as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    kind: meta.kind,
                    max_ts: order.max_ts,
                });
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        for order in orderbook.trigger_orders.asks.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                self.trigger_asks.push(L3Order {
                    price: order.price, // This is the trigger price, not the post-trigger price
                    size: order.size,
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8))
                        | (L3Order::IS_TRIGGER_ABOVE
                            * ((order.condition == OrderTriggerCondition::Above) as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    kind: meta.kind,
                    max_ts: order.max_ts,
                });
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        for order in orderbook.market_orders.bids.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                let price = order
                    .get_price(self.slot, oracle_price, market_tick_size)
                    .unwrap_or_default();
                let order = L3Order {
                    price,
                    size: order.size(),
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8)) | L3Order::IS_LONG,
                    user: meta.user,
                    order_id: meta.order_id,
                    max_ts: order.max_ts,
                    kind: meta.kind,
                };
                if order.price > 0 {
                    self.bids.push(order);
                } else {
                    self.vamm_bids.push(order);
                }
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        for order in orderbook.market_orders.asks.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                let price = order
                    .get_price(self.slot, oracle_price, market_tick_size)
                    .unwrap_or_default();
                let order = L3Order {
                    price,
                    size: order.size(),
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    max_ts: order.max_ts,
                    kind: meta.kind,
                };
                if order.price > 0 {
                    self.asks.push(order);
                } else {
                    self.vamm_asks.push(order);
                }
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        // Add floating limit orders
        for order in orderbook.floating_limit_orders.bids.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                self.floating_bids.push(L3Order {
                    price: order.get_price(oracle_price, market_tick_size),
                    size: order.size,
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8))
                        | L3Order::IS_LONG
                        | (L3Order::IS_POST_ONLY * (order.post_only as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    max_ts: order.max_ts,
                    kind: meta.kind,
                });
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        for order in orderbook.floating_limit_orders.asks.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                self.floating_asks.push(L3Order {
                    price: order.get_price(oracle_price, market_tick_size),
                    size: order.size,
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8))
                        | (L3Order::IS_POST_ONLY * (order.post_only as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    max_ts: order.max_ts,
                    kind: meta.kind,
                });
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        // Add oracle orders as taker orders
        for order in orderbook.oracle_orders.bids.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                let price = order
                    .get_price(self.slot, oracle_price, market_tick_size)
                    .unwrap_or_default();
                let order = L3Order {
                    price,
                    size: order.size(),
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8)) | L3Order::IS_LONG,
                    user: meta.user,
                    order_id: meta.order_id,
                    max_ts: order.max_ts,
                    kind: meta.kind,
                };
                if order.price > 0 {
                    self.floating_bids.push(order);
                } else {
                    self.vamm_bids.push(order);
                }
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        for order in orderbook.oracle_orders.asks.values() {
            total_orders_count += 1;
            if let Some(meta) = metadata.get(&order.id) {
                let price = order
                    .get_price(self.slot, oracle_price, market_tick_size)
                    .unwrap_or_default();
                let order = L3Order {
                    price,
                    size: order.size(),
                    flags: (L3Order::RO_FLAG & (order.reduce_only as u8)),
                    user: meta.user,
                    order_id: meta.order_id,
                    max_ts: order.max_ts,
                    kind: meta.kind,
                };
                if order.price > 0 {
                    self.floating_asks.push(order);
                } else {
                    self.vamm_asks.push(order);
                }
            } else {
                missing_metadata_count += 1;
                log::info!(target: TARGET, "missing order id: {:?}", order.id);
            }
        }

        // Log warning if we found orders without metadata
        if missing_metadata_count > 0 {
            log::warn!(
                target: TARGET,
                "L3Book: Found {} orders without metadata out of {} total orders (market: {})",
                missing_metadata_count,
                total_orders_count,
                orderbook.market.index()
            );
        }

        // Sort bids in descending order (highest first)
        self.bids.sort_by(|a, b| b.price.cmp(&a.price));
        // Sort asks in ascending order (lowest first)
        self.asks.sort_by(|a, b| a.price.cmp(&b.price));
        // sort by expiry time (smallest buffer from vamm price first)
        self.vamm_bids.sort_by(|a, b| a.max_ts.cmp(&b.max_ts));
        // sort by expiry time (smallest buffer from vamm price first)
        self.vamm_asks.sort_by(|a, b| a.max_ts.cmp(&b.max_ts));
        // Sort bids in descending order (highest first)
        self.floating_bids.sort_by(|a, b| b.price.cmp(&a.price));
        // Sort asks in ascending order (lowest first)
        self.floating_asks.sort_by(|a, b| a.price.cmp(&b.price));
    }
}

#[derive(Debug, Default, Clone, PartialEq)]
pub struct L2Book {
    /// price → aggregated size (maker orders only)
    pub bids: BTreeMap<u64, u64>,
    /// price → aggregated size (maker orders only)
    pub asks: BTreeMap<u64, u64>,
    /// cumulative order size at VAMM ask
    pub vamm_ask_size: u64,
    /// cumulative order size at VAMM bid
    pub vamm_bid_size: u64,
    pub oracle_price: u64,
    pub slot: u64,
}

impl std::fmt::Display for L2Book {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "L2 Order Book:")?;
        writeln!(f, "-------------")?;

        // Get top 5 asks in order (highest to lowest)
        let asks: Vec<_> = self.asks.iter().take(5).collect();
        for (price, size) in asks {
            writeln!(f, "ASK: {:>10} | {:>10}", price, size)?;
        }

        writeln!(f, "-------------")?;

        // Get top 5 bids (highest to lowest)
        let bids: Vec<_> = self.bids.iter().rev().take(5).collect();
        for (price, size) in bids {
            writeln!(f, "BID: {:>10} | {:>10}", price, size)?;
        }

        Ok(())
    }
}

impl L2Book {
    /// Get the best bid and ask from maker orders (resting limit orders)
    ///
    /// Returns `(best_bid, best_ask)` where each is an `Option<(price, size)>`.
    /// The best bid is the highest price bid, and the best ask is the lowest price ask.
    /// Returns `None` if there are no orders on that side.
    ///
    /// # Example
    /// ```rust
    /// let (bid, ask) = l2_book.bbo();
    /// if let (Some((bid_price, bid_size)), Some((ask_price, ask_size))) = (bid, ask) {
    ///     println!("Best bid: {} @ {}", bid_size, bid_price);
    ///     println!("Best ask: {} @ {}", ask_size, ask_price);
    /// }
    /// ```
    pub fn bbo(&self) -> (Option<(u64, u64)>, Option<(u64, u64)>) {
        (
            self.bids.first_key_value().map(|x| (*x.0, *x.1)),
            self.asks.first_key_value().map(|x| (*x.0, *x.1)),
        )
    }

    /// Get the top N maker bids (resting limit orders) sorted by price descending
    ///
    /// Returns a vector of `(price, size)` tuples for the highest-priced maker bids.
    ///
    /// # Example
    /// ```rust
    /// let top_bids = l2_book.top_bids(5);
    /// for (price, size) in top_bids {
    ///     println!("Bid: {} @ {}", size, price);
    /// }
    /// ```
    pub fn top_bids(&self, count: usize) -> Vec<(u64, u64)> {
        self.bids.iter().take(count).map(|x| (*x.0, *x.1)).collect()
    }

    /// Get the top N maker asks (resting limit orders) sorted by price ascending
    ///
    /// Returns a vector of `(price, size)` tuples for the lowest-priced maker asks.
    ///
    /// # Example
    /// ```rust
    /// let top_asks = l2_book.top_asks(5);
    /// for (price, size) in top_asks {
    ///     println!("Ask: {} @ {}", size, price);
    /// }
    /// ```
    pub fn top_asks(&self, count: usize) -> Vec<(u64, u64)> {
        self.asks.iter().take(count).map(|x| (*x.0, *x.1)).collect()
    }

    fn reset(&mut self) {
        self.bids.clear();
        self.asks.clear();
        self.slot = 0;
        self.oracle_price = 0;
        self.vamm_ask_size = 0;
        self.vamm_bid_size = 0;
    }

    /// Initialize the L2Book with all order types
    ///
    /// NOTE: orders with size 64::MAX indicate max leverage orders
    fn load_orderbook(&mut self, orderbook: &Orderbook, oracle_price: u64) {
        self.reset();
        self.slot = orderbook.last_modified_slot;
        self.oracle_price = oracle_price;
        let market_tick_size = orderbook.market_tick_size;

        // Process resting limit orders (fixed price orders)
        for order in orderbook.resting_limit_orders.bids.values() {
            let size = self.bids.entry(order.price).or_insert(0);
            *size = size.saturating_add(order.size);
        }
        for order in orderbook.resting_limit_orders.asks.values() {
            let size = self.asks.entry(order.price).or_insert(0);
            *size = size.saturating_add(order.size);
        }

        // Process floating limit orders (oracle-relative price orders)
        for order in orderbook.floating_limit_orders.bids.values() {
            let price = order.get_price(oracle_price, market_tick_size);
            let size = self.bids.entry(price).or_insert(0);
            *size = size.saturating_add(order.size);
        }
        for order in orderbook.floating_limit_orders.asks.values() {
            let price = order.get_price(oracle_price, market_tick_size);
            let size = self.asks.entry(price).or_insert(0);
            *size = size.saturating_add(order.size);
        }

        // Process trigger orders as taker orders
        for order in orderbook
            .trigger_orders
            .bids
            .values()
            .filter(|o| o.price <= oracle_price)
        {
            let price = order.price;
            let size = self.bids.entry(price).or_insert(0);

            *size = size.saturating_add(order.size);
        }
        for order in orderbook
            .trigger_orders
            .asks
            .values()
            .filter(|o| o.price >= oracle_price)
        {
            let price = order.price;
            let size = self.asks.entry(price).or_insert(0);

            *size = size.saturating_add(order.size);
        }

        // Process market orders as taker orders
        for order in orderbook.market_orders.bids.values() {
            if order.size > 0 {
                if let Some(price) = order.get_price(self.slot, oracle_price, market_tick_size) {
                    let size = self.bids.entry(price).or_insert(0);
                    *size = size.saturating_add(order.size);
                } else {
                    self.vamm_bid_size += order.size;
                }
            }
        }
        for order in orderbook.market_orders.asks.values() {
            if order.size > 0 {
                if let Some(price) = order.get_price(self.slot, oracle_price, market_tick_size) {
                    let size = self.asks.entry(price).or_insert(0);
                    *size = size.saturating_add(order.size);
                } else {
                    self.vamm_ask_size += order.size;
                }
            }
        }

        // Process oracle orders as taker orders
        for order in orderbook.oracle_orders.bids.values() {
            if order.size > 0 {
                if let Some(price) = order.get_price(self.slot, oracle_price, market_tick_size) {
                    let size = self.bids.entry(price).or_insert(0);
                    *size = size.saturating_add(order.size);
                } else {
                    self.vamm_bid_size += order.size;
                }
            }
        }
        for order in orderbook.oracle_orders.asks.values() {
            if order.size > 0 {
                if let Some(price) = order.get_price(self.slot, oracle_price, market_tick_size) {
                    let size = self.asks.entry(price).or_insert(0);
                    *size = size.saturating_add(order.size);
                } else {
                    self.vamm_ask_size += order.size;
                }
            }
        }
    }
}

```

## File: crates/src/dlob/tests.rs
[Truncated - showing first 1000 chars of 121KB file]
```
use solana_sdk::pubkey::Pubkey;

use crate::{
    dlob::{Direction, OrderKind, Orderbook, Snapshot, TakerOrder, DLOB},
    drift_idl::types::{HistoricalOracleData, AMM},
    math::constants::{AMM_RESERVE_PRECISION, PEG_PRECISION},
    types::{accounts::PerpMarket, MarketId, MarketType, Order, OrderStatus, OrderType},
};

fn create_test_order(
    order_id: u32,
    order_type: OrderType,
    direction: Direction,
    price: i64,
    size: u64,
    slot: u64,
) -> Order {
    Order {
        order_id,
        order_type,
        direction,
        base_asset_amount: size,
        base_asset_amount_filled: 0,
        price: price as u64,
        auction_start_price: price,
        auction_end_price: price,
        slot,
        market_index: 0,
        market_type: MarketType::Perp,
        max_ts: 30,
        status: OrderStatus::Open,
        ..Default::default()
    }
}

#[test]
fn dlob_limit_order_sorting() {
    let _ = env_logger::try_init();
    let dlob = DLOB::default();
    let
```

## File: crates/src/dlob/types.rs
```
use std::{
    fmt::Debug,
    sync::{atomic::AtomicPtr, Arc},
};

use arrayvec::ArrayVec;
use solana_sdk::pubkey::Pubkey;

use crate::{
    dlob::{Direction, OrderDelta},
    ffi::{calculate_auction_price, OraclePriceData},
    math::standardize_price,
    types::{
        accounts::PerpMarket, MarketId, MarketType, Order, OrderParams, OrderStatus,
        OrderTriggerCondition, OrderType, SdkResult,
    },
};

// Replace the key structs with type aliases
type MarketOrderKey = (u64, u64);
type OracleOrderKey = (i64, u64);
type LimitOrderKey = (u64, u64, u64);
type FloatingLimitOrderKey = (i32, u64, u64);
type TriggerOrderKey = (u64, u64);

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug, Copy, PartialEq)]
#[repr(u8)]
pub enum OrderKind {
    /// auction fixed price offset
    Market,
    /// auction oracle offset
    Oracle,
    /// oracle limit order undergoing initial auction (taking)
    FloatingLimitAuction,
    /// fixed limit order undergoing initial auction (taking)
    LimitAuction,
    /// resting limit order
    Limit,
    /// resting oracle limit order
    FloatingLimit,
    /// trigger order that will result in Market or Oracle auction order (untriggered)
    TriggerMarket,
    /// trigger order that will result in Limit/Market auction order (untriggered)
    TriggerLimit,
    /// Triggered oracle order
    OracleTriggered,
    /// Triggered market order
    MarketTriggered,
    /// Triggered limit order
    LimitTriggered,
}

impl OrderKind {
    /// Returns true if the order is a taker order
    pub fn is_taker(&self) -> bool {
        !self.is_maker()
    }
    /// Returns true if the order is a maker order
    pub fn is_maker(&self) -> bool {
        matches!(self, OrderKind::Limit | OrderKind::FloatingLimit)
    }
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug, Copy, PartialEq)]
pub struct OrderMetadata {
    pub max_ts: u64,
    pub order_id: u32,
    pub user: Pubkey,
    pub kind: OrderKind,
}

impl OrderMetadata {
    pub fn new(user: Pubkey, kind: OrderKind, order_id: u32, max_ts: u64) -> Self {
        Self {
            user,
            kind,
            order_id,
            max_ts,
        }
    }
}

/// Minimal taker order info
#[derive(Copy, Clone, Debug)]
pub struct TakerOrder {
    pub price: u64,
    pub size: u64,
    pub market_index: u16,
    pub direction: Direction,
    pub market_type: MarketType,
}

impl TakerOrder {
    pub fn from_order_params(order: OrderParams, price: u64) -> Self {
        Self {
            price,
            size: order.base_asset_amount,
            direction: order.direction,
            market_index: order.market_index,
            market_type: order.market_type,
        }
    }
}

#[derive(Clone, Debug, Default)]
/// Orderbook crosses and top maker info
pub struct CrossesAndTopMakers {
    //  best maker accounts on ask side
    pub top_maker_asks: ArrayVec<Pubkey, 3>,
    //  best maker accounts on bid side
    pub top_maker_bids: ArrayVec<Pubkey, 3>,
    // top of book limit cross, if any
    pub limit_crosses: Option<(L3Order, L3Order)>,
    pub vamm_taker_ask: Option<L3Order>,
    pub vamm_taker_bid: Option<L3Order>,
    //  taker crosses and maker orders
    pub crosses: Vec<(L3Order, MakerCrosses)>,
}

/// Best fills for a taker order
/// Returns (candidates, is_partial)
#[derive(Clone, Debug, Default)]
pub struct MakerCrosses {
    /// (maker order, fill_size)
    pub orders: ArrayVec<(L3Order, u64), 16>,
    /// Slot crosses were found
    pub slot: u64,
    // true if crosses VAMM quote
    pub has_vamm_cross: bool,
    pub is_partial: bool,
    pub taker_direction: Direction,
}

impl MakerCrosses {
    /// Returns True if there were no crosses found
    pub fn is_empty(&self) -> bool {
        self.orders.is_empty() && !self.has_vamm_cross
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DLOBEvent {
    /// dlob slot and/or oracle update
    SlotAndOracleUpdate {
        slot: u64,
        oracle_price: u64,
        market: MarketId,
    },
    /// user order deltas
    Deltas { deltas: Vec<OrderDelta>, slot: u64 },
}

/// Order with dynamic price calculation
pub(crate) trait DynamicPrice {
    fn get_price(&self, slot: u64, oracle_price: u64, tick_size: u64) -> Option<u64>;
    fn size(&self) -> u64;
}

// Subset of order fields for sorting
pub(crate) trait OrderKey {
    type Key: Ord + Clone + Debug;
    fn key(&self) -> Self::Key;
}

impl OrderKey for MarketOrder {
    type Key = MarketOrderKey;
    fn key(&self) -> Self::Key {
        (self.slot, self.id)
    }
}

impl MarketOrder {
    /// Check if this order has expired
    pub fn is_expired(&self, now_unix_seconds: u64) -> bool {
        self.max_ts != 0 && self.max_ts < now_unix_seconds
    }
    /// Check if this auction order has completed
    pub fn is_auction_complete(&self, current_slot: u64) -> bool {
        current_slot.saturating_sub(self.slot) > self.duration as u64
    }

    /// Convert to LimitOrder when auction completes
    pub fn to_limit_order(&self) -> LimitOrder {
        LimitOrder {
            id: self.id,
            size: self.size,
            price: self.price,
            slot: self.slot,
            max_ts: self.max_ts,
            post_only: false,
            reduce_only: self.reduce_only,
        }
    }
}

impl OrderKey for OracleOrder {
    type Key = OracleOrderKey;
    fn key(&self) -> Self::Key {
        (self.end_price_offset, self.id)
    }
}

impl OracleOrder {
    /// Check if this order has expired
    pub fn is_expired(&self, now_unix_seconds: u64) -> bool {
        self.max_ts != 0 && self.max_ts < now_unix_seconds
    }
    /// Check if this auction order has completed
    pub fn is_auction_complete(&self, current_slot: u64) -> bool {
        current_slot.saturating_sub(self.slot) > self.duration as u64
    }

    /// Convert to FloatingLimitOrder when auction completes
    pub fn to_floating_limit_order(&self) -> FloatingLimitOrder {
        FloatingLimitOrder {
            id: self.id,
            slot: self.slot,
            size: self.size,
            offset_price: self.oracle_price_offset,
            max_ts: self.max_ts,
            post_only: false,
            reduce_only: self.reduce_only,
        }
    }
}

impl OrderKey for LimitOrder {
    type Key = LimitOrderKey;
    fn key(&self) -> Self::Key {
        (self.price, self.slot, self.id)
    }
}

impl OrderKey for FloatingLimitOrder {
    type Key = FloatingLimitOrderKey;
    fn key(&self) -> Self::Key {
        (self.offset_price, self.slot, self.id)
    }
}

impl OrderKey for TriggerOrder {
    type Key = TriggerOrderKey;
    fn key(&self) -> Self::Key {
        // nb: trigger order slot updates when triggered so is unreliable as a sort key
        (self.price, self.id)
    }
}

#[derive(Default, Clone, PartialEq, Debug)]
pub(crate) struct MarketOrder {
    pub id: u64,
    pub size: u64,
    pub start_price: i64,
    pub end_price: i64,
    pub price: u64, // the limit price post auction
    pub duration: u8,
    pub slot: u64,
    pub max_ts: u64,
    pub is_limit: bool,
    pub direction: Direction,
    pub reduce_only: bool,
}

#[derive(Default, Clone, PartialEq, Debug)]
pub(crate) struct OracleOrder {
    pub id: u64,
    pub size: u64,
    pub start_price_offset: i64,
    pub end_price_offset: i64,
    pub oracle_price_offset: i32,
    pub max_ts: u64,
    pub slot: u64,
    pub duration: u8,
    pub is_limit: bool,
    pub direction: Direction,
    pub reduce_only: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct LimitOrderView {
    /// Internal order id
    pub id: u64,
    /// Price of the order
    pub price: u64,
    /// Size of the order
    pub size: u64,
    /// Slot of the order
    pub slot: u64,
    /// Whether the order is post-only
    pub post_only: bool,
}

#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub(crate) struct LimitOrder {
    pub id: u64,
    pub size: u64,
    pub price: u64,
    pub slot: u64,
    pub max_ts: u64,
    pub post_only: bool,
    pub reduce_only: bool,
}

#[derive(Default, Clone, PartialEq, Eq, Debug)]
pub(crate) struct FloatingLimitOrder {
    pub id: u64,
    pub size: u64,
    pub slot: u64,
    pub max_ts: u64,
    pub offset_price: i32,
    pub post_only: bool,
    pub reduce_only: bool,
}

#[allow(dead_code)]
#[derive(Default, Debug, Clone)]
pub(crate) struct TriggerOrder {
    pub id: u64,
    pub size: u64,
    /// static trigger price
    pub price: u64,
    pub slot: u64,
    pub max_ts: u64,
    pub condition: OrderTriggerCondition,
    pub direction: Direction,
    pub kind: OrderType,
    pub bit_flags: u8,
    pub reduce_only: bool,
}

impl TriggerOrder {
    /// Returns true if the order would trigger at the given `oracle_price`
    pub fn will_trigger_at(&self, oracle_price: u64) -> bool {
        oracle_price != 0
            && match self.condition {
                OrderTriggerCondition::Above => oracle_price > self.price,
                OrderTriggerCondition::Below => oracle_price < self.price,
                _ => true, // technically unreachable
            }
    }
    /// Returns order price if it were triggered at `slot` with the current market parameters, `oracle_price` and `perp_market`
    pub fn get_price(
        &self,
        slot: u64,
        oracle_price: u64,
        perp_market: Option<&PerpMarket>,
    ) -> SdkResult<u64> {
        // TODO: safe trigger order can fill against VAMM
        // if slot.saturating_sub(order.slot) > 150 && self.reduce_only {
        //     order.add_bit_flag(OrderBitFlag::SafeTriggerOrder);
        // }
        if let Some(market) = perp_market {
            let mut order = Order {
                slot, // slot is the current slot (i.e simulate trigger and place)
                direction: self.direction,
                order_type: self.kind,
                market_index: market.market_index,
                market_type: MarketType::Perp,
                base_asset_amount: self.size,
                status: OrderStatus::Open,
                trigger_condition: match self.condition {
                    OrderTriggerCondition::Above => OrderTriggerCondition::TriggeredAbove,
                    OrderTriggerCondition::Below => OrderTriggerCondition::TriggeredBelow,
                    _ => self.condition,
                },
                bit_flags: self.bit_flags,
                ..Default::default()
            };
            let (auction_duration, auction_start, auction_end) =
                crate::ffi::calculate_auction_params_for_trigger_order(
                    &order,
                    &OraclePriceData {
                        price: oracle_price as i64,
                        confidence: 0,
                        delay: 0,
                        has_sufficient_number_of_data_points: true,
                        sequence_id: None,
                    },
                    Some(market),
                )
                .unwrap();
            order.auction_duration = auction_duration;
            order.auction_start_price = auction_start;
            order.auction_end_price = auction_end;

            if matches!(order.order_type, OrderType::TriggerMarket) {
                order.bit_flags |= Order::ORACLE_TRIGGER_MARKET_FLAG;
            }

            return calculate_auction_price(
                &order,
                slot,
                market.amm.order_tick_size,
                Some(oracle_price as i64),
                false,
            );
        }

        todo!("implement spot market trigger price");
    }
}

impl DynamicPrice for MarketOrder {
    fn size(&self) -> u64 {
        self.size
    }
    /// Returns the price of the market order at `slot`
    ///
    /// A value of None indicates the order will use the fallback/vamm price
    fn get_price(&self, slot: u64, _oracle_price: u64, tick_size: u64) -> Option<u64> {
        let slots_elapsed = slot.saturating_sub(self.slot) as i64;
        let delta_denominator = self.duration as i64;
        let delta_numerator = slots_elapsed.min(delta_denominator);

        // limit price after auction end
        if slots_elapsed > self.duration as i64 {
            return if self.price > 0 {
                Some(self.price)
            } else {
                None
            };
        }

        if delta_denominator == 0 {
            return Some(self.end_price as u64);
        }

        let price = if self.direction == Direction::Long {
            let delta = (self.end_price.saturating_sub(self.start_price) * delta_numerator)
                / delta_denominator;
            self.start_price.saturating_add(delta)
        } else {
            let delta = (self.start_price.saturating_sub(self.end_price) * delta_numerator)
                / delta_denominator;
            self.start_price.saturating_sub(delta)
        };

        let price = price.max(tick_size as i64);
        Some(standardize_price(price as u64, tick_size, self.direction))
    }
}

impl From<(u64, Order)> for MarketOrder {
    fn from(value: (u64, Order)) -> Self {
        let (id, order) = value;
        Self {
            id,
            size: order.base_asset_amount - order.base_asset_amount_filled,
            start_price: order.auction_start_price,
            end_price: order.auction_end_price,
            price: order.price,
            duration: order.auction_duration,
            direction: order.direction,
            slot: order.slot,
            is_limit: matches!(order.order_type, OrderType::Limit | OrderType::TriggerLimit),
            max_ts: order.max_ts as u64,
            reduce_only: order.reduce_only,
        }
    }
}

impl DynamicPrice for OracleOrder {
    fn size(&self) -> u64 {
        self.size
    }
    /// Returns price of oracle auction at given `slot`
    ///
    /// A value of None indicates the order will use the fallback/vamm price
    fn get_price(&self, slot: u64, oracle_price: u64, tick_size: u64) -> Option<u64> {
        let slots_elapsed = slot.saturating_sub(self.slot) as i64;
        // limit price after auction end
        if slots_elapsed > self.duration as i64 {
            return if self.oracle_price_offset > 0 {
                Some((oracle_price as i64 + self.oracle_price_offset as i64) as u64)
            } else {
                None
            };
        }
        let delta_denominator = self.duration as i64;
        let delta_numerator = slots_elapsed.min(delta_denominator);

        if delta_denominator == 0 {
            let price = ((oracle_price as i64 + self.end_price_offset) as u64).max(tick_size);

            return Some(standardize_price(price, tick_size, self.direction));
        }

        let price_offset = if self.direction == Direction::Long {
            let delta = (self
                .end_price_offset
                .saturating_sub(self.start_price_offset)
                * delta_numerator)
                / delta_denominator;
            self.start_price_offset.saturating_add(delta)
        } else {
            let delta = (self
                .start_price_offset
                .saturating_sub(self.end_price_offset)
                * delta_numerator)
                / delta_denominator;
            self.start_price_offset.saturating_sub(delta)
        };

        let price = ((oracle_price as i64 + price_offset) as u64).max(tick_size);

        Some(standardize_price(price, tick_size, self.direction))
    }
}

impl From<(u64, Order)> for OracleOrder {
    fn from(value: (u64, Order)) -> Self {
        let (id, order) = value;
        Self {
            id,
            size: order.base_asset_amount - order.base_asset_amount_filled,
            start_price_offset: order.auction_start_price,
            end_price_offset: order.auction_end_price,
            oracle_price_offset: order.oracle_price_offset,
            duration: order.auction_duration,
            slot: order.slot,
            is_limit: order.order_type == OrderType::Limit,
            direction: order.direction,
            max_ts: order.max_ts as u64,
            reduce_only: order.reduce_only,
        }
    }
}

impl LimitOrder {
    pub fn get_price(&self) -> u64 {
        self.price
    }
    pub fn is_expired(&self, now_unix_seconds: u64) -> bool {
        self.max_ts != 0 && self.max_ts < now_unix_seconds
    }
}

impl From<(u64, Order)> for LimitOrder {
    fn from(value: (u64, Order)) -> Self {
        let (id, order) = value;
        Self {
            id,
            size: order.base_asset_amount - order.base_asset_amount_filled,
            price: order.price,
            slot: order.slot,
            max_ts: order.max_ts as u64,
            post_only: order.post_only,
            reduce_only: order.reduce_only,
        }
    }
}

impl FloatingLimitOrder {
    pub fn is_expired(&self, now_unix_seconds: u64) -> bool {
        self.max_ts != 0 && self.max_ts < now_unix_seconds
    }
    pub fn get_price(&self, oracle_price: u64, tick_size: u64) -> u64 {
        (oracle_price as i64 + self.offset_price as i64).max(tick_size as i64) as u64
    }
}

impl From<(u64, Order)> for FloatingLimitOrder {
    fn from(value: (u64, Order)) -> Self {
        let (id, order) = value;
        Self {
            id,
            size: order.base_asset_amount - order.base_asset_amount_filled,
            offset_price: order.oracle_price_offset,
            slot: order.slot,
            max_ts: order.max_ts as u64,
            post_only: order.post_only,
            reduce_only: order.reduce_only,
        }
    }
}

impl From<(u64, Order)> for TriggerOrder {
    fn from(value: (u64, Order)) -> Self {
        let (id, order) = value;
        Self {
            id,
            size: order.base_asset_amount,
            price: order.trigger_price,
            condition: order.trigger_condition,
            max_ts: order.max_ts.unsigned_abs(),
            slot: order.slot,
            direction: order.direction,
            kind: order.order_type,
            bit_flags: order.bit_flags,
            reduce_only: order.reduce_only,
        }
    }
}

/// Double-buffered snapshot of T
///
/// Provides lock-free reads/write API
pub struct Snapshot<T: Default + Clone> {
    a: AtomicPtr<T>,
    b: AtomicPtr<T>,
}

impl<T: Default + Clone> Default for Snapshot<T> {
    fn default() -> Self {
        Self::new(T::default(), T::default())
    }
}

impl<T: Default + Clone> Snapshot<T> {
    /// Create a new double buffer from two initial values.
    pub fn new(a: T, b: T) -> Self {
        let a = Arc::into_raw(Arc::new(a)) as *mut T;
        let b = Arc::into_raw(Arc::new(b)) as *mut T;
        Self {
            a: AtomicPtr::new(a),
            b: AtomicPtr::new(b),
        }
    }

    /// Read the snapshot
    #[inline]
    pub fn read(&self) -> Arc<T> {
        unsafe {
            let ptr = self.a.load(std::sync::atomic::Ordering::Acquire);
            Arc::increment_strong_count(ptr);
            Arc::from_raw(ptr)
        }
    }

    /// Write the snapshot
    #[inline]
    pub fn write<F>(&self, f: F)
    where
        F: FnOnce(&mut T),
    {
        let b_ptr = self.b.load(std::sync::atomic::Ordering::Relaxed);
        let b = unsafe { Arc::from_raw(b_ptr as *const T) };
        let mut b_mut = Arc::try_unwrap(b).unwrap_or_else(|arc| (*arc).clone());
        f(&mut b_mut);
        let new_b = Arc::into_raw(Arc::new(b_mut)) as *mut T;
        self.b.store(new_b, std::sync::atomic::Ordering::Relaxed);
        self.swap();
    }

    /// atomic swap of a/b pointers.
    #[inline]
    fn swap(&self) {
        let a_ptr = self.a.load(std::sync::atomic::Ordering::Acquire);
        let b_ptr = self.b.load(std::sync::atomic::Ordering::Acquire);
        self.a.store(b_ptr, std::sync::atomic::Ordering::Release);
        self.b.store(a_ptr, std::sync::atomic::Ordering::Release);
    }
}

impl<T: Default + Clone> Drop for Snapshot<T> {
    fn drop(&mut self) {
        unsafe {
            let a_ptr = self.a.load(std::sync::atomic::Ordering::Relaxed);
            let b_ptr = self.b.load(std::sync::atomic::Ordering::Relaxed);

            // Only drop non-null pointers to avoid double-free
            if !a_ptr.is_null() {
                drop(Arc::from_raw(a_ptr));
            }
            if !b_ptr.is_null() {
                drop(Arc::from_raw(b_ptr));
            }
        }
    }
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
pub struct CrossingRegion {
    pub slot: u64,
    pub crossing_bids: Vec<L3Order>,
    pub crossing_asks: Vec<L3Order>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct L3Order {
    /// point in time limit price of the order at some slot & oracle price
    pub price: u64,
    /// base asset amount of the order
    pub size: u64,
    /// order expiry ts
    pub max_ts: u64,
    /// program assigned order id
    pub order_id: u32,
    pub kind: OrderKind,
    /// user subaccount of the order
    pub user: Pubkey,
    /// internal order flags
    pub(crate) flags: u8,
}

impl L3Order {
    /// when set indicates order is reduce only
    pub(crate) const RO_FLAG: u8 = 0b0000_0001;
    /// When set indicates order direction is long
    pub(crate) const IS_LONG: u8 = 0b0000_0010;
    /// When set and order kind is trigger, this bit indicates 'trigger above'
    /// conversely, 'trigger below' when unset
    pub(crate) const IS_TRIGGER_ABOVE: u8 = 0b0000_0100;
    /// When set indicates limit order with post only flag set
    pub(crate) const IS_POST_ONLY: u8 = 0b0000_1000;
    /// True if this is a long order, false otherwise
    pub fn is_long(&self) -> bool {
        self.flags & Self::IS_LONG > 0
    }
    /// True if this is a reduce only order, false otherwise
    pub fn is_reduce_only(&self) -> bool {
        self.flags & Self::RO_FLAG > 0
    }
    /// True if this is a trigger order with 'trigger above' condition
    pub fn is_trigger_above(&self) -> bool {
        self.flags & Self::IS_TRIGGER_ABOVE > 0
    }
    /// True if this is a limit order with 'post only' set
    pub fn is_post_only(&self) -> bool {
        self.flags & Self::IS_POST_ONLY > 0
    }
    /// Calculate the 'limit' price of an _untriggered_ perp trigger order
    ///
    /// i.e. if order was triggered onchain immediately at the current `slot` and `oracle_price`
    pub fn post_trigger_price(
        &self,
        slot: u64,
        oracle_price: u64,
        perp_market: &PerpMarket,
    ) -> Option<u64> {
        if matches!(
            self.kind,
            OrderKind::TriggerMarket | OrderKind::TriggerLimit
        ) {
            let condition = if self.is_trigger_above() {
                OrderTriggerCondition::Above
            } else {
                OrderTriggerCondition::Below
            };
            let order = TriggerOrder {
                id: 0,
                size: self.size,
                reduce_only: self.is_reduce_only(),
                max_ts: self.max_ts,
                direction: if self.is_long() {
                    Direction::Long
                } else {
                    Direction::Short
                },
                condition,
                slot,
                ..Default::default()
            };
            order.get_price(slot, oracle_price, Some(perp_market)).ok()
        } else {
            None
        }
    }
    /// True if order is maker only
    pub fn is_maker(&self) -> bool {
        self.kind.is_maker()
    }
    /// True if order is taker only
    pub fn is_taker(&self) -> bool {
        self.kind.is_taker()
    }
}

```

## File: crates/src/dlob/util.rs
```
use std::hash::{Hash, Hasher};

use crate::types::{accounts::User, Order, OrderStatus};
use ahash::AHasher;
use solana_sdk::pubkey::Pubkey;

/// change of order signal dlob
#[derive(Debug, PartialEq, Clone)]
pub enum OrderDelta {
    Create {
        order: Order,
        user: Pubkey,
    },
    Update {
        new_order: Order,
        old_order: Order,
        user: Pubkey,
    },
    Remove {
        order: Order,
        user: Pubkey,
    },
}

/// Helper function to generate unique order Id hash for internal DLOB use
pub fn order_hash(user: &Pubkey, order_id: u32) -> u64 {
    let mut hasher = AHasher::default();
    user.hash(&mut hasher);
    order_id.hash(&mut hasher);
    hasher.finish()
}

pub fn compare_user_orders(pubkey: Pubkey, old: &User, new: &User) -> Vec<OrderDelta> {
    let mut deltas = Vec::<OrderDelta>::with_capacity(16);
    // relies on the layout of orders and transitions made by the program
    // 1) orders transition from to open to closed/filled,
    // 2) not open orders can be replaced with new orders
    // 3) orders that remain open were possibly updated
    // 4) use order_id to determine if we're looking at the same order or different orders
    for (old_order, new_order) in old.orders.iter().zip(new.orders.iter()) {
        // Check if we're looking at the same order (same order_id) or different orders
        if old_order.order_id == new_order.order_id {
            // Same order - check for updates or status changes
            match (old_order.status, new_order.status) {
                (OrderStatus::Open, OrderStatus::Open) => {
                    // Same order, both open - check if it was updated
                    if new_order != old_order {
                        deltas.push(OrderDelta::Update {
                            user: pubkey,
                            new_order: *new_order,
                            old_order: *old_order,
                        });
                    }
                }
                (OrderStatus::Open, _) => {
                    // Same order, was open now filled/cancelled - remove it
                    deltas.push(OrderDelta::Remove {
                        user: pubkey,
                        order: *old_order, // Use old_order since it was the one that was removed
                    });
                }
                (_, OrderStatus::Open) => {
                    // invalid transition e.g. out of order update
                }
                _ => {
                    // Same order, both not open - no change needed
                }
            }
        } else {
            // Different orders - this means one was replaced by another
            match (old_order.status, new_order.status) {
                (OrderStatus::Open, OrderStatus::Open) => {
                    // Old order was open, new order is open - remove old, create new
                    deltas.push(OrderDelta::Remove {
                        user: pubkey,
                        order: *old_order,
                    });
                    deltas.push(OrderDelta::Create {
                        user: pubkey,
                        order: *new_order,
                    });
                }
                (OrderStatus::Open, _) => {
                    // Old order was open, new order is not open - remove old
                    deltas.push(OrderDelta::Remove {
                        user: pubkey,
                        order: *old_order,
                    });
                }
                (_, OrderStatus::Open) => {
                    // Old order was not open, new order is open - create new
                    deltas.push(OrderDelta::Create {
                        user: pubkey,
                        order: *new_order,
                    });
                }
                _ => {
                    // Both orders not open - no change needed
                }
            }
        }
    }

    deltas
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{MarketType, OrderType, PositionDirection};

    fn create_test_order(id: u32, status: OrderStatus) -> Order {
        Order {
            slot: 0,
            price: 100,
            base_asset_amount: 1000,
            base_asset_amount_filled: 0,
            quote_asset_amount_filled: 0,
            order_id: id,
            market_index: 0,
            status,
            order_type: OrderType::Limit,
            market_type: MarketType::Perp,
            existing_position_direction: PositionDirection::Long,
            direction: PositionDirection::Long,
            reduce_only: false,
            post_only: false,
            immediate_or_cancel: false,
            trigger_condition: crate::types::OrderTriggerCondition::Above,
            ..Default::default()
        }
    }

    fn create_test_user(orders: Vec<Order>) -> User {
        let mut user = User::default();
        for (i, order) in orders.into_iter().enumerate() {
            if i < 32 {
                user.orders[i] = order;
            }
        }
        user
    }

    #[test]
    fn dlob_util_test_empty_orders() {
        let pubkey = Pubkey::new_unique();
        let old = create_test_user(vec![]);
        let new = create_test_user(vec![]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert!(deltas.is_empty());
    }

    #[test]
    fn dlob_util_test_create_order() {
        let pubkey = Pubkey::new_unique();
        let old = create_test_user(vec![]);
        let new = create_test_user(vec![create_test_order(1, OrderStatus::Open)]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert_eq!(deltas.len(), 1);

        match &deltas[0] {
            OrderDelta::Create { user, order } => {
                assert_eq!(*user, pubkey);
                assert_eq!(order.order_id, 1);
            }
            _ => panic!("Expected Create delta"),
        }
    }

    #[test]
    fn dlob_util_test_remove_order() {
        let pubkey = Pubkey::new_unique();
        let old = create_test_user(vec![create_test_order(1, OrderStatus::Open)]);
        let new = create_test_user(vec![]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert_eq!(deltas.len(), 1);

        match &deltas[0] {
            OrderDelta::Remove { user, order } => {
                assert_eq!(*user, pubkey);
                assert_eq!(order.order_id, 1);
            }
            _ => panic!("Expected Remove delta"),
        }
    }

    #[test]
    fn dlob_util_test_remove_order_via_cancel() {
        let pubkey = Pubkey::new_unique();
        let mut order = create_test_order(1, OrderStatus::Open);
        let old = create_test_user(vec![order.clone()]);
        order.status = OrderStatus::Canceled;
        let new = create_test_user(vec![order]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert_eq!(deltas.len(), 1);

        match &deltas[0] {
            OrderDelta::Remove { user, order } => {
                assert_eq!(*user, pubkey);
                assert_eq!(order.order_id, 1);
            }
            _ => panic!("Expected Remove delta"),
        }
    }

    #[test]
    fn dlob_util_test_update_order() {
        let pubkey = Pubkey::new_unique();
        let old_order = create_test_order(1, OrderStatus::Open);
        let mut new_order = create_test_order(1, OrderStatus::Open);
        new_order.price = 200; // Change the price

        let old = create_test_user(vec![old_order]);
        let new = create_test_user(vec![new_order]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert_eq!(deltas.len(), 1);

        match &deltas[0] {
            OrderDelta::Update {
                user,
                new_order,
                old_order,
            } => {
                assert_eq!(*user, pubkey);
                assert_eq!(new_order.order_id, 1);
                assert_eq!(new_order.price, 200);
                assert_eq!(old_order.order_id, 1);
                assert_eq!(old_order.price, 100);
            }
            _ => panic!("Expected Update delta"),
        }
    }

    #[test]
    fn dlob_util_test_multiple_operations() {
        let pubkey = Pubkey::new_unique();
        let old = create_test_user(vec![
            create_test_order(1, OrderStatus::Open),
            create_test_order(2, OrderStatus::Open),
        ]);

        let mut new_order = create_test_order(1, OrderStatus::Open);
        new_order.price = 200;

        let new = create_test_user(vec![new_order, create_test_order(3, OrderStatus::Open)]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert_eq!(deltas.len(), 3);
    }

    // Helper function to assert order replacement deltas
    fn assert_order_replacement_deltas(
        deltas: &[OrderDelta],
        expected_remove_id: u32,
        expected_create_id: u32,
    ) {
        assert_eq!(deltas.len(), 2);

        let mut has_remove = false;
        let mut has_create = false;

        for delta in deltas {
            match delta {
                OrderDelta::Remove { order, .. } => {
                    assert_eq!(order.order_id, expected_remove_id);
                    has_remove = true;
                }
                OrderDelta::Create { order, .. } => {
                    assert_eq!(order.order_id, expected_create_id);
                    has_create = true;
                }
                _ => panic!("Unexpected delta type: {:?}", delta),
            }
        }

        assert!(
            has_remove,
            "Should have Remove delta for order {}",
            expected_remove_id
        );
        assert!(
            has_create,
            "Should have Create delta for order {}",
            expected_create_id
        );
    }

    #[test]
    fn dlob_util_test_order_replacement() {
        let pubkey = Pubkey::new_unique();

        // Test basic order replacement: Order 1 (Open) → Order 2 (Open) at same index
        let old = create_test_user(vec![create_test_order(1, OrderStatus::Open)]);
        let new = create_test_user(vec![create_test_order(2, OrderStatus::Open)]);

        let deltas = compare_user_orders(pubkey, &old, &new);
        assert_order_replacement_deltas(&deltas, 1, 2);
    }

    #[test]
    fn dlob_util_test_multiple_order_replacements() {
        let pubkey = Pubkey::new_unique();

        // Test multiple simultaneous replacements
        let old = create_test_user(vec![
            create_test_order(1, OrderStatus::Open),
            create_test_order(2, OrderStatus::Open),
            create_test_order(3, OrderStatus::Open),
        ]);

        let new = create_test_user(vec![
            create_test_order(4, OrderStatus::Open), // replaced order 1
            create_test_order(2, OrderStatus::Open), // unchanged
            create_test_order(5, OrderStatus::Open), // replaced order 3
        ]);

        let deltas = compare_user_orders(pubkey, &old, &new);

        // Should have 2 Remove and 2 Create deltas
        assert_eq!(deltas.len(), 4);

        let mut remove_count = 0;
        let mut create_count = 0;

        for delta in &deltas {
            match delta {
                OrderDelta::Remove { order, .. } => {
                    assert!(order.order_id == 1 || order.order_id == 3);
                    remove_count += 1;
                }
                OrderDelta::Create { order, .. } => {
                    assert!(order.order_id == 4 || order.order_id == 5);
                    create_count += 1;
                }
                _ => panic!("Unexpected delta type: {:?}", delta),
            }
        }

        assert_eq!(remove_count, 2, "Should have 2 Remove deltas");
        assert_eq!(create_count, 2, "Should have 2 Create deltas");
    }

    #[test]
    fn dlob_util_test_atomic_create_and_fill() {
        let pubkey = Pubkey::new_unique();

        // Test case: Order doesn't exist in old (default/empty order), but exists in new
        // as a filled order (created and filled atomically). Should NOT emit Create+Remove.
        let old = create_test_user(vec![]); // Empty user, all slots have default Order (order_id=0, status=Init)
        let new = create_test_user(vec![create_test_order(1, OrderStatus::Filled)]); // Order created and filled atomically

        let deltas = compare_user_orders(pubkey, &old, &new);

        // Should emit NO deltas - the order was created and filled atomically, so it never
        // existed in an open state that we need to track
        assert_eq!(
            deltas.len(),
            0,
            "Should not emit deltas for atomically created and filled orders"
        );
    }

    #[test]
    fn dlob_util_test_atomic_create_and_cancel() {
        let pubkey = Pubkey::new_unique();

        // Similar test but with Canceled status
        let old = create_test_user(vec![]);
        let new = create_test_user(vec![create_test_order(1, OrderStatus::Canceled)]);

        let deltas = compare_user_orders(pubkey, &old, &new);

        assert_eq!(
            deltas.len(),
            0,
            "Should not emit deltas for atomically created and canceled orders"
        );
    }

    #[test]
    fn dlob_util_test_atomic_create_and_fill_with_existing_orders() {
        let pubkey = Pubkey::new_unique();

        // Test with other orders present to ensure the logic works in context
        let old = create_test_user(vec![
            create_test_order(1, OrderStatus::Open),
            // Slot 1 is empty (default order)
        ]);

        let new = create_test_user(vec![
            create_test_order(1, OrderStatus::Open),   // Unchanged
            create_test_order(2, OrderStatus::Filled), // Created and filled atomically at slot 1
        ]);

        let deltas = compare_user_orders(pubkey, &old, &new);

        // Should only have 0 deltas - order 1 is unchanged, order 2 was created and filled atomically
        assert_eq!(
            deltas.len(),
            0,
            "Should not emit deltas for atomically created and filled orders"
        );
    }

    #[test]
    fn dlob_util_test_filled_order_replacement() {
        let pubkey = Pubkey::new_unique();

        // Test case: Old order is filled (not open), new order is also filled (different order_id)
        // This simulates: old filled order gets replaced by a new order that was created and filled atomically
        // Should NOT emit Remove+Create since neither order was ever open in the DLOB
        let old = create_test_user(vec![create_test_order(1, OrderStatus::Filled)]);
        let new = create_test_user(vec![create_test_order(2, OrderStatus::Filled)]);

        let deltas = compare_user_orders(pubkey, &old, &new);

        // Should emit NO deltas - both orders are filled, so neither was ever open in the DLOB
        assert_eq!(
            deltas.len(),
            0,
            "Should not emit Remove+Create for replacement of filled orders"
        );
    }

    #[test]
    fn dlob_util_test_canceled_order_replacement() {
        let pubkey = Pubkey::new_unique();

        // Similar test but with Canceled status
        let old = create_test_user(vec![create_test_order(1, OrderStatus::Canceled)]);
        let new = create_test_user(vec![create_test_order(2, OrderStatus::Filled)]);

        let deltas = compare_user_orders(pubkey, &old, &new);

        assert_eq!(
            deltas.len(),
            0,
            "Should not emit Remove+Create for replacement of canceled order with filled order"
        );
    }
}

```

## File: crates/src/drift_idl.rs
[Truncated - showing first 1000 chars of 1033KB file]
```
#![allow(unused_imports)]
#![doc = r""]
#![doc = r" Auto-generated IDL types, manual edits do not persist (see `crates/drift-idl-gen`)"]
#![doc = r""]
use anchor_lang::{
    prelude::{
        account,
        borsh::{self},
        error_code, event, msg, AnchorDeserialize, AnchorSerialize, InitSpace,
    },
    Discriminator,
};
use serde::{Deserialize, Serialize};
use solana_sdk::{instruction::AccountMeta, pubkey::Pubkey};
pub const IDL_VERSION: &str = "2.146.0";
use self::traits::ToAccountMetas;
pub mod traits {
    use solana_sdk::instruction::AccountMeta;
    #[doc = r" This is distinct from the anchor_lang version of the trait"]
    #[doc = r" reimplemented to ensure the types used are from `solana`` crates _not_ the anchor_lang vendored versions which may be lagging behind"]
    pub trait ToAccountMetas {
        fn to_account_metas(&self) -> Vec<AccountMeta>;
    }
}
pub mod instructions {
    #![doc = r" IDL instruction types"]
    use super::{types::*, *};
    #[derive(Ancho
```

## File: crates/src/event_subscriber.rs
```
use std::{
    collections::VecDeque,
    str::FromStr,
    sync::{Arc, OnceLock},
    task::{Context, Poll},
    time::Duration,
};

use ahash::HashSet;
use anchor_lang::{AnchorDeserialize, Discriminator};
use base64::Engine;
pub use drift_pubsub_client::PubsubClient;
use futures_util::{future::BoxFuture, stream::FuturesOrdered, FutureExt, Stream, StreamExt};
use log::{debug, info, warn};
use regex::Regex;
pub use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_rpc_client::rpc_client::GetConfirmedSignaturesForAddress2Config;
use solana_rpc_client_api::{
    config::{RpcTransactionConfig, RpcTransactionLogsConfig, RpcTransactionLogsFilter},
    response::RpcLogsResponse,
};
pub use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::{pubkey::Pubkey, signature::Signature, transaction::VersionedTransaction};
use solana_transaction_status::{
    option_serializer::OptionSerializer, EncodedTransactionWithStatusMeta, UiTransactionEncoding,
};
use tokio::{
    sync::{
        mpsc::{channel, Receiver, Sender},
        RwLock,
    },
    task::JoinHandle,
};

use crate::{
    constants::{self, PROGRAM_ID},
    drift_idl::{
        events::{FundingPaymentRecord, OrderActionRecord, OrderRecord},
        types::{MarketType, Order, OrderAction, OrderActionExplanation, PositionDirection},
    },
    grpc::{
        grpc_subscriber::{DriftGrpcClient, GeyserSubscribeOpts, GrpcConnectionOpts},
        TransactionUpdate,
    },
    types::{events::SwapRecord, SdkResult},
};

const LOG_TARGET: &str = "events";
const EMPTY_SIGNATURE: &str = "1111111111111111111111111111111111111111111111111111111111111111";

impl EventRpcProvider for RpcClient {
    fn get_tx(
        &self,
        signature: Signature,
    ) -> BoxFuture<'_, SdkResult<EncodedTransactionWithStatusMeta>> {
        async move {
            let result = self
                .get_transaction_with_config(
                    &signature,
                    RpcTransactionConfig {
                        encoding: Some(UiTransactionEncoding::Base64),
                        max_supported_transaction_version: Some(0),
                        ..Default::default()
                    },
                )
                .await?;

            Ok(result.transaction)
        }
        .boxed()
    }
    fn get_tx_signatures(
        &self,
        account: Pubkey,
        after: Option<Signature>,
        limit: Option<usize>,
    ) -> BoxFuture<'_, SdkResult<Vec<String>>> {
        async move {
            let results = self
                .get_signatures_for_address_with_config(
                    &account,
                    GetConfirmedSignaturesForAddress2Config {
                        until: after,
                        limit,
                        ..Default::default()
                    },
                )
                .await?;

            Ok(results.iter().map(|r| r.signature.clone()).collect())
        }
        .boxed()
    }
}

/// RPC functions required for drift event subscriptions
pub trait EventRpcProvider: Send + Sync + 'static {
    /// Fetch tx signatures of account
    /// `after` only return txs more recent than this signature, if given
    /// `limit` return at most this many signatures, if given
    fn get_tx_signatures(
        &self,
        account: Pubkey,
        after: Option<Signature>,
        limit: Option<usize>,
    ) -> BoxFuture<'_, SdkResult<Vec<String>>>;
    /// Fetch tx with `signature`
    fn get_tx(
        &self,
        signature: Signature,
    ) -> BoxFuture<'_, SdkResult<EncodedTransactionWithStatusMeta>>;
}

/// Provides sub-account event streaming
pub struct EventSubscriber;

impl EventSubscriber {
    /// Subscribe to drift events of `sub_account`, backed by Ws APIs
    ///
    /// * `sub_account` - pubkey of the user's sub-account to subscribe to (use Drift Program ID to get all program events)
    ///
    /// passing the driftV2 address `dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH`
    /// will yield events from all sub-accounts.
    ///
    /// Returns a stream of events
    pub async fn subscribe(
        ws: Arc<PubsubClient>,
        sub_account: Pubkey,
    ) -> SdkResult<DriftEventStream> {
        log_stream(ws, sub_account).await
    }
    /// Subscribe to drift events of `sub_account`, backed by RPC polling APIs
    pub fn subscribe_polled(provider: impl EventRpcProvider, account: Pubkey) -> DriftEventStream {
        polled_stream(provider, account)
    }

    pub async fn subscribe_grpc(
        endpoint: String,
        x_token: String,
        sub_account: Pubkey,
    ) -> SdkResult<DriftEventStream> {
        grpc_log_stream(endpoint, x_token, sub_account).await
    }
}

struct LogEventStream {
    cache: Arc<RwLock<TxSignatureCache>>,
    provider: Arc<PubsubClient>,
    sub_account: Pubkey,
    event_tx: Sender<DriftEvent>,
    commitment: CommitmentConfig,
}

impl LogEventStream {
    /// Returns a future for running the configured log event stream
    async fn stream_fn(self) {
        let sub_account = self.sub_account;
        info!(target: LOG_TARGET, "log stream connecting: {sub_account:?}");

        let subscribe_result = self
            .provider
            .logs_subscribe(
                RpcTransactionLogsFilter::Mentions(vec![self.sub_account.to_string()]),
                RpcTransactionLogsConfig {
                    commitment: Some(self.commitment),
                },
            )
            .await;

        if let Err(ref err) = subscribe_result {
            warn!(
                target: LOG_TARGET,
                "log subscription failed for: {sub_account:?}. {err:?}"
            );
            return;
        }

        let (mut log_stream, _unsub_fn) = subscribe_result.unwrap();
        debug!(
            target: LOG_TARGET,
            "start log subscription: {sub_account:?}"
        );

        while let Some(response) = log_stream.next().await {
            self.process_log(response.context.slot, response.value)
                .await;
        }
        warn!(target: LOG_TARGET, "log stream ended: {sub_account:?}");
    }

    /// Process a log response from RPC, emitting any relevant events
    async fn process_log(&self, slot: u64, response: RpcLogsResponse) {
        let signature = response.signature;
        if response.err.is_some() {
            debug!(target: LOG_TARGET, "skipping failed tx: {signature:?}");
            return;
        }
        if signature == EMPTY_SIGNATURE {
            debug!(target: LOG_TARGET, "skipping empty signature, logs");
            return;
        }
        {
            let mut cache = self.cache.write().await;
            if cache.contains(&signature) {
                debug!(target: LOG_TARGET, "skipping cached tx: {signature:?}");
                return;
            }
            cache.insert(signature.clone());
        }

        debug!(
            target: LOG_TARGET,
            "log extracting events, slot: {slot}, tx: {signature:?}"
        );
        for (tx_idx, log) in response.logs.iter().enumerate() {
            // a drift sub-account should not interact with any other program by definition
            if let Some(event) = try_parse_log(log.as_str(), &signature, tx_idx) {
                // unrelated events from same tx should not be emitted e.g. a filler tx which produces other fill events
                if event.pertains_to(self.sub_account) {
                    if self.event_tx.send(event).await.is_err() {
                        warn!("event receiver closed");
                        return;
                    }
                }
            }
        }
    }
}

struct GrpcLogEventStream {
    grpc_endpoint: String,
    grpc_x_token: String,
    sub_account: Pubkey,
    event_tx: Sender<DriftEvent>,
    commitment: CommitmentConfig,
}

impl GrpcLogEventStream {
    /// Returns a future for running the configured log event stream
    async fn stream_fn(self) {
        let sub_account = self.sub_account;
        info!(
            target: LOG_TARGET,
            "grpc log stream connecting: {sub_account:?}"
        );

        let mut grpc = DriftGrpcClient::new(self.grpc_endpoint.clone(), self.grpc_x_token.clone())
            .grpc_connection_opts(GrpcConnectionOpts::default());

        let (raw_event_tx, mut raw_event_rx): (
            Sender<TransactionUpdate>,
            Receiver<TransactionUpdate>,
        ) = channel(256);

        let raw_event_tx_clone = raw_event_tx.clone();
        grpc.on_transaction(Box::new(move |tx_update: &TransactionUpdate| {
            raw_event_tx_clone.try_send(tx_update.clone()).unwrap();
        }));

        // prevent dropping unsub_fn and unsubscribing from grpc
        let _unsub_fn = grpc
            .subscribe(
                self.commitment.commitment,
                GeyserSubscribeOpts {
                    transactions_accounts_include: vec![sub_account.to_string()],
                    ..Default::default()
                },
            )
            .await
            .unwrap();
        info!(
            target: LOG_TARGET,
            "grpc log stream connected: {sub_account:?}"
        );

        while let Some(event) = raw_event_rx.recv().await {
            let start = std::time::Instant::now();
            let slot = event.slot;
            self.process_log(&event).await;
            let elapsed = start.elapsed();
            debug!(target: "grpc", "transaction slot: {}, len: {} callbacks took {:?}", slot, raw_event_rx.len(), elapsed);
        }
        info!(target: LOG_TARGET, "grpc log stream ended: {sub_account:?}");
    }

    /// Process a log response from RPC, emitting any relevant events
    async fn process_log(&self, event: &TransactionUpdate) {
        let signature = event.transaction.signatures.first();
        if signature.is_none() {
            debug!(target: LOG_TARGET, "skipping tx with no signatures");
            return;
        }
        let signature =
            Signature::from(<[u8; 64]>::try_from(signature.unwrap().as_slice()).unwrap());

        debug!(
            target: LOG_TARGET,
            "log extracting events, slot: {}, tx: {}", event.slot, signature
        );
        let logs = &event.meta.log_messages;
        for (tx_idx, log) in logs.iter().enumerate() {
            if let Some(event) = try_parse_log(log.as_str(), &signature.to_string(), tx_idx) {
                // unrelated events from same tx should not be emitted e.g. a filler tx which produces other fill events
                if event.pertains_to(self.sub_account) {
                    if self.event_tx.send(event).await.is_err() {
                        warn!("event receiver closed");
                        return;
                    }
                }
            }
        }
    }
}

/// Creates a poll-ed stream using JSON-RPC interfaces
fn polled_stream(provider: impl EventRpcProvider, sub_account: Pubkey) -> DriftEventStream {
    let (event_tx, event_rx) = channel(256);
    let cache = Arc::new(RwLock::new(TxSignatureCache::new(128)));
    let join_handle = tokio::spawn(
        PolledEventStream {
            cache: Arc::clone(&cache),
            provider,
            sub_account,
            event_tx,
        }
        .stream_fn(),
    );

    DriftEventStream {
        rx: event_rx,
        task: join_handle,
    }
}

/// Creates a Ws-backed event stream using `logsSubscribe` interface
async fn log_stream(ws: Arc<PubsubClient>, sub_account: Pubkey) -> SdkResult<DriftEventStream> {
    debug!(target: LOG_TARGET, "stream events for {sub_account:?}");
    let (event_tx, event_rx) = channel(256);
    let cache = Arc::new(RwLock::new(TxSignatureCache::new(256)));

    // spawn the event subscription task
    let join_handle = tokio::spawn(async move {
        LogEventStream {
            provider: ws,
            cache: Arc::clone(&cache),
            sub_account,
            event_tx: event_tx.clone(),
            commitment: CommitmentConfig::confirmed(),
        }
        .stream_fn()
        .await;
    });

    Ok(DriftEventStream {
        rx: event_rx,
        task: join_handle,
    })
}

/// Creates a grpc-backed event stream
async fn grpc_log_stream(
    endpoint: String,
    x_token: String,
    sub_account: Pubkey,
) -> SdkResult<DriftEventStream> {
    debug!(target: LOG_TARGET, "grpc stream events for {sub_account:?}");
    let (event_tx, event_rx) = channel(256);

    // spawn the event subscription task
    let join_handle = tokio::spawn(async move {
        GrpcLogEventStream {
            grpc_endpoint: endpoint.clone(),
            grpc_x_token: x_token.clone(),
            sub_account,
            event_tx: event_tx.clone(),
            commitment: CommitmentConfig::confirmed(),
        }
        .stream_fn()
        .await;
    });

    Ok(DriftEventStream {
        rx: event_rx,
        task: join_handle,
    })
}

pub struct PolledEventStream<T: EventRpcProvider> {
    cache: Arc<RwLock<TxSignatureCache>>,
    event_tx: Sender<DriftEvent>,
    provider: T,
    sub_account: Pubkey,
}

impl<T: EventRpcProvider> PolledEventStream<T> {
    async fn stream_fn(self) {
        debug!(target: LOG_TARGET, "poll events for {:?}", self.sub_account);
        // poll for events in any tx after this tx
        // initially fetch the most recent tx from account
        debug!(target: LOG_TARGET, "fetch initial txs");
        let res = self
            .provider
            .get_tx_signatures(self.sub_account, None, Some(1))
            .await;
        debug!(target: LOG_TARGET, "fetched initial txs");

        let mut last_seen_tx = res.expect("fetched tx").first().cloned();
        let provider_ref = &self.provider;
        'outer: loop {
            // don't needlessly spam the RPC or hog the executor
            tokio::time::sleep(Duration::from_millis(400)).await;

            debug!(target: LOG_TARGET, "poll txs for events");
            let signatures = provider_ref
                .get_tx_signatures(
                    self.sub_account,
                    last_seen_tx
                        .clone()
                        .map(|s| Signature::from_str(s.as_str()).unwrap()),
                    None,
                )
                .await;

            if let Err(err) = signatures {
                warn!(target: LOG_TARGET, "poll tx signatures: {err:?}");
                continue;
            }

            let signatures = signatures.unwrap();
            // txs from RPC are ordered newest to oldest
            // process in reverse order, so subscribers receive events in chronological order
            let mut futs = {
                FuturesOrdered::from_iter(
                    signatures
                        .into_iter()
                        .map(|s| async move {
                            (
                                s.clone(),
                                provider_ref
                                    .get_tx(
                                        Signature::from_str(s.as_str()).expect("valid signature"),
                                    )
                                    .await,
                            )
                        })
                        .rev(),
                )
            };
            if futs.is_empty() {
                continue;
            }

            while let Some((signature, response)) = futs.next().await {
                debug!(
                    target: LOG_TARGET,
                    "poll extracting events, tx: {signature:?}"
                );
                if let Err(err) = response {
                    warn!(target: LOG_TARGET, "poll processing tx: {err:?}");
                    // retry querying the batch
                    continue 'outer;
                }

                last_seen_tx = Some(signature.clone());
                {
                    let mut cache = self.cache.write().await;
                    if cache.contains(&signature) {
                        debug!(target: LOG_TARGET, "poll skipping cached tx: {signature:?}");
                        continue;
                    }
                    cache.insert(signature.clone());
                }

                let EncodedTransactionWithStatusMeta {
                    meta, transaction, ..
                } = response.unwrap();
                if meta.is_none() {
                    continue;
                }
                let meta = meta.unwrap();

                if let Some(VersionedTransaction { message, .. }) = transaction.decode() {
                    // only txs interacting with drift program
                    if !message
                        .static_account_keys()
                        .iter()
                        .any(|k| k == &constants::PROGRAM_ID)
                    {
                        continue;
                    }
                }
                // ignore failed txs
                if meta.err.is_some() {
                    continue;
                }

                if let OptionSerializer::Some(logs) = meta.log_messages {
                    for (tx_idx, log) in logs.iter().enumerate() {
                        if let Some(event) = try_parse_log(log.as_str(), signature.as_str(), tx_idx)
                        {
                            if event.pertains_to(self.sub_account) {
                                self.event_tx.try_send(event).expect("sent");
                            }
                        }
                    }
                }
            }
        }
    }
}

/// Provides a stream API of drift sub-account events
pub struct DriftEventStream {
    /// handle to end the stream task
    task: JoinHandle<()>,
    /// channel of events from stream task
    rx: Receiver<DriftEvent>,
}

impl DriftEventStream {
    /// End the event stream
    pub fn unsubscribe(&self) {
        self.task.abort();
    }
}

impl Drop for DriftEventStream {
    fn drop(&mut self) {
        self.unsubscribe()
    }
}

impl Stream for DriftEventStream {
    type Item = DriftEvent;
    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>> {
        self.as_mut().rx.poll_recv(cx)
    }
}

const PROGRAM_LOG: &str = "Program log: ";
const PROGRAM_DATA: &str = "Program data: ";

/// Try deserialize a drift event type from raw log string
/// https://github.com/coral-xyz/anchor/blob/9d947cb26b693e85e1fd26072bb046ff8f95bdcf/client/src/lib.rs#L552
pub fn try_parse_log(raw: &str, signature: &str, tx_idx: usize) -> Option<DriftEvent> {
    // Log emitted from the current program.
    if let Some(log) = raw
        .strip_prefix(PROGRAM_LOG)
        .or_else(|| raw.strip_prefix(PROGRAM_DATA))
    {
        if let Ok(borsh_bytes) = base64::engine::general_purpose::STANDARD.decode(log) {
            let (disc, mut data) = borsh_bytes.split_at(8);
            let disc: [u8; 8] = disc.try_into().unwrap();

            return DriftEvent::from_discriminant(disc, &mut data, signature, tx_idx);
        }

        // experimental
        let order_cancel_missing_re = ORDER_CANCEL_MISSING_RE
            .get_or_init(|| Regex::new(r"could not find( user){0,1} order id (\d+)").unwrap());
        if let Some(captures) = order_cancel_missing_re.captures(log) {
            let order_id = captures
                .get(2)
                .unwrap()
                .as_str()
                .parse::<u32>()
                .expect("<u32");
            let event = if captures.get(1).is_some() {
                // cancel by user order Id
                DriftEvent::OrderCancelMissing {
                    user_order_id: order_id as u8,
                    order_id: 0,
                    signature: signature.to_string(),
                }
            } else {
                // cancel by order id
                DriftEvent::OrderCancelMissing {
                    user_order_id: 0,
                    order_id,
                    signature: signature.to_string(),
                }
            };

            return Some(event);
        }
    }

    None
}

static ORDER_CANCEL_MISSING_RE: OnceLock<Regex> = OnceLock::new();

/// Enum of all drift program events
#[derive(Debug, PartialEq)]
pub enum DriftEvent {
    OrderFill {
        maker: Option<Pubkey>,
        maker_fee: i64,
        maker_order_id: u32,
        maker_side: Option<PositionDirection>,
        taker: Option<Pubkey>,
        taker_fee: u64,
        taker_order_id: u32,
        taker_side: Option<PositionDirection>,
        base_asset_amount_filled: u64,
        quote_asset_amount_filled: u64,
        market_index: u16,
        market_type: MarketType,
        oracle_price: i64,
        signature: String,
        tx_idx: usize,
        ts: u64,
        bit_flags: u8,
    },
    OrderCancel {
        taker: Option<Pubkey>,
        maker: Option<Pubkey>,
        taker_order_id: u32,
        maker_order_id: u32,
        signature: String,
        tx_idx: usize,
        ts: u64,
    },
    /// An order cancel for a missing order Id / user order id
    OrderCancelMissing {
        user_order_id: u8,
        order_id: u32,
        signature: String,
    },
    OrderCreate {
        order: Order,
        user: Pubkey,
        ts: u64,
        signature: String,
        tx_idx: usize,
    },
    // sub-case of cancel?
    OrderExpire {
        order_id: u32,
        user: Option<Pubkey>,
        fee: u64,
        ts: u64,
        signature: String,
        tx_idx: usize,
    },
    FundingPayment {
        amount: i64,
        market_index: u16,
        user: Pubkey,
        ts: u64,
        signature: String,
        tx_idx: usize,
    },
    Swap {
        user: Pubkey,
        amount_in: u64,
        amount_out: u64,
        market_in: u16,
        market_out: u16,
        fee: u64,
        ts: u64,
        signature: String,
        tx_idx: usize,
    },
    OrderTrigger {
        /// trigger order owner
        user: Pubkey,
        order_id: u32,
        oracle_price: u64,
        /// base asset amount
        amount: u64,
    },
}

impl DriftEvent {
    /// Return true if the event is connected to sub-account
    fn pertains_to(&self, sub_account: Pubkey) -> bool {
        if sub_account == PROGRAM_ID {
            return true;
        }
        let subject = &Some(sub_account);
        match self {
            Self::OrderCancel { maker, taker, .. } | Self::OrderFill { maker, taker, .. } => {
                maker == subject || taker == subject
            }
            Self::OrderCreate { user, .. } => *user == sub_account,
            Self::OrderExpire { user, .. } => user == subject,
            Self::OrderCancelMissing { .. } => true,
            Self::FundingPayment { user, .. } => *user == sub_account,
            Self::Swap { user, .. } => *user == sub_account,
            Self::OrderTrigger { user, .. } => *user == sub_account,
        }
    }
    /// Deserialize drift event by discriminant
    fn from_discriminant(
        disc: [u8; 8],
        data: &mut &[u8],
        signature: &str,
        tx_idx: usize,
    ) -> Option<Self> {
        match disc.as_slice() {
            // deser should only fail on a breaking protocol changes
            OrderActionRecord::DISCRIMINATOR => Self::from_oar(
                OrderActionRecord::deserialize(data).expect("deserializes"),
                signature,
                tx_idx,
            ),
            OrderRecord::DISCRIMINATOR => Self::from_order_record(
                OrderRecord::deserialize(data).expect("deserializes"),
                signature,
                tx_idx,
            ),
            FundingPaymentRecord::DISCRIMINATOR => Some(Self::from_funding_payment_record(
                FundingPaymentRecord::deserialize(data).expect("deserializes"),
                signature,
                tx_idx,
            )),
            SwapRecord::DISCRIMINATOR => Some(Self::from_swap_record(
                SwapRecord::deserialize(data).expect("deserializes"),
                signature,
                tx_idx,
            )),
            _ => {
                debug!(target: LOG_TARGET, "unhandled event: {disc:?}");
                None
            }
        }
    }
    fn from_swap_record(value: SwapRecord, signature: &str, tx_idx: usize) -> Self {
        Self::Swap {
            amount_in: value.amount_in,
            amount_out: value.amount_out,
            market_in: value.in_market_index,
            market_out: value.out_market_index,
            fee: value.fee,
            ts: value.ts.unsigned_abs(),
            user: value.user,
            signature: signature.to_string(),
            tx_idx,
        }
    }
    fn from_funding_payment_record(
        value: FundingPaymentRecord,
        signature: &str,
        tx_idx: usize,
    ) -> Self {
        Self::FundingPayment {
            amount: value.funding_payment,
            market_index: value.market_index,
            ts: value.ts.unsigned_abs(),
            user: value.user,
            signature: signature.to_string(),
            tx_idx,
        }
    }
    fn from_order_record(value: OrderRecord, signature: &str, tx_idx: usize) -> Option<Self> {
        Some(DriftEvent::OrderCreate {
            order: value.order,
            user: value.user,
            ts: value.ts.unsigned_abs(),
            signature: signature.to_string(),
            tx_idx,
        })
    }
    fn from_oar(value: OrderActionRecord, signature: &str, tx_idx: usize) -> Option<Self> {
        match value.action {
            OrderAction::Cancel => {
                if let OrderActionExplanation::OrderExpired = value.action_explanation {
                    // TODO: would be nice to report the `user_order_id` too...
                    Some(DriftEvent::OrderExpire {
                        fee: value.filler_reward.unwrap_or_default(),
                        order_id: value
                            .maker_order_id
                            .or(value.taker_order_id)
                            .expect("order id set"),
                        ts: value.ts.unsigned_abs(),
                        signature: signature.to_string(),
                        tx_idx,
                        user: value.maker.or(value.taker),
                    })
                } else {
                    Some(DriftEvent::OrderCancel {
                        maker: value.maker,
                        taker: value.taker,
                        maker_order_id: value.maker_order_id.unwrap_or_default(),
                        taker_order_id: value.taker_order_id.unwrap_or_default(),
                        ts: value.ts.unsigned_abs(),
                        signature: signature.to_string(),
                        tx_idx,
                    })
                }
            }
            OrderAction::Fill => Some(DriftEvent::OrderFill {
                maker: value.maker,
                maker_fee: value.maker_fee.unwrap_or_default(),
                maker_order_id: value.maker_order_id.unwrap_or_default(),
                maker_side: value.maker_order_direction,
                taker: value.taker,
                taker_fee: value.taker_fee.unwrap_or_default(),
                taker_order_id: value.taker_order_id.unwrap_or_default(),
                taker_side: value.taker_order_direction,
                base_asset_amount_filled: value.base_asset_amount_filled.unwrap_or_default(),
                quote_asset_amount_filled: value.quote_asset_amount_filled.unwrap_or_default(),
                oracle_price: value.oracle_price,
                market_index: value.market_index,
                market_type: value.market_type,
                ts: value.ts.unsigned_abs(),
                signature: signature.to_string(),
                tx_idx,
                bit_flags: value.bit_flags,
            }),
            OrderAction::Trigger => Some(DriftEvent::OrderTrigger {
                amount: value.taker_order_base_asset_amount.unwrap_or(0),
                oracle_price: value.oracle_price.unsigned_abs(),
                user: value.taker.unwrap_or_default(),
                order_id: value.taker_order_id.unwrap_or(0),
            }),
            // Place - parsed from `OrderRecord` event, ignored here due to lack of useful info
            // Expire - never emitted
            OrderAction::Place | OrderAction::Expire => None,
        }
    }
}

/// fixed capacity cache of tx signatures
struct TxSignatureCache {
    capacity: usize,
    entries: HashSet<String>,
    age: VecDeque<String>,
}

impl TxSignatureCache {
    fn new(capacity: usize) -> Self {
        Self {
            capacity,
            entries: HashSet::<String>::with_capacity_and_hasher(capacity, Default::default()),
            age: VecDeque::with_capacity(capacity),
        }
    }
    fn contains(&self, x: &str) -> bool {
        self.entries.contains(x)
    }
    fn insert(&mut self, x: String) {
        self.entries.insert(x.clone());
        self.age.push_back(x);

        if self.age.len() >= self.capacity {
            if let Some(ref oldest) = self.age.pop_front() {
                self.entries.remove(oldest);
            }
        }
    }
    #[cfg(test)]
    fn reset(&mut self) {
        self.entries.clear()
    }
}

#[cfg(test)]
mod test {
    use ahash::HashMap;
    use anchor_lang::prelude::*;
    use base64::Engine;
    use futures_util::future::ready;
    use solana_sdk::{
        hash::Hash,
        instruction::{AccountMeta, Instruction},
        message::{v0, VersionedMessage},
        pubkey::Pubkey,
    };
    use solana_transaction_status::{TransactionStatusMeta, VersionedTransactionWithStatusMeta};
    use tokio::sync::Mutex;

    use super::*;
    use crate::SdkError;

    #[cfg(feature = "rpc_tests")]
    #[tokio::test]
    async fn event_streaming_logs() {
        use crate::async_utils::retry_policy;
        let mut event_stream = EventSubscriber::subscribe(
            "wss://api.devnet.solana.com",
            Pubkey::from_str("9JtczxrJjPM4J1xooxr2rFXmRivarb4BwjNiBgXDwe2p").unwrap(),
            retry_policy::never(),
        )
        .await
        .unwrap()
        .take(5);

        while let Some(event) = event_stream.next().await {
            dbg!(event);
        }
    }

    #[ignore = "base64 encoded logs need updating"]
    #[tokio::test]
    async fn log_stream_handles_jit_proxy_events() {
        let cache = TxSignatureCache::new(16);
        let (event_tx, mut event_rx) = channel(16);

        let mut log_stream = LogEventStream {
            cache: Arc::new(cache.into()),
            provider: Arc::new(
                PubsubClient::new("wss://api.devnet.solana.com".into())
                    .await
                    .unwrap(),
            ),
            sub_account: "GgZkrSFgTAXZn1rNtZ533wpZi6nxx8whJC9bxRESB22c"
                .try_into()
                .unwrap(),
            event_tx,
            commitment: CommitmentConfig::confirmed(),
        };

        let logs: Vec<String> = [
            "Program ComputeBudget111111111111111111111111111111 invoke [1]",
            "Program ComputeBudget111111111111111111111111111111 success",
            "Program J1TnP8zvVxbtF5KFp5xRmWuvG9McnhzmBd9XGfCyuxFP invoke [1]",
            "Program log: Instruction: ArbPerp",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH invoke [2]",
            "Program log: Instruction: PlaceAndTakePerpOrder",
            "Program log: Invalid Spot 0 Oracle: Stale (oracle_delay=23)",
            "Program log: 4DRDR8LtbQFOKvplAAAAAAAAGAABAAAAAAAAAAAAAAFGJn8TpIimFlKv8ZWRhmuU81x+ojkf3K4d+++MbslDfAGZcTYAAQEBAM5q/TIAAAABAAAAAAAAAAABAAAAAAAAAAAAAAAAAACTWxEAAAAAAAA=",
            "Program log: aBNAOFkVAlpOKvplAAAAAEYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8qZQ2DwAAAABMTREAAAAAAADOav0yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJlxNgAYAAEBAQAAAQAAAQAAAAAA",
            "Program log: 4DRDR8LtbQFOKvplAAAAAAIIGAABAUYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8AQAAAAAAAAAAAceaAwAAAAAAAQDOav0yAAAAAQQgzQ4AAAAAAQIjAQAAAAAAAQA+////////AAAAAUYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8AZlxNgABAQEAzmr9MgAAAAEAzmr9MgAAAAEEIM0OAAAAAAHpAf4sI0TDV0Ec0LWHs9mO40bjfKEm3A+yye5HFCQQQQEzPgAAAQABANraQssAAAABANraQssAAAABLJgAOwAAAACTWxEAAAAAAAA=",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH consumed 373815 of 1334075 compute units",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH success",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH invoke [2]",
            "Program log: Instruction: PlaceAndTakePerpOrder",
            "Program log: Invalid Spot 0 Oracle: Stale (oracle_delay=23)",
            "Program log: 4DRDR8LtbQFOKvplAAAAAAAAGAABAAAAAAAAAAAAAAFGJn8TpIimFlKv8ZWRhmuU81x+ojkf3K4d+++MbslDfAGacTYAAQABAM5q/TIAAAABAAAAAAAAAAABAAAAAAAAAAAAAAAAAACTWxEAAAAAAAA=",
            "Program log: aBNAOFkVAlpOKvplAAAAAEYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8qZQ2DwAAAACAPBEAAAAAAADOav0yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJpxNgAYAAEBAQABAAAAAQAAAAAA",
            "Program log: 4DRDR8LtbQFOKvplAAAAAAIQGAABAUYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8AQAAAAAAAAAAAciaAwAAAAAAAQDgBS0LAAAAAQBYOwMAAAAAAYs/AAAAAAAAAAAB+Ejx//////8AAUYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8AZpxNgABAAEAzmr9MgAAAAEA4AUtCwAAAAEAWDsDAAAAAAAAAAAAAJNbEQAAAAAAAA==",
            "Program log: 4DRDR8LtbQFOKvplAAAAAAIIGAABAUYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8AQAAAAAAAAAAAcmaAwAAAAAAAQDuZNAnAAAAAYBpgwsAAAAAAV3iAAAAAAAAARhp////////AAAAAUYmfxOkiKYWUq/xlZGGa5TzXH6iOR/crh3774xuyUN8AZpxNgABAAEAzmr9MgAAAAEAzmr9MgAAAAGAwb4OAAAAAAFmQRGN8PRJqt5D5pVvCspbc3f0ZBdTB1Kcw0YfuzxCOAH2/poHAQEBAIjmn+sAAAABAFrDjp4AAAABgPDZLQAAAACTWxEAAAAAAAA=",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH consumed 269624 of 934786 compute units",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH success",
            "Program log: pnl 792986",
            "Program J1TnP8zvVxbtF5KFp5xRmWuvG9McnhzmBd9XGfCyuxFP consumed 738458 of 1399850 compute units",
            "Program J1TnP8zvVxbtF5KFp5xRmWuvG9McnhzmBd9XGfCyuxFP success",
            ].into_iter().map(Into::into).collect();

        log_stream.process_log(338797360, RpcLogsResponse {
            signature: "2jLk34wWwgecuws9iD9Ug63JdL8kYBePdtcakzG34zEx9KYVYD6HuokxMZYpFw799cJZBcaCMZ47WAxkGJjM7zNC".into(),
            err: None,
            logs: logs.clone(),
        }).await;

        // case 1: jit taker
        assert_eq!(
            event_rx.try_recv().expect("one event"),
            DriftEvent::OrderFill {
                maker: Some(
                    "GgZkrSFgTAXZn1rNtZ533wpZi6nxx8whJC9bxRESB22c".try_into().unwrap(),
                ),
                maker_fee: -49664,
                maker_order_id: 15923,
                maker_side: Some(
                    PositionDirection::Long,
                ),
                taker: Some(
                    "5iqawn52cdBmsjC4hDegyFnX1iNRTNDV5mRsGzgqbuyD".try_into().unwrap(),
                ),
                taker_fee: 74498,
                taker_order_id: 3568025,
                taker_side: Some(
                    PositionDirection::Short,
                ),
                base_asset_amount_filled: 219000000000,
                quote_asset_amount_filled: 248324100,
                market_index: 24,
                market_type: MarketType::Perp,
                oracle_price: 1137555,
                signature: "2jLk34wWwgecuws9iD9Ug63JdL8kYBePdtcakzG34zEx9KYVYD6HuokxMZYpFw799cJZBcaCMZ47WAxkGJjM7zNC".into(),
                tx_idx: 9,
                ts: 1710893646,
                bit_flags: 0,
            }
        );
        assert!(event_rx.try_recv().is_err()); // no more events

        // case 2: jit maker
        // reset the cache and account to process the log from maker's side this time
        log_stream.sub_account = "5iqawn52cdBmsjC4hDegyFnX1iNRTNDV5mRsGzgqbuyD"
            .try_into()
            .unwrap();
        log_stream.cache.write().await.reset();

        log_stream.process_log(338797360, RpcLogsResponse {
            signature: "2jLk34wWwgecuws9iD9Ug63JdL8kYBePdtcakzG34zEx9KYVYD6HuokxMZYpFw799cJZBcaCMZ47WAxkGJjM7zNC".into(),
            err: None,
            logs: logs.clone(),
        }).await;

        assert!(event_rx.try_recv().is_ok()); // place/create
        assert!(event_rx.try_recv().is_ok()); // fill with match
        assert!(event_rx.try_recv().is_ok()); // place/create
        assert!(event_rx.try_recv().is_ok()); // fill with amm
        assert!(event_rx.try_recv().is_ok()); // fill with match
        assert!(event_rx.try_recv().is_err()); // no more events
    }

    #[ignore = "base64 encoded logs need updating"]
    #[test]
    fn parses_order_trigger() {
        let logs = &[
        "Program log: Instruction: TriggerOrder",
        "Program log: new auction duration 20 start price -78510 end price -240874",
        "Program data: 4DRDR8LtbQG05GRoAAAAAAMAAAABAWV38QbUIIRAZCdpZP/Qu59+ZUJQ7xCnqbsMijUn8LhNAbgLAAAAAAAAAAAAAbgLAAAAAAAAAAAAAAFyjMdMRfzcEXahOyKad9N6FfOMHN8CvExn1JYdEjXysQEXAQAAAQEBAGXNHQAAAAABAAAAAAAAAAABAAAAAAAAAAAAAAAAAADvauMIAAAAAAAAAAAA",
        "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH consumed 20239 of 319700 compute units",
        "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH success",
        "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH invoke [1]",
        "Program log: Instruction: FillPerpOrder",
        "Program log: market 0 amm skipping auction duration",
        "Program log: 4DRDR8LtbQG05GRoAAAAAAIGAAABAWV38QbUIIRAZCdpZP/Qu59+ZUJQ7xCnqbsMijUn8LhNAUcHAAAAAAAAASRutQAAAAAAAQBlzR0AAAAAAayTcQQAAAAAAc9IAAAAAAAAAAABySEAAAAAAAAAAXKMx0xF/NwRdqE7Ipp303oV84wc3wK8TGfUlh0SNfKxARcBAAABAQEAZc0dAAAAAAEAZc0dAAAAAAGsk3EEAAAAAAAAAAAAAO9q4wgAAAAAAAEG408EAAAAAAAAAA==",
        ];
        let mut found_trigger = false;
        for log in logs {
            if let Some(DriftEvent::OrderTrigger { .. }) = try_parse_log(log, "sig", 0) {
                found_trigger = true;
            }
        }
        assert!(found_trigger);
    }

    #[ignore = "base64 encoded logs need updating"]
    #[test]
    fn parses_jit_proxy_logs() {
        let cpi_logs = &[
            "Program log: 4DRDR8LtbQFSX2toAAAAAAAAAQABAAAAAAAAAAAAAAAAAAAAAAHxh4ku0wIrxX3I+lRI8EbIXIFfEdQlHjfBI9cFoChKLwH02xUAAQABQHcbAAAAAAABAAAAAAAAAAABAAAAAAAAAACtuRtoGQAAAAAAAAAA",
            "Program log: aBNAOFkVAlpSX2toAAAAAPGHiS7TAivFfcj6VEjwRshcgV8R1CUeN8Ej1wWgKEovU9/1FAAAAACghJZnGQAAAEB3GwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPTbFQABAAEBAQAAAAABAQAAUwAA",
            "Program log: 4DRDR8LtbQFSX2toAAAAAAIHAQABAfGHiS7TAivFfcj6VEjwRshcgV8R1CUeN8Ej1wWgKEovAQAAAAAAAAAAAcvxUgAAAAAAAaC7DQAAAAAAATpt2gUAAAAAAQAAAAAAAAAAAAABDh0AAAAAAAAAAVIi3orGnkfo2nFxt1E65uhfuUq1+ZNdDVJYImWVm0dJATViBAABAQFAdxsAAAAAAAGguw0AAAAAAAE6bdoFAAAAAAAAAAAAAK25G2gZAAAAAAAAAAA=",
            "Program log: 4DRDR8LtbQFSX2toAAAAAAIJAQABAfGHiS7TAivFfcj6VEjwRshcgV8R1CUeN8Ej1wWgKEovAQAAAAAAAAAAAczxUgAAAAAAAaC7DQAAAAAAATpt2gUAAAAAAQAAAAAAAAAAAQAAAAAAAAAAAAAAAVIi3orGnkfo2nFxt1E65uhfuUq1+ZNdDVJYImWVm0dJATViBAABAQFAdxsAAAAAAAFAdxsAAAAAAAF02rQLAAAAAAHxh4ku0wIrxX3I+lRI8EbIXIFfEdQlHjfBI9cFoChKLwH02xUAAQABQHcbAAAAAAABoLsNAAAAAAABOm3aBQAAAACtuRtoGQAAAAAAAAAA",
            "Program log: 4DRDR8LtbQFSX2toAAAAAAEAAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfGHiS7TAivFfcj6VEjwRshcgV8R1CUeN8Ej1wWgKEovAfTbFQABAAFAdxsAAAAAAAGguw0AAAAAAAE6bdoFAAAAAK25G2gZAAAAAAAAAAA=",
        ];

        for log in cpi_logs {
            let result = try_parse_log(log, "sig", 0);
            dbg!(log, result);
        }
    }

    #[tokio::test]
    async fn polled_event_stream_caching() {
        let _ = env_logger::try_init();
        struct MockRpcProvider {
            tx_responses: HashMap<String, EncodedTransactionWithStatusMeta>,
            signatures: tokio::sync::Mutex<Vec<String>>,
        }

        impl MockRpcProvider {
            async fn add_signatures(&self, signatures: Vec<String>) {
                let mut all_signatures = self.signatures.lock().await;
                all_signatures.extend(signatures.into_iter());
            }
        }

        impl EventRpcProvider for Arc<MockRpcProvider> {
            fn get_tx(
                &self,
                signature: Signature,
            ) -> BoxFuture<SdkResult<EncodedTransactionWithStatusMeta>> {
                ready(
                    self.tx_responses
                        .get(signature.to_string().as_str())
                        .ok_or(SdkError::Deserializing)
                        .cloned(),
                )
                .boxed()
            }
            fn get_tx_signatures(
                &self,
                _account: Pubkey,
                after: Option<Signature>,
                _limit: Option<usize>,
            ) -> BoxFuture<SdkResult<Vec<String>>> {
                async move {
                    let after = after.map(|s| s.to_string());
                    let mut self_signatures = self.signatures.lock().await;
                    if after.is_none() {
                        return Ok(self_signatures.clone());
                    }

                    if let Some(idx) = self_signatures
                        .iter()
                        .position(|s| Some(s) == after.as_ref())
                    {
                        if idx > 0 {
                            // newest -> oldest
                            *self_signatures = self_signatures[..idx].to_vec();
                        } else {
                            self_signatures.clear();
                        }
                    }

                    Ok(self_signatures.clone())
                }
                .boxed()
            }
        }

        let (event_tx, mut event_rx) = channel(16);
        let sub_account = Pubkey::new_unique();
        let cache = Arc::new(RwLock::new(TxSignatureCache::new(16)));

        let mut order_events: Vec<(OrderActionRecord, OrderRecord)> = (0..5)
            .map(|id| {
                (
                    get_order_action_record(
                        id as i64,
                        OrderAction::Place,
                        OrderActionExplanation::None,
                        0,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        Some(sub_account.clone()),
                        Some(Order {
                            order_id: id,
                            ..Default::default()
                        }),
                        0,
                        0,
                    ),
                    OrderRecord {
                        ts: id as i64,
                        user: sub_account,
                        order: Order {
                            order_id: id,
                            ..Default::default()
                        },
                    },
                )
            })
            .collect();
        let signatures: Vec<String> = (0..order_events.len())
            .map(|_| Signature::new_unique().to_string())
            .collect();
        let mut tx_responses = HashMap::<String, EncodedTransactionWithStatusMeta>::default();
        for s in signatures.iter() {
            let (oar, or) = order_events.pop().unwrap();
            tx_responses.insert(
                s.clone(),
                make_transaction(
                    sub_account,
                    Signature::from_str(s).unwrap(),
                    Some(vec![
                        format!("{PROGRAM_LOG}{}", serialize_event(oar)),
                        format!("{PROGRAM_LOG}{}", serialize_event(or),),
                    ]),
                ),
            );
        }

        let mock_rpc_provider = Arc::new(MockRpcProvider {
            tx_responses,
            signatures: Mutex::new(vec![signatures.first().unwrap().clone()]),
        });

        tokio::spawn(
            PolledEventStream {
                cache: Arc::clone(&cache),
                provider: Arc::clone(&mock_rpc_provider),
                sub_account,
                event_tx,
            }
            .stream_fn(),
        );
        tokio::time::sleep(Duration::from_secs(1)).await;

        // add 4 new tx signtaures
        // 1) cached
        // 2,3) emit events
        // 4) cached
        {
            let mut cache_ = cache.write().await;
            cache_.insert(signatures[1].clone());
            cache_.insert(signatures[4].clone());
        }
        mock_rpc_provider
            .add_signatures(signatures[1..].to_vec())
            .await;
        tokio::time::sleep(Duration::from_secs(1)).await;

        assert!(event_rx.recv().await.is_some_and(|f| {
            if let DriftEvent::OrderCreate { order, .. } = f {
                println!("{}", order.order_id);
                order.order_id == 1
            } else {
                false
            }
        }));
        assert!(event_rx.recv().await.is_some_and(|f| {
            if let DriftEvent::OrderCreate { order, .. } = f {
                println!("{}", order.order_id);
                order.order_id == 2
            } else {
                false
            }
        }));
        tokio::time::sleep(Duration::from_secs(1)).await;
        assert!(event_rx.try_recv().is_err());
    }

    #[ignore = "base64 encoded logs need updating"]
    #[test]
    fn parses_swap_logs() {
        let _ = env_logger::try_init();
        let logs = [
            "Program ComputeBudget111111111111111111111111111111 invoke [1]",
            "Program ComputeBudget111111111111111111111111111111 success",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH invoke [1]",
            "Program log: Instruction: BeginSwap",
            "Program data: t7rLuuG7X4KaKRhoAAAAAAEA+cUBBi3pAAAAAAAAAAAAAChj7nUCAAAAAAAAAAAAAABkycImhIMAAAAAAAAAAAAASvkgrAIAAAAAAAAAAAAAAAA1DADgIgIAgE8SAA==",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]",
            "Program log: Instruction: Transfer",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4645 of 549891 compute units",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH consumed 68535 of 602850 compute units",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH success",
            "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 invoke [1]",
            "Program log: Instruction: Route",
            "Program obriQD1zbpyLz95G5n7nJe6a4DPjpFwa5XYPoNm113y invoke [2]",
            "Program log: Instruction: Swap",
            "Program log: price_x: 1447685",
            "Program log: price_y: 10000",
            "Program log: reld 4",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
            "Program log: Instruction: Transfer",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4645 of 480841 compute units",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
            "Program log: Instruction: Transfer",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4736 of 473320 compute units",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
            "Program log: YX15 199179269003,100319696971,2000000,13814365",
            "Program obriQD1zbpyLz95G5n7nJe6a4DPjpFwa5XYPoNm113y consumed 67898 of 529822 compute units",
            "Program obriQD1zbpyLz95G5n7nJe6a4DPjpFwa5XYPoNm113y success",
            "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 invoke [2]",
            "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 consumed 184 of 460188 compute units",
            "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 success",
            "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 consumed 75895 of 534315 compute units",
            "Program return: JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 XcrSAAAAAAA=",
            "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 success",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH invoke [1]",
            "Program log: Instruction: EndSwap",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]",
            "Program log: Instruction: Transfer",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4736 of 408324 compute units",
            "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
            "Program log: Invalid Spot 0 Oracle: Stale (oracle_delay=38)",
            "Program log: Invalid Spot 9 Oracle: Stale (oracle_delay=38)",
            "Program log: Invalid Spot 5 Oracle: Stale (oracle_delay=38)",
            "Program data: ort7woo4+vGaKRhoAAAAAGV38QbUIIRAZCdpZP/Qu59+ZUJQ7xCnqbsMijUn8LhNXcrSAAAAAACAhB4AAAAAAAEAAADA3KAIAAAAAEBCDwAAAAAAAAAAAAAAAAA=",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH consumed 152124 of 458420 compute units",
            "Program dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH success",
        ];

        let res: Vec<DriftEvent> = logs.iter().enumerate().filter_map(|(idx, log)| try_parse_log(log, "2M1e4UJ1x6rwvjFR6kh5CDCWZg8NcGeqzT2GbDRGaC2TmZDgNTNbKSn4Y4pu11apErVycpk5p3Hq6Tg2nrFdGimm", idx)).collect();
        assert_eq!(res[0], DriftEvent::Swap {
            user: solana_sdk::pubkey!("7q6FkeUEvTDS6DaM2WTHw6s1gTzbBasGTPATLzMZW41S"),
            amount_in: 2000000,
            amount_out: 13814365,
            market_in: 0,
            market_out: 1,
            fee: 0,
            ts: 1746413978,
            signature: "2M1e4UJ1x6rwvjFR6kh5CDCWZg8NcGeqzT2GbDRGaC2TmZDgNTNbKSn4Y4pu11apErVycpk5p3Hq6Tg2nrFdGimm".try_into().unwrap(),
            tx_idx: 44,
        });
    }

    /// Make transaction with dummy instruction for drift program
    fn make_transaction(
        account: Pubkey,
        signature: Signature,
        logs: Option<Vec<String>>,
    ) -> EncodedTransactionWithStatusMeta {
        let mut meta = TransactionStatusMeta::default();
        meta.log_messages = logs;
        VersionedTransactionWithStatusMeta {
            transaction: VersionedTransaction {
                signatures: vec![signature],
                message: VersionedMessage::V0(
                    v0::Message::try_compile(
                        &account,
                        &[Instruction {
                            program_id: constants::PROGRAM_ID,
                            accounts: vec![AccountMeta::new_readonly(constants::PROGRAM_ID, true)],
                            data: Default::default(),
                        }],
                        &[],
                        Hash::new_unique(),
                    )
                    .expect("v0 message"),
                ),
            },
            meta,
        }
        .encode(UiTransactionEncoding::Base64, Some(0), false)
        .unwrap()
    }

    /// serialize event to string like Drift program log
    pub fn serialize_event<T: AnchorSerialize + Discriminator>(event: T) -> String {
        let mut data_buf = T::DISCRIMINATOR.to_vec();
        event.serialize(&mut data_buf).expect("serializes");
        base64::engine::general_purpose::STANDARD.encode(data_buf)
    }

    pub fn get_order_action_record(
        ts: i64,
        action: OrderAction,
        action_explanation: OrderActionExplanation,
        market_index: u16,
        filler: Option<Pubkey>,
        fill_record_id: Option<u64>,
        filler_reward: Option<u64>,
        base_asset_amount_filled: Option<u64>,
        quote_asset_amount_filled: Option<u64>,
        taker_fee: Option<u64>,
        maker_rebate: Option<u64>,
        referrer_reward: Option<u64>,
        quote_asset_amount_surplus: Option<i64>,
        spot_fulfillment_method_fee: Option<u64>,
        taker: Option<Pubkey>,
        taker_order: Option<Order>,
        maker: Option<Pubkey>,
        maker_order: Option<Order>,
        oracle_price: i64,
        bit_flags: u8,
    ) -> OrderActionRecord {
        OrderActionRecord {
            bit_flags,
            ts,
            action,
            action_explanation,
            market_index,
            market_type: if let Some(taker_order) = taker_order {
                taker_order.market_type
            } else if let Some(maker_order) = maker_order {
                maker_order.market_type
            } else {
                panic!("invalid order");
            },
            filler,
            filler_reward,
            fill_record_id,
            base_asset_amount_filled,
            quote_asset_amount_filled,
            taker_fee,
            maker_fee: match maker_rebate {
                Some(maker_rebate) => Some(maker_rebate as i64),
                None => None,
            },
            referrer_reward: match referrer_reward {
                Some(referrer_reward) if referrer_reward > 0 => {
                    Some(referrer_reward.try_into().unwrap())
                }
                _ => None,
            },
            quote_asset_amount_surplus,
            spot_fulfillment_method_fee,
            taker,
            taker_order_id: taker_order.map(|order| order.order_id),
            taker_order_direction: taker_order.map(|order| order.direction),
            taker_order_base_asset_amount: taker_order.map(|order| order.base_asset_amount),
            taker_order_cumulative_base_asset_amount_filled: taker_order
                .map(|order| order.base_asset_amount_filled),
            taker_order_cumulative_quote_asset_amount_filled: taker_order
                .as_ref()
                .map(|order| order.quote_asset_amount_filled),
            maker,
            maker_order_id: maker_order.map(|order| order.order_id),
            maker_order_direction: maker_order.map(|order| order.direction),
            maker_order_base_asset_amount: maker_order.map(|order| order.base_asset_amount),
            maker_order_cumulative_base_asset_amount_filled: maker_order
                .map(|order| order.base_asset_amount_filled),
            maker_order_cumulative_quote_asset_amount_filled: maker_order
                .map(|order| order.quote_asset_amount_filled),
            oracle_price,
            maker_existing_base_asset_amount: None,
            maker_existing_quote_entry_amount: None,
            taker_existing_base_asset_amount: None,
            taker_existing_quote_entry_amount: None,
            trigger_price: None,
            builder_fee: None,
            builder_idx: None,
        }
    }
}

```

## File: crates/src/ffi.rs
```
//!
//! FFI shims
//! Defines wrapper types for ergonomic access to drift-program logic
//!
use std::time::{SystemTime, UNIX_EPOCH};

use abi_stable::std_types::ROption;
use anchor_lang::{prelude::AccountInfo, Discriminator};
use solana_sdk::{account::Account, clock::Slot, pubkey::Pubkey};

pub use self::abi_types::*;
use crate::{
    constants::{high_leverage_mode_account, PROGRAM_ID},
    drift_idl::{
        accounts,
        errors::ErrorCode,
        types::{self, ContractType, MarginRequirementType, OracleSource},
    },
    market_state::MarketState,
    math::{
        constants::{BID_ASK_SPREAD_PRECISION_I64, PERCENTAGE_PRECISION_I128, QUOTE_PRECISION_I64},
        standardize_price_i64,
    },
    types::{
        accounts::HighLeverageModeConfig, ContractTier, OrderParams, OrderType, PositionDirection,
        ProtectedMakerParams, RevenueShareOrder, SdkError, ValidityGuardRails,
    },
    SdkResult,
};

// Declarations of exported functions from `drift-ffi` lib
// the types here must be C abi safe/compatible
//
// DEV: the types here are deliberately received as those defined in `::abi_types`-
// which are equivalent to the drift-ffi exported types directly from drift program crate
// the result is that this code can use its own solana-program/* crates without restriction from the version used by drift program
extern "C" {
    #[allow(improper_ctypes)]
    pub fn ffi_version() -> String;
    #[allow(improper_ctypes)]
    pub fn math_calculate_auction_price(
        order: &types::Order,
        slot: Slot,
        tick_size: u64,
        oracle_price: ROption<i64>,
        is_prediction_market: bool,
    ) -> FfiResult<u64>;
    #[allow(improper_ctypes)]
    pub fn math_calculate_margin_requirement_and_total_collateral_and_liability_info(
        user: &accounts::User,
        accounts: &mut AccountsList,
        mode: MarginContextMode,
    ) -> FfiResult<MarginCalculation>;

    #[allow(improper_ctypes)]
    pub fn oracle_get_oracle_price(
        oracle_source: OracleSource,
        oracle_account: &mut (Pubkey, Account),
        slot: Slot,
    ) -> FfiResult<OraclePriceData>;

    #[allow(improper_ctypes)]
    pub fn order_is_limit_order(order: &types::Order) -> bool;
    #[allow(improper_ctypes)]
    pub fn order_is_resting_limit_order(order: &types::Order, slot: Slot) -> FfiResult<bool>;
    #[allow(improper_ctypes)]
    pub fn order_get_limit_price(
        order: &types::Order,
        valid_oracle_price: Option<i64>,
        fallback_price: Option<u64>,
        slot: u64,
        tick_size: u64,
        is_prediction_market: bool,
        pmm_params: Option<ProtectedMakerParams>,
    ) -> FfiResult<Option<u64>>;

    #[allow(improper_ctypes)]
    pub fn perp_market_get_margin_ratio(
        market: &accounts::PerpMarket,
        size: u128,
        margin_type: MarginRequirementType,
        high_leverage_mode: bool,
    ) -> FfiResult<u32>;
    #[allow(improper_ctypes)]
    pub fn perp_market_get_open_interest(market: &accounts::PerpMarket) -> u128;
    #[allow(improper_ctypes)]
    pub fn perp_market_get_protected_maker_params(
        market: &accounts::PerpMarket,
    ) -> ProtectedMakerParams;
    #[allow(improper_ctypes)]
    pub fn perp_market_get_trigger_price(
        market: &accounts::PerpMarket,
        oracle_price: i64,
        now: i64,
        use_median_trigger_price: bool,
    ) -> FfiResult<u64>;
    #[allow(improper_ctypes)]
    pub fn perp_market_get_mm_oracle_price_data(
        market: &accounts::PerpMarket,
        oracle_price_data: OraclePriceData,
        clock_slot: Slot,
        oracle_guard_rails: &ValidityGuardRails,
    ) -> FfiResult<MMOraclePriceData>;
    #[allow(improper_ctypes)]
    pub fn perp_market_get_fallback_price(
        market: &accounts::PerpMarket,
        taker_direction: PositionDirection,
        oracle_price: i64,
        seconds_til_expiry: i64,
    ) -> FfiResult<u64>;
    #[allow(improper_ctypes)]
    pub fn perp_position_get_unrealized_pnl(
        position: &types::PerpPosition,
        oracle_price: i64,
    ) -> FfiResult<i128>;
    pub fn perp_position_is_available(position: &types::PerpPosition) -> bool;
    pub fn perp_position_is_open_position(position: &types::PerpPosition) -> bool;
    #[allow(improper_ctypes)]
    pub fn perp_position_worst_case_base_asset_amount(
        position: &types::PerpPosition,
        oracle_price: i64,
        contract_type: ContractType,
    ) -> FfiResult<i128>;

    #[allow(improper_ctypes)]
    pub fn spot_market_get_asset_weight(
        market: &accounts::SpotMarket,
        size: u128,
        oracle_price: i64,
        margin_requirement_type: MarginRequirementType,
    ) -> FfiResult<u32>;
    #[allow(improper_ctypes)]
    pub fn spot_market_get_liability_weight(
        market: &accounts::SpotMarket,
        size: u128,
        margin_requirement_type: MarginRequirementType,
    ) -> FfiResult<u32>;
    #[allow(improper_ctypes)]
    pub fn spot_position_is_available(position: &types::SpotPosition) -> bool;
    #[allow(improper_ctypes)]
    pub fn spot_position_get_signed_token_amount(
        position: &types::SpotPosition,
        market: &accounts::SpotMarket,
    ) -> FfiResult<i128>;
    #[allow(improper_ctypes)]
    pub fn spot_position_get_token_amount(
        position: &types::SpotPosition,
        market: &accounts::SpotMarket,
    ) -> FfiResult<u128>;
    #[allow(improper_ctypes)]
    pub fn user_get_spot_position(
        user: &accounts::User,
        market_index: u16,
    ) -> FfiResult<&types::SpotPosition>;
    #[allow(improper_ctypes)]
    pub fn user_get_perp_position(
        user: &accounts::User,
        market_index: u16,
    ) -> FfiResult<&types::PerpPosition>;
    #[allow(improper_ctypes)]
    pub fn user_update_perp_position_max_margin_ratio(
        user: &mut accounts::User,
        market_index: u16,
        margin_ratio: u16,
    ) -> FfiResult<()>;
    #[allow(improper_ctypes)]
    pub fn orders_place_perp_order<'a>(
        user: &accounts::User,
        state: &accounts::State,
        order_params: &types::OrderParams,
        accounts: &mut AccountsList,
        high_leverage_mode_config: Option<&'a AccountInfo<'a>>,
        revenue_order_share: &mut Option<&mut RevenueShareOrder>,
    ) -> FfiResult<bool>;
    #[allow(improper_ctypes)]
    pub fn order_params_will_auction_params_sanitize(
        order_params: &types::OrderParams,
        perp_market: &accounts::PerpMarket,
        oracle_price: i64,
        is_signed_msg: bool,
    ) -> FfiResult<bool>;
    #[allow(improper_ctypes)]
    pub fn order_params_update_perp_auction_params(
        order_params: &mut types::OrderParams,
        perp_market: &accounts::PerpMarket,
        oracle_price: i64,
        is_signed_msg: bool,
    );
    #[allow(improper_ctypes)]
    pub fn order_calculate_auction_params_for_trigger_order(
        order: &types::Order,
        oracle_price: &OraclePriceData,
        perp_market: Option<&accounts::PerpMarket>,
    ) -> FfiResult<(u8, i64, i64)>;
}

//
// Shims for SDK
//

/// Returns the linked libdrift_ffi version
pub fn check_ffi_version() -> String {
    unsafe { ffi_version() }
}

pub fn get_oracle_price(
    oracle_source: OracleSource,
    oracle_account: &mut (Pubkey, Account),
    slot: Slot,
) -> SdkResult<OraclePriceData> {
    if oracle_account.1.data.is_empty() {
        return Err(SdkError::NoAccountData(oracle_account.0));
    }
    to_sdk_result(unsafe { oracle_get_oracle_price(oracle_source, oracle_account, slot) })
}

pub fn calculate_auction_price(
    order: &types::Order,
    slot: Slot,
    tick_size: u64,
    oracle_price: Option<i64>,
    is_prediction_market: bool,
) -> SdkResult<u64> {
    let res = unsafe {
        math_calculate_auction_price(
            order,
            slot,
            tick_size,
            oracle_price.into(),
            is_prediction_market,
        )
    };
    to_sdk_result(res)
}

impl OrderParams {
    pub fn update_perp_auction_params(
        &mut self,
        perp_market: &accounts::PerpMarket,
        oracle_price: i64,
        is_signed_msg: bool,
    ) {
        unsafe {
            order_params_update_perp_auction_params(self, perp_market, oracle_price, is_signed_msg)
        }
    }
}

impl MarketState {
    /// Calculate margin requirement for user
    ///
    /// this is a more lightweight/optimized version of `calculate_margin_requirement_and_total_collateral_and_liability_info`
    pub fn calculate_simplified_margin_requirement(
        &self,
        user: &accounts::User,
        margin_type: MarginRequirementType,
        margin_buffer: Option<u32>,
    ) -> crate::SdkResult<SimplifiedMarginCalculation> {
        let state = self.load();
        let result = unsafe {
            margin_calculate_simplified_margin_requirement(
                user,
                &state,
                margin_type,
                margin_buffer.unwrap_or(0),
            )
        };

        to_sdk_result(result)
    }
    /// Calculate margin requirement for user
    ///
    /// incremental version allows partial updates e.g. when specific positions or oracle prices change
    pub fn calculate_incremental_margin_requirement(
        &self,
        user: &accounts::User,
        margin_type: MarginRequirementType,
        margin_buffer: Option<u32>,
    ) -> IncrementalMarginCalculation {
        let state = self.load();
        let ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
        unsafe {
            incremental_margin_calculation_from_user(
                user,
                &state,
                margin_type,
                ts,
                margin_buffer.unwrap_or(0),
            )
        }
    }
}

pub fn calculate_margin_requirement_and_total_collateral_and_liability_info(
    user: &accounts::User,
    accounts: &mut AccountsList,
    mode: MarginContextMode,
) -> SdkResult<MarginCalculation> {
    let res = unsafe {
        math_calculate_margin_requirement_and_total_collateral_and_liability_info(
            user, accounts, mode,
        )
    };
    to_sdk_result(res)
}

/// Simulates the program's `place_perp_order` ix
/// Useful to verify an order can be placed given factors such as available margin, etc.
///
/// Returns `true` if the order could be placed
pub fn simulate_place_perp_order<'a>(
    user: &mut accounts::User,
    accounts: &mut AccountsList,
    state: &accounts::State,
    order_params: &types::OrderParams,
    high_leverage_mode_config: Option<&mut accounts::HighLeverageModeConfig>,
    max_margin_ratio: Option<u16>,
    revenue_share_order: &mut Option<&mut RevenueShareOrder>,
) -> SdkResult<bool> {
    if order_params.high_leverage_mode() && high_leverage_mode_config.is_none() {
        return Err(SdkError::Generic(
            "HLM config account must be provided".to_owned(),
        ));
    }

    if let Some(max_margin_ratio) = max_margin_ratio {
        user.update_perp_position_max_margin_ratio(order_params.market_index, max_margin_ratio)?;
    }

    let mut lamports = 0;
    let res = match high_leverage_mode_config {
        Some(hlm) => {
            let mut data = HighLeverageModeConfig::DISCRIMINATOR.to_vec();
            data.extend_from_slice(bytemuck::bytes_of(hlm));

            let hlm = AccountInfo::new(
                high_leverage_mode_account(),
                false,
                true,
                &mut lamports,
                data.as_mut_slice(),
                &PROGRAM_ID,
                false,
                u64::MAX,
            );
            unsafe {
                orders_place_perp_order(
                    user,
                    state,
                    order_params,
                    accounts,
                    Some(&hlm),
                    revenue_share_order,
                )
            }
        }
        None => unsafe {
            orders_place_perp_order(
                user,
                state,
                order_params,
                accounts,
                None,
                revenue_share_order,
            )
        },
    };
    to_sdk_result(res)
}

/// Simulates using the program's update_perp_auction_params func to determine if
/// an order's auction params will get sanitized
///
/// Returns `true` if the order's auctions will get sanitized
pub fn simulate_will_auction_params_sanitize(
    order_params: &types::OrderParams,
    perp_market: &accounts::PerpMarket,
    oracle_price: i64,
    is_signed_msg: bool,
) -> SdkResult<bool> {
    let res = unsafe {
        order_params_will_auction_params_sanitize(
            order_params,
            perp_market,
            oracle_price,
            is_signed_msg,
        )
    };
    to_sdk_result(res)
}

impl types::OrderParams {
    pub fn get_auction_params(
        &self,
        oracle_price_data: &OraclePriceData,
        tick_size: u64,
        min_auction_duration: u8,
    ) -> Option<(i64, i64, u8)> {
        if !matches!(
            self.order_type,
            OrderType::Market | OrderType::Oracle | OrderType::Limit
        ) {
            return Some((0_i64, 0_i64, 0_u8));
        }

        if self.order_type == OrderType::Limit {
            return match (
                self.auction_start_price,
                self.auction_end_price,
                self.auction_duration,
            ) {
                (Some(auction_start_price), Some(auction_end_price), Some(auction_duration)) => {
                    let auction_duration = if auction_duration == 0 {
                        auction_duration
                    } else {
                        // if auction is non-zero, force it to be at least min_auction_duration
                        auction_duration.max(min_auction_duration)
                    };

                    Some((
                        standardize_price_i64(auction_start_price, tick_size, self.direction),
                        standardize_price_i64(auction_end_price, tick_size, self.direction),
                        auction_duration,
                    ))
                }
                _ => Some((0_i64, 0_i64, 0_u8)),
            };
        }

        let auction_duration = self.auction_duration.unwrap_or(0).max(min_auction_duration);

        let (auction_start_price, auction_end_price) =
            match (self.auction_start_price, self.auction_end_price) {
                (Some(auction_start_price), Some(auction_end_price)) => {
                    (auction_start_price, auction_end_price)
                }
                _ if self.order_type == OrderType::Oracle => return None,
                _ => calculate_auction_prices(oracle_price_data, self.direction, self.price)?,
            };

        Some((
            standardize_price_i64(auction_start_price, tick_size, self.direction),
            standardize_price_i64(auction_end_price, tick_size, self.direction),
            auction_duration,
        ))
    }
}
pub const AUCTION_DERIVE_PRICE_FRACTION: i64 = 200;
pub fn calculate_auction_prices(
    oracle_price_data: &OraclePriceData,
    direction: PositionDirection,
    limit_price: u64,
) -> Option<(i64, i64)> {
    let oracle_price = oracle_price_data.price;
    let limit_price = limit_price as i64;
    if limit_price > 0 {
        let (auction_start_price, auction_end_price) = match direction {
            // Long and limit price is better than oracle price
            PositionDirection::Long if limit_price < oracle_price => {
                let limit_derive_start_price =
                    limit_price.checked_sub(limit_price / AUCTION_DERIVE_PRICE_FRACTION)?;
                let oracle_derive_start_price =
                    oracle_price.checked_sub(oracle_price / AUCTION_DERIVE_PRICE_FRACTION)?;

                (
                    limit_derive_start_price.min(oracle_derive_start_price),
                    limit_price,
                )
            }
            // Long and limit price is worse than oracle price
            PositionDirection::Long if limit_price >= oracle_price => {
                let oracle_derive_end_price =
                    oracle_price.checked_add(oracle_price / AUCTION_DERIVE_PRICE_FRACTION)?;

                (oracle_price, limit_price.min(oracle_derive_end_price))
            }
            // Short and limit price is better than oracle price
            PositionDirection::Short if limit_price > oracle_price => {
                let limit_derive_start_price =
                    limit_price.checked_add(limit_price / AUCTION_DERIVE_PRICE_FRACTION)?;
                let oracle_derive_start_price =
                    oracle_price.checked_add(oracle_price / AUCTION_DERIVE_PRICE_FRACTION)?;

                (
                    limit_derive_start_price.max(oracle_derive_start_price),
                    limit_price,
                )
            }
            // Short and limit price is worse than oracle price
            PositionDirection::Short if limit_price <= oracle_price => {
                let oracle_derive_end_price =
                    oracle_price.checked_sub(oracle_price / AUCTION_DERIVE_PRICE_FRACTION)?;

                (oracle_price, limit_price.max(oracle_derive_end_price))
            }
            _ => unreachable!(),
        };

        return Some((auction_start_price, auction_end_price));
    }

    let auction_end_price = match direction {
        PositionDirection::Long => {
            oracle_price.checked_add(oracle_price / AUCTION_DERIVE_PRICE_FRACTION)?
        }
        PositionDirection::Short => {
            oracle_price.checked_sub(oracle_price / AUCTION_DERIVE_PRICE_FRACTION)?
        }
    };

    Some((oracle_price, auction_end_price))
}

impl types::SpotPosition {
    pub fn is_available(&self) -> bool {
        unsafe { spot_position_is_available(self) }
    }
    pub fn get_signed_token_amount(&self, market: &accounts::SpotMarket) -> SdkResult<i128> {
        to_sdk_result(unsafe { spot_position_get_signed_token_amount(self, market) })
    }
    pub fn get_token_amount(&self, market: &accounts::SpotMarket) -> SdkResult<u128> {
        to_sdk_result(unsafe { spot_position_get_token_amount(self, market) })
    }
}

impl types::PerpPosition {
    pub fn get_unrealized_pnl(&self, oracle_price: i64) -> SdkResult<i128> {
        to_sdk_result(unsafe { perp_position_get_unrealized_pnl(self, oracle_price) })
    }
    pub fn is_available(&self) -> bool {
        unsafe { perp_position_is_available(self) }
    }
    pub fn is_open_position(&self) -> bool {
        unsafe { perp_position_is_open_position(self) }
    }
    pub fn worst_case_base_asset_amount(
        &self,
        oracle_price: i64,
        contract_type: ContractType,
    ) -> SdkResult<i128> {
        to_sdk_result(unsafe {
            perp_position_worst_case_base_asset_amount(self, oracle_price, contract_type)
        })
    }
}

impl accounts::User {
    pub const STATUS_BEING_LIQUIDATED: u8 = 0b00000001;
    pub const STATUS_BANKRUPT: u8 = 0b00000010;
    pub const STATUS_REDUCE_ONLY: u8 = 0b00000100;
    pub const STATUS_ADVANCED_LP: u8 = 0b00001000;
    pub const STATUS_PROTECTED_MAKER_ORDERS: u8 = 0b00010000;

    pub fn get_spot_position(&self, market_index: u16) -> SdkResult<types::SpotPosition> {
        // TODO: no clone
        to_sdk_result(unsafe { user_get_spot_position(self, market_index) }).copied()
    }
    pub fn get_perp_position(&self, market_index: u16) -> SdkResult<types::PerpPosition> {
        to_sdk_result(unsafe { user_get_perp_position(self, market_index) }).copied()
    }
    pub fn is_being_liquidated(&self) -> bool {
        self.status & (Self::STATUS_BEING_LIQUIDATED | Self::STATUS_BANKRUPT) > 0
    }
    pub fn is_bankrupt(&self) -> bool {
        (self.status & Self::STATUS_BANKRUPT) > 0
    }
    pub fn is_reduce_only(&self) -> bool {
        (self.status & Self::STATUS_REDUCE_ONLY) > 0
    }
    pub fn is_advanced_lp(&self) -> bool {
        (self.status & Self::STATUS_ADVANCED_LP) > 0
    }
    pub fn is_protected_maker(&self) -> bool {
        (self.status & Self::STATUS_PROTECTED_MAKER_ORDERS) > 0
    }

    pub fn update_perp_position_max_margin_ratio(
        &mut self,
        market_index: u16,
        max_margin_ratio: u16,
    ) -> SdkResult<()> {
        to_sdk_result(unsafe {
            user_update_perp_position_max_margin_ratio(self, market_index, max_margin_ratio)
        })
    }
}

impl types::Order {
    pub fn is_limit_order(&self) -> bool {
        unsafe { order_is_limit_order(self) }
    }
    pub fn is_resting_limit_order(&self, slot: Slot) -> SdkResult<bool> {
        to_sdk_result(unsafe { order_is_resting_limit_order(self, slot) })
    }
    pub fn get_limit_price(
        &self,
        valid_oracle_price: Option<i64>,
        fallback_price: Option<u64>,
        slot: u64,
        tick_size: u64,
        is_prediction_market: bool,
        pmm_params: Option<ProtectedMakerParams>,
    ) -> SdkResult<Option<u64>> {
        to_sdk_result(unsafe {
            order_get_limit_price(
                self,
                valid_oracle_price,
                fallback_price,
                slot,
                tick_size,
                is_prediction_market,
                pmm_params,
            )
        })
    }
}

impl accounts::SpotMarket {
    pub fn get_asset_weight(
        &self,
        size: u128,
        oracle_price: i64,
        margin_requirement_type: MarginRequirementType,
    ) -> SdkResult<u32> {
        to_sdk_result(unsafe {
            spot_market_get_asset_weight(self, size, oracle_price, margin_requirement_type)
        })
    }
    pub fn get_liability_weight(
        &self,
        size: u128,
        margin_requirement_type: MarginRequirementType,
    ) -> SdkResult<u32> {
        to_sdk_result(unsafe {
            spot_market_get_liability_weight(self, size, margin_requirement_type)
        })
    }
}

impl accounts::PerpMarket {
    /// Return VAMM fallback price
    pub fn fallback_price(
        &self,
        taker_direction: PositionDirection,
        oracle_price: i64,
        seconds_til_expiry: i64,
    ) -> SdkResult<u64> {
        to_sdk_result(unsafe {
            perp_market_get_fallback_price(self, taker_direction, oracle_price, seconds_til_expiry)
        })
    }
    pub fn get_mm_oracle_price_data(
        &self,
        oracle_price_data: OraclePriceData,
        clock_slot: Slot,
        validity_guard_rails: &ValidityGuardRails,
    ) -> SdkResult<MMOraclePriceData> {
        to_sdk_result(unsafe {
            perp_market_get_mm_oracle_price_data(
                self,
                oracle_price_data,
                clock_slot,
                validity_guard_rails,
            )
        })
    }
    pub fn get_trigger_price(
        &self,
        oracle_price: i64,
        now: i64,
        use_median_trigger_price: bool,
    ) -> SdkResult<u64> {
        to_sdk_result(unsafe {
            perp_market_get_trigger_price(self, oracle_price, now, use_median_trigger_price)
        })
    }
    pub fn get_margin_ratio(
        &self,
        size: u128,
        margin_requirement_type: MarginRequirementType,
        high_leverage_mode: bool,
    ) -> SdkResult<u32> {
        to_sdk_result(unsafe {
            perp_market_get_margin_ratio(self, size, margin_requirement_type, high_leverage_mode)
        })
    }
    pub fn get_open_interest(&self) -> u128 {
        unsafe { perp_market_get_open_interest(self) }
    }
    pub fn get_protected_maker_params(&self) -> ProtectedMakerParams {
        unsafe { perp_market_get_protected_maker_params(self) }
    }
    pub fn has_too_much_drawdown(&self) -> bool {
        pub const DEFAULT_REVENUE_SINCE_LAST_FUNDING_SPREAD_RETREAT: i64 =
            -25 * QUOTE_PRECISION_I64; //$25 loss
        let quote_drawdown_limit_breached = match self.contract_tier {
            ContractTier::A | ContractTier::B => {
                self.amm.net_revenue_since_last_funding
                    <= DEFAULT_REVENUE_SINCE_LAST_FUNDING_SPREAD_RETREAT * 400
            }
            _ => {
                self.amm.net_revenue_since_last_funding
                    <= DEFAULT_REVENUE_SINCE_LAST_FUNDING_SPREAD_RETREAT * 200
            }
        };

        if quote_drawdown_limit_breached {
            let net_revenue_since_last_funding = self.amm.net_revenue_since_last_funding as i128;
            let percent_drawdown = (net_revenue_since_last_funding * PERCENTAGE_PRECISION_I128)
                / (self.amm.total_fee_minus_distributions.as_i128().max(1_i128));

            let percent_drawdown_limit_breached = match self.contract_tier {
                ContractTier::A => percent_drawdown <= -PERCENTAGE_PRECISION_I128 / 50,
                ContractTier::B => percent_drawdown <= -PERCENTAGE_PRECISION_I128 / 33,
                ContractTier::C => percent_drawdown <= -PERCENTAGE_PRECISION_I128 / 25,
                _ => percent_drawdown <= -PERCENTAGE_PRECISION_I128 / 20,
            };

            if percent_drawdown_limit_breached {
                return true;
            }
        }

        false
    }
    /// Return AMM's reserve price
    pub fn reserve_price(&self) -> u64 {
        // (quote_asset_reserve / base_asset_reserve) * peg / PEG_PRECISION
        if self.amm.base_asset_reserve.as_u128() == 0 {
            return 0;
        }
        let peg_quote_asset_amount =
            self.amm.quote_asset_reserve.as_u128() * self.amm.peg_multiplier.as_u128();
        peg_quote_asset_amount.saturating_div(self.amm.base_asset_reserve.as_u128()) as u64
    }

    /// Return AMM's bid price
    ///
    /// ## Params
    ///
    /// * `reserve_price` - optional reserve price, default: AMM current reserve price
    ///
    pub fn bid_price(&self, reserve_price: Option<u64>) -> u64 {
        let adjusted_spread = (-(self.amm.short_spread as i32)) + self.amm.reference_price_offset;
        let multiplier = BID_ASK_SPREAD_PRECISION_I64 + adjusted_spread as i64;
        let reserve_price = reserve_price.unwrap_or(self.reserve_price());

        (reserve_price * multiplier.unsigned_abs()) / BID_ASK_SPREAD_PRECISION_I64 as u64
    }

    /// Return AMM's ask price
    ///
    /// ## Params
    ///
    /// * `reserve_price` - optional reserve price, default: AMM current reserve price
    ///
    pub fn ask_price(&self, reserve_price: Option<u64>) -> u64 {
        let adjusted_spread = self.amm.long_spread as i32 + self.amm.reference_price_offset;
        let multiplier = BID_ASK_SPREAD_PRECISION_I64 + adjusted_spread as i64;
        let reserve_price = reserve_price.unwrap_or(self.reserve_price());

        (reserve_price * multiplier.unsigned_abs()) / BID_ASK_SPREAD_PRECISION_I64 as u64
    }
}

impl types::MarginMode {
    /// Returns true if the margin mode is high leverage mode or high leverage maintenance mode
    pub fn is_high_leverage_mode(&self, margin_type: MarginRequirementType) -> bool {
        matches!(
            (self, margin_type),
            (types::MarginMode::HighLeverage, _)
                | (
                    types::MarginMode::HighLeverageMaintenance,
                    MarginRequirementType::Maintenance
                )
        )
    }
}

/// Calculates auction params for a trigger order using the FFI, returning (duration, start_price, end_price)
pub fn calculate_auction_params_for_trigger_order(
    order: &types::Order,
    oracle_price: &OraclePriceData,
    perp_market: Option<&accounts::PerpMarket>,
) -> SdkResult<(u8, i64, i64)> {
    to_sdk_result(unsafe {
        order_calculate_auction_params_for_trigger_order(order, oracle_price, perp_market)
    })
}

fn to_sdk_result<T>(value: FfiResult<T>) -> SdkResult<T> {
    match value {
        FfiResult::ROk(t) => Ok(t),
        FfiResult::RErr(code) => {
            let error_code = unsafe {
                std::mem::transmute::<u32, ErrorCode>(code - anchor_lang::error::ERROR_CODE_OFFSET)
            };
            Err(crate::SdkError::Anchor(Box::new(error_code.into())))
        }
    }
}

impl IncrementalMarginCalculation {
    /// Return free collateral amount
    pub fn free_collateral(&self) -> i128 {
        self.total_collateral - self.margin_requirement as i128
    }
    /// Create a new cached margin calculation from a user account
    pub fn from_user(
        user: &accounts::User,
        market_state: &MarketState,
        margin_type: MarginRequirementType,
        timestamp: u64,
        margin_buffer: Option<u32>,
    ) -> Self {
        let m = market_state.load();
        unsafe {
            incremental_margin_calculation_from_user(
                user,
                &m,
                margin_type,
                timestamp,
                margin_buffer.unwrap_or(0),
            )
        }
    }

    /// Create a new cached margin calculation from a user account with current timestamp
    pub fn from_user_now(
        user: &accounts::User,
        market_state: &MarketState,
        margin_type: MarginRequirementType,
        margin_buffer: Option<u32>,
    ) -> Self {
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        Self::from_user(user, market_state, margin_type, timestamp, margin_buffer)
    }

    /// Update the cached calculation with a spot position change
    pub fn update_spot_position(
        &mut self,
        spot_position: &types::SpotPosition,
        market_state: &MarketState,
        timestamp: u64,
    ) {
        let m = market_state.load();
        unsafe {
            incremental_margin_calculation_update_spot_position(self, spot_position, &m, timestamp);
        }
    }

    /// Update the cached calculation with a perp position change
    pub fn update_perp_position(
        &mut self,
        perp_position: &types::PerpPosition,
        market_state: &MarketState,
        timestamp: u64,
    ) {
        let m = market_state.load();
        unsafe {
            incremental_margin_calculation_update_perp_position(self, perp_position, &m, timestamp);
        }
    }
}

pub mod abi_types {
    //! cross-boundary FFI types
    use abi_stable::std_types::RResult;
    use solana_sdk::{account::Account, clock::Slot, pubkey::Pubkey};

    use crate::{drift_idl::types::MarginRequirementType, types::OracleValidity, OracleGuardRails};

    /// FFI safe version of (pubkey, account)
    #[repr(C)]
    pub struct AccountWithKey {
        pub key: Pubkey,
        pub account: Account,
    }

    impl From<(Pubkey, Account)> for AccountWithKey {
        fn from(value: (Pubkey, Account)) -> Self {
            Self {
                key: value.0,
                account: value.1,
            }
        }
    }

    /// FFI equivalent of an `AccountMap`
    /// Its used as input for drift program math functions
    #[repr(C)]
    pub struct AccountsList<'a> {
        // accounts
        pub perp_markets: &'a mut [AccountWithKey],
        pub spot_markets: &'a mut [AccountWithKey],
        pub oracles: &'a mut [AccountWithKey],
        // context
        pub oracle_guard_rails: Option<OracleGuardRails>,
        pub latest_slot: Slot,
    }

    #[cfg(test)]
    impl<'a> AccountsList<'a> {
        pub fn new(
            perp_markets: &'a mut [AccountWithKey],
            spot_markets: &'a mut [AccountWithKey],
            oracles: &'a mut [AccountWithKey],
        ) -> Self {
            Self {
                perp_markets,
                spot_markets,
                oracles,
                oracle_guard_rails: None,
                latest_slot: 0,
            }
        }
    }

    /// FFI safe equivalent of `MarginContext`
    #[repr(C)]
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub enum MarginContextMode {
        StandardMaintenance,
        StandardInitial,
        StandardCustom(MarginRequirementType),
    }

    #[repr(C, align(16))]
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub struct MarginCalculation {
        pub total_collateral: i128,
        pub margin_requirement: u128,
        pub all_oracles_valid: bool,
        pub with_perp_isolated_liability: bool,
        pub with_spot_isolated_liability: bool,
        pub total_spot_asset_value: i128,
        pub total_spot_liability_value: u128,
        pub total_perp_liability_value: u128,
        pub total_perp_pnl: i128,
        pub open_orders_margin_requirement: u128,
    }

    impl MarginCalculation {
        pub fn get_free_collateral(&self) -> u128 {
            (self.total_collateral - self.margin_requirement as i128) // safe cast, margin requirement >= 0
                .max(0) as u128
        }
    }

    /// FFI equivalent of `OraclePriceData`
    #[derive(Default, Clone, Copy, Debug)]
    pub struct OraclePriceData {
        pub price: i64,
        pub confidence: u64,
        pub delay: i64,
        pub has_sufficient_number_of_data_points: bool,
        pub sequence_id: Option<u64>,
    }

    /// MMOraclePriceData, not defined in IDL
    #[derive(Default, Clone, Copy, Debug)]
    pub struct MMOraclePriceData {
        pub mm_oracle_price: i64,
        pub mm_oracle_delay: i64,
        pub mm_oracle_validity: OracleValidity,
        pub mm_exchange_diff_bps: u128,
        pub exchange_oracle_price_data: OraclePriceData,
        pub safe_oracle_price_data: OraclePriceData,
    }

    /// C-ABI compatible result type for drift FFI calls
    pub type FfiResult<T> = RResult<T, u32>;

    /// FFI-compatible simplified margin calculation result
    #[repr(C, align(16))]
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub struct SimplifiedMarginCalculation {
        pub total_collateral: i128,
        pub total_collateral_buffer: i128,
        pub margin_requirement: u128,
        pub margin_requirement_plus_buffer: u128,
    }

    /// FFI-compatible incremental margin calculation
    ///
    /// This struct must match the FFI-side struct exactly for proper alignment
    #[repr(C, align(16))]
    #[derive(Clone)]
    pub struct IncrementalMarginCalculation {
        pub total_collateral: i128,
        pub total_collateral_buffer: i128,
        pub margin_requirement: u128,
        pub margin_requirement_plus_buffer: u128,
        pub spot_collateral: [PositionCollateral; 8],
        pub perp_collateral: [PositionCollateral; 8],
        pub last_updated: u64,
        pub user_custom_margin_ratio: u32,
        pub margin_buffer: u32,
        pub margin_type: MarginRequirementType,
        pub user_high_leverage_mode: bool,
        pub user_pool_id: u8,
    }

    impl std::fmt::Debug for IncrementalMarginCalculation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let total_collateral_formatted =
                format!("{:.2}", self.total_collateral as f64 / 1_000_000.0);
            let margin_requirement_formatted =
                format!("{:.2}", self.margin_requirement as f64 / 1_000_000.0);

            let total_collateral_buffer_formatted =
                format!("{:.2}", self.total_collateral_buffer as f64 / 1_000_000.0);
            let margin_requirement_buffer_formatted = format!(
                "{:.2}",
                self.margin_requirement_plus_buffer as f64 / 1_000_000.0
            );

            f.debug_struct("CachedMarginCalculation")
                .field("total_collateral", &total_collateral_formatted)
                .field(
                    "total_collateral_buffer",
                    &total_collateral_buffer_formatted,
                )
                .field("margin_requirement", &margin_requirement_formatted)
                .field(
                    "margin_requirement_buffer",
                    &margin_requirement_buffer_formatted,
                )
                .field("margin_type", &self.margin_type)
                .field("user_high_leverage_mode", &self.user_high_leverage_mode)
                .field("user_custom_margin_ratio", &self.user_custom_margin_ratio)
                .field("last_updated", &self.last_updated)
                .finish()
        }
    }

    /// FFI-compatible position collateral contribution
    /// This struct must match the FFI-side struct exactly for proper alignment
    #[repr(C, align(16))]
    #[derive(Clone, Copy, Default)]
    pub struct PositionCollateral {
        pub collateral_value: i128,
        pub collateral_buffer: i128,
        pub liability_value: u128,
        pub liability_buffer: u128,
        pub last_updated: u64,
        pub market_index: u16,
    }

    impl std::fmt::Debug for PositionCollateral {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut fields = vec![format!("market_index: {}", self.market_index)];

            if self.collateral_value > 0 {
                let asset_formatted = format!("{:.2}", self.collateral_value as f64 / 1_000_000.0);
                fields.push(format!("+{}", asset_formatted));
            }

            if self.liability_value > 0 {
                let liability_formatted =
                    format!("{:.2}", self.liability_value as f64 / 1_000_000.0);
                fields.push(format!("-{}", liability_formatted));
            }

            if self.last_updated > 0 {
                fields.push(format!("last_updated: {}", self.last_updated));
            }

            write!(f, "PositionCollateral {{ {} }}", fields.join(", "))
        }
    }
}

#[cfg(test)]
mod tests {
    use anchor_lang::Discriminator;
    use solana_sdk::{account::Account, pubkey::Pubkey};

    use super::{
        margin_calculate_simplified_margin_requirement, simulate_place_perp_order, AccountWithKey,
        AccountsList, FfiResult, MarginContextMode,
    };
    use crate::{
        accounts::State,
        constants::{self, ids::pyth_program},
        create_account_info,
        drift_idl::{
            accounts::{PerpMarket, SpotMarket, User},
            types::{
                ContractType, MarginRequirementType, OracleSource, Order, OrderParams,
                OrderTriggerCondition, OrderType, PerpPosition, PostOnlyParam, SpotBalanceType,
                SpotPosition,
            },
        },
        ffi::{
            calculate_auction_price,
            calculate_margin_requirement_and_total_collateral_and_liability_info,
            check_ffi_version, get_oracle_price, IncrementalMarginCalculation, OraclePriceData,
        },
        math::constants::{
            BASE_PRECISION, BASE_PRECISION_I64, LIQUIDATION_FEE_PRECISION, MARGIN_PRECISION,
            PERCENTAGE_PRECISION, PRICE_PRECISION_I64, PRICE_PRECISION_U64, QUOTE_PRECISION,
            QUOTE_PRECISION_I64, SPOT_BALANCE_PRECISION, SPOT_BALANCE_PRECISION_U64,
            SPOT_CUMULATIVE_INTEREST_PRECISION, SPOT_WEIGHT_PRECISION,
        },
        types::{accounts::HighLeverageModeConfig, ContractTier, MarketType, ValidityGuardRails},
        utils::test_utils::{get_account_bytes, get_pyth_price},
        HistoricalOracleData, MarketStatus, PositionDirection, AMM,
    };

    fn sol_spot_market() -> SpotMarket {
        SpotMarket {
            market_index: 1,
            oracle_source: OracleSource::Pyth,
            oracle: solana_sdk::pubkey!("J83w4HKfqxwcq3BEMMkPFSppX3gqekLyLJBexebFVkix"),
            cumulative_deposit_interest: SPOT_CUMULATIVE_INTEREST_PRECISION.into(),
            cumulative_borrow_interest: SPOT_CUMULATIVE_INTEREST_PRECISION.into(),
            decimals: 9,
            initial_asset_weight: 8 * SPOT_WEIGHT_PRECISION / 10,
            maintenance_asset_weight: 9 * SPOT_WEIGHT_PRECISION / 10,
            initial_liability_weight: 12 * SPOT_WEIGHT_PRECISION / 10,
            maintenance_liability_weight: 11 * SPOT_WEIGHT_PRECISION / 10,
            liquidator_fee: LIQUIDATION_FEE_PRECISION / 1000,
            deposit_balance: (1_000 * SPOT_BALANCE_PRECISION).into(),
            order_step_size: 1_000,
            order_tick_size: 1_000,
            historical_oracle_data: HistoricalOracleData {
                last_oracle_price_twap5min: 240_000_000_000,
                ..Default::default()
            },
            ..Default::default()
        }
    }

    fn usdc_spot_market() -> SpotMarket {
        SpotMarket {
            market_index: 0,
            oracle_source: OracleSource::QuoteAsset,
            cumulative_deposit_interest: SPOT_CUMULATIVE_INTEREST_PRECISION.into(),
            decimals: 6,
            initial_asset_weight: SPOT_WEIGHT_PRECISION,
            maintenance_asset_weight: SPOT_WEIGHT_PRECISION,
            deposit_balance: (100_000 * SPOT_BALANCE_PRECISION).into(),
            liquidator_fee: 0,
            order_step_size: 1_000,
            order_tick_size: 1_000,
            historical_oracle_data: HistoricalOracleData {
                last_oracle_price_twap5min: 1_000_000,
                ..Default::default()
            },
            ..SpotMarket::default()
        }
    }

    #[test]
    fn ffi_check_version() {
        let drift_ffi_sys = include_str!("../drift-ffi-sys/Cargo.toml");
        let cargo_toml: toml::Value = drift_ffi_sys.parse().unwrap();
        let expected_version = cargo_toml["package"]["version"].as_str();
        assert_eq!(&check_ffi_version(), expected_version.unwrap());
    }

    #[test]
    fn ffi_deser_1_76_0_spot_market() {
        // smoke test for deserializing program data (where u128/i128 alignment is 8)
        let spot_market_borsh =
            hex::decode(include_str!("../../res/spot_market_1_76_0.hex")).unwrap();
        let actual: &SpotMarket = bytemuck::from_bytes::<SpotMarket>(&spot_market_borsh[8..]); // ignore dscriminator

        assert_eq!(actual, &sol_spot_market());
    }

    #[test]
    fn ffi_spot_position_is_available() {
        let spot_position = SpotPosition::default();
        assert!(spot_position.is_available());
    }

    #[test]
    fn ffi_spot_position_get_signed_token_amount() {
        let spot_position = SpotPosition {
            scaled_balance: (123 * SPOT_BALANCE_PRECISION) as u64,
            market_index: 1,
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };

        let result = spot_position.get_signed_token_amount(&sol_spot_market());
        assert_eq!(result.unwrap(), 123 * SPOT_BALANCE_PRECISION as i128);
    }

    #[test]
    fn ffi_spot_market_get_asset_weight() {
        let spot_market = SpotMarket {
            initial_asset_weight: 9_000,
            initial_liability_weight: 11_000,
            decimals: 6,
            imf_factor: 0,
            ..Default::default()
        };
        let size = 1_000 * QUOTE_PRECISION;
        let price = QUOTE_PRECISION as i64;
        let asset_weight = spot_market
            .get_asset_weight(size, price, MarginRequirementType::Initial)
            .unwrap();
        assert_eq!(asset_weight, 9_000);
    }

    #[test]
    fn ffi_spot_market_get_liability_weight() {
        let spot_market = SpotMarket {
            initial_asset_weight: 9_000,
            initial_liability_weight: 11_000,
            decimals: 6,
            imf_factor: 0,
            ..Default::default()
        };

        let size = 1_000 * QUOTE_PRECISION;
        let liability_weight = spot_market
            .get_liability_weight(size, MarginRequirementType::Initial)
            .unwrap();
        assert_eq!(liability_weight, 11_000);
    }

    #[test]
    fn ffi_user_get_spot_position() {
        let mut user = User::default();
        user.spot_positions[1] = SpotPosition {
            market_index: 1,
            scaled_balance: 1_000 * SPOT_BALANCE_PRECISION_U64,
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };

        let result = user.get_spot_position(1);
        assert!(result.is_ok());
        let spot_position = result.unwrap();
        assert_eq!(spot_position.market_index, 1);
        assert_eq!(
            spot_position.scaled_balance,
            1_000 * SPOT_BALANCE_PRECISION_U64
        );
        assert_eq!(spot_position.balance_type, SpotBalanceType::Deposit);

        // Test for non-existent market index
        let result = user.get_spot_position(5);
        assert!(result.is_err());
    }

    #[test]
    fn ffi_user_get_perp_position() {
        let mut user = User::default();
        user.perp_positions[2] = PerpPosition {
            market_index: 2,
            base_asset_amount: 500,
            quote_asset_amount: 1_000,
            lp_shares: 1_000,
            ..Default::default()
        };

        let result = user.get_perp_position(2);
        assert!(result.is_ok());
        let perp_position = result.unwrap();
        assert_eq!(perp_position.market_index, 2);
        assert_eq!(perp_position.base_asset_amount, 500);
        assert_eq!(perp_position.quote_asset_amount, 1_000);

        // Test for non-existent market index
        let result = user.get_perp_position(5);
        assert!(result.is_err());
    }

    #[test]
    fn ffi_perp_position_is_available() {
        let position = PerpPosition::default();
        assert!(position.is_available());

        let position = PerpPosition {
            base_asset_amount: 100,
            ..Default::default()
        };
        assert!(!position.is_available());
    }

    #[test]
    fn ffi_perp_position_is_open_position() {
        let position = PerpPosition::default();
        assert!(!position.is_open_position());

        let position = PerpPosition {
            base_asset_amount: 100,
            ..Default::default()
        };
        assert!(position.is_open_position());
    }

    #[test]
    fn ffi_perp_position_worst_case_base_asset_amount() {
        let position = PerpPosition {
            base_asset_amount: 1_000 * BASE_PRECISION_I64,
            quote_asset_amount: 5_000 * QUOTE_PRECISION_I64,
            market_index: 1,
            ..Default::default()
        };
        let oracle_price = 10 * QUOTE_PRECISION_I64;
        let contract_type = ContractType::Perpetual;

        let result = position.worst_case_base_asset_amount(oracle_price, contract_type);
        assert!(result.is_ok());
        let worst_case_amount = result.unwrap();
        assert!(worst_case_amount >= 1000); // The worst case should be at least the current base asset amount
    }

    #[test]
    fn ffi_get_oracle_price() {
        let oracle_pubkey = Pubkey::new_unique();
        let oracle_account = Account {
            data: get_account_bytes(&mut get_pyth_price(240, 9)).to_vec(),
            owner: constants::ids::pyth_program::ID,
            ..Default::default()
        };

        let oracle_source = OracleSource::Pyth;
        let slot = 12_345;

        let result = get_oracle_price(oracle_source, &mut (oracle_pubkey, oracle_account), slot);

        // Assert the result
        assert!(result.is_ok());
        let oracle_price_data = result.unwrap();

        dbg!(oracle_price_data.price);
        assert!(oracle_price_data.price == 240 * QUOTE_PRECISION as i64);
    }

    #[test]
    fn ffi_order_is_limit_order() {
        // Test a limit order
        for (order_type, is_limit) in [
            (OrderType::Limit, true),
            (OrderType::Market, false),
            (OrderType::TriggerLimit, true),
            (OrderType::TriggerMarket, false),
        ]
        .into_iter()
        {
            let limit_order = Order {
                order_type,
                slot: 100,
                ..Default::default()
            };
            let ffi_limit_order = limit_order;
            assert_eq!(ffi_limit_order.is_limit_order(), is_limit);
            assert_eq!(
                ffi_limit_order.is_resting_limit_order(100).unwrap(),
                is_limit
            );
        }
    }

    #[test]
    fn ffi_perp_market_get_mm_oracle_data_basic() {
        let perp_market = PerpMarket {
            market_index: 1,
            contract_tier: ContractTier::A,
            amm: AMM {
                mm_oracle_price: 1_000_123,
                mm_oracle_slot: 12345,
                ..Default::default()
            },
            ..Default::default()
        };
        let oracle_price_data = OraclePriceData {
            price: 1_000_000,
            confidence: 99 * PERCENTAGE_PRECISION as u64,
            delay: 2,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };
        let clock_slot = 12345;
        let validity_guard_rails = ValidityGuardRails::default();

        let result = perp_market.get_mm_oracle_price_data(
            oracle_price_data,
            clock_slot,
            &validity_guard_rails,
        );
        assert!(result.is_ok(), "Should succeed for valid input");
        let mm_oracle_data = result.unwrap();
        assert!(mm_oracle_data.safe_oracle_price_data.price > 0);
    }

    #[test]
    fn ffi_perp_market_fallback_price() {
        use crate::math::constants::{AMM_RESERVE_PRECISION, PEG_PRECISION};

        // Use properly scaled AMM values
        let default_reserves = 100 * AMM_RESERVE_PRECISION;
        let perp_market = PerpMarket {
            market_index: 1,
            contract_tier: ContractTier::A,
            amm: AMM {
                max_fill_reserve_fraction: 1,
                base_asset_reserve: default_reserves.into(),
                quote_asset_reserve: default_reserves.into(),
                sqrt_k: default_reserves.into(),
                peg_multiplier: PEG_PRECISION.into(),
                terminal_quote_asset_reserve: default_reserves.into(),
                concentration_coef: 5u128.into(),
                long_spread: 100,  // 1% spread
                short_spread: 100, // 1% spread
                max_base_asset_reserve: (u64::MAX as u128).into(),
                min_base_asset_reserve: 0u128.into(),
                order_step_size: 1,
                order_tick_size: 1,
                max_spread: 1000,
                historical_oracle_data: HistoricalOracleData {
                    last_oracle_price: crate::math::constants::PRICE_PRECISION_I64,
                    ..Default::default()
                },
                last_oracle_valid: true,
                ..Default::default()
            },
            ..Default::default()
        };
        let oracle_price = 10_000_000i64; // $10.00 with PRICE_PRECISION
        let seconds_til_expiry = 3600i64; // 1 hour

        // Test fallback price for Long direction (buying)
        let result_long =
            perp_market.fallback_price(PositionDirection::Long, oracle_price, seconds_til_expiry);
        assert!(result_long.is_ok(), "Should succeed for Long direction");
        let fallback_price_long = result_long.unwrap();
        assert!(fallback_price_long > 0, "Fallback price should be positive");

        // Test fallback price for Short direction (selling)
        let result_short =
            perp_market.fallback_price(PositionDirection::Short, oracle_price, seconds_til_expiry);
        assert!(result_short.is_ok(), "Should succeed for Short direction");
        let fallback_price_short = result_short.unwrap();
        assert!(
            fallback_price_short > 0,
            "Fallback price should be positive"
        );

        // For Long (buying), fallback price should typically be higher than oracle (ask price)
        // For Short (selling), fallback price should typically be lower than oracle (bid price)
        // Note: This depends on AMM state, but generally holds true
        assert!(
            fallback_price_long >= fallback_price_short,
            "Long fallback price should be >= Short fallback price"
        );
    }

    #[test]
    fn ffi_perp_market_get_margin_ratio() {
        let perp_market = PerpMarket {
            margin_ratio_initial: 1_000 * MARGIN_PRECISION, // 10%
            margin_ratio_maintenance: 500,                  // 5%
            imf_factor: 0,                                  // No impact for simplicity
            // enable HL mode for this market
            high_leverage_margin_ratio_maintenance: 1_234,
            high_leverage_margin_ratio_initial: 4_321,
            ..Default::default()
        };

        let size = 1_000 * MARGIN_PRECISION as u128; // Assuming MARGIN_PRECISION is defined

        // Test initial margin ratio
        let result = perp_market.get_margin_ratio(size, MarginRequirementType::Initial, false);
        assert!(result.is_ok());
        let initial_margin_ratio = result.unwrap();
        assert_eq!(initial_margin_ratio, 1_000 * MARGIN_PRECISION); // 10%

        // Test maintenance margin ratio
        let result = perp_market.get_margin_ratio(size, MarginRequirementType::Maintenance, false);
        assert!(result.is_ok());
        let maintenance_margin_ratio = result.unwrap();
        assert_eq!(maintenance_margin_ratio, 500); // 5%

        // HL mode
        let result = perp_market.get_margin_ratio(size, MarginRequirementType::Maintenance, true);
        assert!(result.is_ok());
        let maintenance_margin_ratio = result.unwrap();
        assert_eq!(maintenance_margin_ratio, 1_234); // 5%
    }

    #[test]
    fn ffi_order_params_update_perp_auction_params_populates_fields() {
        let market_index = 3u16;
        // PerpMarket with non-zero AMM fields to exercise FFI struct layout
        let perp_market = PerpMarket {
            market_index,
            status: MarketStatus::Active,
            contract_tier: ContractTier::A,
            amm: AMM {
                order_step_size: 2_000,
                order_tick_size: 1_000,
                base_asset_reserve: 10_000u128.into(),
                quote_asset_reserve: 20_000u128.into(),
                sqrt_k: 100u128.into(),
                peg_multiplier: 1_000_000u128.into(),
                terminal_quote_asset_reserve: 19_000u128.into(),
                concentration_coef: 5u128.into(),
                max_open_interest: 1_000_000u128.into(),
                mm_oracle_price: 1_234_567,
                mm_oracle_slot: 9_999,
                ..Default::default()
            },
            ..Default::default()
        };

        // Start with empty auction params and let program fill them
        let mut params = OrderParams {
            order_type: OrderType::Limit,
            market_type: MarketType::Perp,
            direction: PositionDirection::Short,
            user_order_id: 7,
            base_asset_amount: 50_000,
            price: 200_000,
            market_index,
            reduce_only: false,
            post_only: PostOnlyParam::None,
            bit_flags: 0,
            max_ts: None,
            trigger_price: None,
            trigger_condition: OrderTriggerCondition::Below,
            oracle_price_offset: None,
            auction_duration: None,
            auction_start_price: None,
            auction_end_price: None,
        };

        // Call through FFI
        let oracle_price = 199_500i64;

        // Debug: Check AMM fields before FFI call
        eprintln!("Before FFI call - AMM fields:");
        eprintln!("  mm_oracle_price: {}", perp_market.amm.mm_oracle_price);
        eprintln!("  order_step_size: {}", perp_market.amm.order_step_size);
        eprintln!("  order_tick_size: {}", perp_market.amm.order_tick_size);
        eprintln!(
            "  base_asset_reserve: {:?}",
            perp_market.amm.base_asset_reserve.as_u128()
        );
        eprintln!(
            "  quote_asset_reserve: {:?}",
            perp_market.amm.quote_asset_reserve.as_u128()
        );

        params.update_perp_auction_params(&perp_market, oracle_price, true);

        // Debug: Check if auction params were populated
        eprintln!("After FFI call - auction params:");
        eprintln!("  auction_duration: {:?}", params.auction_duration);
        eprintln!("  auction_start_price: {:?}", params.auction_start_price);
        eprintln!("  auction_end_price: {:?}", params.auction_end_price);

        // Expect auction params to be populated and non-zero
        assert!(params.auction_duration.is_some());
        assert!(params.auction_start_price.is_some());
        assert!(params.auction_end_price.is_some());

        let dur = params.auction_duration.unwrap();
        let start = params.auction_start_price.unwrap();
        let end = params.auction_end_price.unwrap();
        assert!(dur > 0);
        assert!(start != 0);
        assert!(end != 0);
    }

    #[test]
    fn ffi_order_params_update_perp_auction_params_reads_amm_fields() {
        let market_index = 4u16;

        let perp_market_a = PerpMarket {
            market_index,
            status: MarketStatus::Active,
            contract_tier: ContractTier::A,
            amm: AMM {
                order_step_size: 1_000,
                order_tick_size: 1_000,
                base_asset_reserve: 50_000u128.into(),
                quote_asset_reserve: 80_000u128.into(),
                sqrt_k: 200u128.into(),
                peg_multiplier: 1_100_000u128.into(),
                terminal_quote_asset_reserve: 79_000u128.into(),
                concentration_coef: 7u128.into(),
                max_open_interest: 2_000_000u128.into(),
                mm_oracle_price: 2_222_222,
                mm_oracle_slot: 10_001,
                ..Default::default()
            },
            ..Default::default()
        };

        let perp_market_b = PerpMarket {
            market_index,
            status: MarketStatus::Active,
            contract_tier: ContractTier::A,
            amm: AMM {
                order_step_size: 8_000, // different
                order_tick_size: 4_000, // different
                base_asset_reserve: 60_000u128.into(),
                quote_asset_reserve: 90_000u128.into(),
                sqrt_k: 250u128.into(),
                peg_multiplier: 900_000u128.into(),
                terminal_quote_asset_reserve: 88_000u128.into(),
                concentration_coef: 9u128.into(),
                max_open_interest: 3_000_000u128.into(),
                mm_oracle_price: 3_333_333,
                mm_oracle_slot: 10_005,
                ..Default::default()
            },
            ..Default::default()
        };

        let base_params = || OrderParams {
            order_type: OrderType::Limit,
            market_type: MarketType::Perp,
            direction: PositionDirection::Short,
            user_order_id: 8,
            base_asset_amount: 50_000,
            price: 200_000,
            market_index,
            reduce_only: false,
            post_only: PostOnlyParam::None,
            bit_flags: 0,
            max_ts: None,
            trigger_price: None,
            trigger_condition: OrderTriggerCondition::Below,
            oracle_price_offset: None,
            auction_duration: None,
            auction_start_price: None,
            auction_end_price: None,
        };

        let oracle_price = 199_500i64;

        // Debug: Check AMM fields before FFI calls
        eprintln!("Before FFI calls - AMM fields:");
        eprintln!(
            "  Market A - mm_oracle_price: {}, order_step_size: {}",
            perp_market_a.amm.mm_oracle_price, perp_market_a.amm.order_step_size
        );
        eprintln!(
            "  Market B - mm_oracle_price: {}, order_step_size: {}",
            perp_market_b.amm.mm_oracle_price, perp_market_b.amm.order_step_size
        );

        let mut a = base_params();
        a.update_perp_auction_params(&perp_market_a, oracle_price, false);

        let mut b = base_params();
        b.update_perp_auction_params(&perp_market_b, oracle_price, false);

        // Debug: Check results
        eprintln!("After FFI calls:");
        eprintln!(
            "  Market A - auction_duration: {:?}, auction_start_price: {:?}",
            a.auction_duration, a.auction_start_price
        );
        eprintln!(
            "  Market B - auction_duration: {:?}, auction_start_price: {:?}",
            b.auction_duration, b.auction_start_price
        );

        // If AMM fields are read correctly across FFI, results should differ
        assert!(a.auction_duration.is_some() && b.auction_duration.is_some());
        assert!(a.auction_start_price.is_some() && b.auction_start_price.is_some());
        assert!(a.auction_end_price.is_some() && b.auction_end_price.is_some());

        let a_tuple = (
            a.auction_duration.unwrap(),
            a.auction_start_price.unwrap(),
            a.auction_end_price.unwrap(),
        );
        let b_tuple = (
            b.auction_duration.unwrap(),
            b.auction_start_price.unwrap(),
            b.auction_end_price.unwrap(),
        );
        assert_ne!(
            a_tuple, b_tuple,
            "auction params should reflect differing AMM fields"
        );
    }

    #[test]
    fn ffi_test_calculate_margin_requirement_and_total_collateral_and_liability_info() {
        // smoke test for ffi compatibility, logic tested in `math::` module
        let btc_perp_index = 1_u16;
        let mut user = User::default();
        user.spot_positions[1] = SpotPosition {
            market_index: 1,
            scaled_balance: (1_000 * SPOT_BALANCE_PRECISION) as u64,
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };
        user.perp_positions[0] = PerpPosition {
            market_index: btc_perp_index,
            base_asset_amount: 100 * BASE_PRECISION_I64 as i64,
            quote_asset_amount: -5_000 * QUOTE_PRECISION as i64,
            ..Default::default()
        };

        // Create mock accounts
        let mut perp_markets = vec![AccountWithKey {
            key: Pubkey::new_unique(),
            account: Account {
                owner: crate::constants::PROGRAM_ID,
                data: [
                    PerpMarket::DISCRIMINATOR,
                    bytemuck::bytes_of(&PerpMarket {
                        market_index: btc_perp_index,
                        ..Default::default()
                    }),
                ]
                .concat()
                .to_vec(),
                ..Default::default()
            },
        }];
        // Set up both USDC and SOL spot markets
        let usdc_spot_market = usdc_spot_market();
        let sol_spot_market = sol_spot_market();
        let mut spot_markets = vec![
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        SpotMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&usdc_spot_market),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        SpotMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&sol_spot_market),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
        ];

        // Set up oracles for both markets
        // USDC oracle (market index 0) - using quote asset oracle
        let usdc_oracle = AccountWithKey {
            key: usdc_spot_market.oracle,
            account: Account {
                data: get_account_bytes(&mut get_pyth_price(1, 6)).to_vec(), // 1 USD
                owner: constants::ids::pyth_program::ID,
                ..Default::default()
            },
        };

        // SOL oracle (market index 1) - using the specific oracle pubkey
        let sol_oracle = AccountWithKey {
            key: sol_spot_market.oracle,
            account: Account {
                data: get_account_bytes(&mut get_pyth_price(240, 9)).to_vec(),
                owner: constants::ids::pyth_program::ID,
                ..Default::default()
            },
        };

        let mut oracles = [usdc_oracle, sol_oracle];
        let mut accounts = AccountsList::new(&mut perp_markets, &mut spot_markets, &mut oracles);

        let modes = [
            MarginContextMode::StandardMaintenance,
            MarginContextMode::StandardInitial,
            MarginContextMode::StandardCustom(MarginRequirementType::Initial),
        ];

        // no panics is enough
        for mode in modes.iter() {
            let _ = calculate_margin_requirement_and_total_collateral_and_liability_info(
                &user,
                &mut accounts,
                *mode,
            );
        }
    }

    #[test]
    fn ffi_simulate_place_perp_order() {
        // smoke test for ffi compatibility, logic tested in `math::` module
        let btc_perp_index = 1_u16;
        let mut user = User::default();
        user.spot_positions[1] = SpotPosition {
            market_index: 1,
            scaled_balance: (1_000 * SPOT_BALANCE_PRECISION) as u64,
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };
        user.perp_positions[0] = PerpPosition {
            market_index: btc_perp_index,
            base_asset_amount: 100 * BASE_PRECISION_I64 as i64,
            quote_asset_amount: -5_000 * QUOTE_PRECISION as i64,
            ..Default::default()
        };
        user.perp_positions[1] = PerpPosition {
            market_index: 0,
            base_asset_amount: 100 * BASE_PRECISION_I64 as i64,
            quote_asset_amount: -5_000 * QUOTE_PRECISION as i64,
            ..Default::default()
        };

        // Create mock accounts
        let mut perp_markets = vec![
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        PerpMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&PerpMarket {
                            market_index: btc_perp_index,
                            status: MarketStatus::Active,
                            amm: AMM {
                                order_step_size: 1_000,
                                order_tick_size: 1_000,
                                ..Default::default()
                            },
                            ..Default::default()
                        }),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        PerpMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&PerpMarket {
                            market_index: 0,
                            status: MarketStatus::Active,
                            amm: AMM {
                                order_step_size: 1_000,
                                order_tick_size: 1_000,
                                ..Default::default()
                            },
                            ..Default::default()
                        }),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
        ];
        let mut spot_markets = vec![
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        SpotMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&sol_spot_market()),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        SpotMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&usdc_spot_market()),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
        ];

        create_account_info!(
            get_pyth_price(240, 9),
            &sol_spot_market().oracle,
            pyth_program::ID,
            sol_oracle
        );
        create_account_info!(
            get_pyth_price(1, 6),
            &usdc_spot_market().oracle,
            pyth_program::ID,
            usdc_oracle
        );

        let mut oracles = [sol_oracle, usdc_oracle];
        let mut accounts = AccountsList::new(&mut perp_markets, &mut spot_markets, &mut oracles);

        let res = simulate_place_perp_order(
            &mut user,
            &mut accounts,
            &State::default(),
            &OrderParams {
                market_index: 1,
                market_type: MarketType::Perp,
                direction: PositionDirection::Short,
                base_asset_amount: 123 * BASE_PRECISION as u64,
                order_type: OrderType::Market,
                ..Default::default()
            },
            None,
            None,
            &mut None,
        );
        assert!(res.is_ok_and(|truthy| truthy));

        let res = simulate_place_perp_order(
            &mut user,
            &mut accounts,
            &State::default(),
            &OrderParams {
                market_index: 1,
                market_type: MarketType::Perp,
                direction: PositionDirection::Short,
                base_asset_amount: 1_234 * BASE_PRECISION as u64,
                order_type: OrderType::Market,
                bit_flags: 0b0000_0010,
                ..Default::default()
            },
            Some(&mut HighLeverageModeConfig {
                max_users: 5,
                current_users: 2,
                reduce_only: 0,
                padding1: Default::default(),
                current_maintenance_users: 0,
                padding2: Default::default(),
            }),
            None,
            &mut None,
        );
        dbg!(&res);
        assert!(res.is_ok_and(|truthy| truthy));
    }

    #[test]
    fn ffi_simulate_place_perp_order_with_max_margin_ratio() {
        // smoke test for ffi compatibility, logic tested in `math::` module
        let btc_perp_index = 1_u16;
        let mut user = User::default();
        user.spot_positions[1] = SpotPosition {
            market_index: 1,
            scaled_balance: (1_000 * SPOT_BALANCE_PRECISION) as u64,
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };
        user.perp_positions[0] = PerpPosition {
            market_index: btc_perp_index,
            base_asset_amount: 100 * BASE_PRECISION_I64 as i64,
            quote_asset_amount: -5_000 * QUOTE_PRECISION as i64,
            ..Default::default()
        };
        user.perp_positions[1] = PerpPosition {
            market_index: 0,
            base_asset_amount: 100 * BASE_PRECISION_I64 as i64,
            quote_asset_amount: -5_000 * QUOTE_PRECISION as i64,
            ..Default::default()
        };

        // Create mock accounts
        let mut perp_markets = vec![
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        PerpMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&PerpMarket {
                            market_index: btc_perp_index,
                            status: MarketStatus::Active,
                            amm: AMM {
                                order_step_size: 1_000,
                                order_tick_size: 1_000,
                                ..Default::default()
                            },
                            ..Default::default()
                        }),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        PerpMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&PerpMarket {
                            market_index: 0,
                            status: MarketStatus::Active,
                            amm: AMM {
                                order_step_size: 1_000,
                                order_tick_size: 1_000,
                                ..Default::default()
                            },
                            ..Default::default()
                        }),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
        ];
        let mut spot_markets = vec![
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        SpotMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&sol_spot_market()),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
            AccountWithKey {
                key: Pubkey::new_unique(),
                account: Account {
                    owner: crate::constants::PROGRAM_ID,
                    data: [
                        SpotMarket::DISCRIMINATOR,
                        bytemuck::bytes_of(&usdc_spot_market()),
                    ]
                    .concat()
                    .to_vec(),
                    ..Default::default()
                },
            },
        ];

        create_account_info!(
            get_pyth_price(240, 9),
            &sol_spot_market().oracle,
            pyth_program::ID,
            sol_oracle
        );
        create_account_info!(
            get_pyth_price(1, 6),
            &usdc_spot_market().oracle,
            pyth_program::ID,
            usdc_oracle
        );

        let mut oracles = [sol_oracle, usdc_oracle];
        let mut accounts = AccountsList::new(&mut perp_markets, &mut spot_markets, &mut oracles);

        let res = simulate_place_perp_order(
            &mut user,
            &mut accounts,
            &State::default(),
            &OrderParams {
                market_index: 1,
                market_type: MarketType::Perp,
                direction: PositionDirection::Short,
                base_asset_amount: 123 * BASE_PRECISION as u64,
                order_type: OrderType::Market,
                ..Default::default()
            },
            None,
            Some(2),
            &mut None,
        );
        assert!(res.is_ok_and(|truthy| truthy));

        let res: Result<bool, crate::types::SdkError> = simulate_place_perp_order(
            &mut user,
            &mut accounts,
            &State::default(),
            &OrderParams {
                market_index: 1,
                market_type: MarketType::Perp,
                direction: PositionDirection::Short,
                base_asset_amount: 1_234 * BASE_PRECISION as u64,
                order_type: OrderType::Market,
                bit_flags: 0b0000_0010,
                ..Default::default()
            },
            Some(&mut HighLeverageModeConfig {
                max_users: 5,
                current_users: 2,
                reduce_only: 0,
                padding1: Default::default(),
                current_maintenance_users: 0,
                padding2: Default::default(),
            }),
            None,
            &mut None,
        );
        dbg!(&res);
        assert!(res.is_ok_and(|truthy| truthy));
    }

    #[test]
    fn ffi_calculate_auction_price() {
        let price = calculate_auction_price(
            &Order {
                price: 123_456,
                order_type: OrderType::Limit,
                direction: PositionDirection::Long,
                ..Default::default()
            },
            0,
            1_000,
            None,
            false,
        );
        assert_eq!(price.unwrap(), 0,);

        let price = calculate_auction_price(
            &Order {
                slot: 1,
                auction_duration: 10,
                auction_start_price: 90 * PRICE_PRECISION_I64,
                auction_end_price: 100 * PRICE_PRECISION_I64,
                oracle_price_offset: 555,
                order_type: OrderType::Oracle,
                direction: PositionDirection::Long,
                ..Default::default()
            },
            5,
            3,
            Some(100 * PRICE_PRECISION_I64),
            false,
        );
        assert!(price.is_ok_and(|p| p > 0));
    }

    #[test]
    fn ffi_order_get_limit_price() {
        let tick_size = 1_000;
        let oracle_price = Some(100 * PRICE_PRECISION_I64);
        let fallback_price = Some(95 * PRICE_PRECISION_U64);
        let slot = 100;

        // Test cases
        let cases = [
            // Case 1: Basic limit order with price
            (
                Order {
                    price: 95 * PRICE_PRECISION_U64,
                    order_type: OrderType::Limit,
                    direction: PositionDirection::Long,
                    ..Default::default()
                },
                "Basic limit order",
            ),
            // Case 2: Order with auction parameters
            (
                Order {
                    slot: 90,
                    auction_duration: 20,
                    auction_start_price: 90 * PRICE_PRECISION_I64,
                    auction_end_price: 100 * PRICE_PRECISION_I64,
                    order_type: OrderType::Limit,
                    direction: PositionDirection::Long,
                    ..Default::default()
                },
                "Order with auction parameters",
            ),
            // Case 3: Order with oracle price offset
            (
                Order {
                    oracle_price_offset: 5 * PRICE_PRECISION_I64 as i32,
                    order_type: OrderType::Limit,
                    direction: PositionDirection::Long,
                    ..Default::default()
                },
                "Order with oracle price offset",
            ),
            // Case 4: Order with zero price and fallback
            (
                Order {
                    price: 0,
                    order_type: OrderType::Limit,
                    direction: PositionDirection::Long,
                    ..Default::default()
                },
                "Order with zero price and fallback",
            ),
        ];

        for (order, case_name) in cases {
            let result = order
                .get_limit_price(oracle_price, fallback_price, slot, tick_size, false, None)
                .unwrap();
            assert!(result.is_some(), "{} should return a price", case_name);
            let price = result.unwrap();
            assert!(price > 0, "{} should return a positive price", case_name);
        }
    }

    #[test]
    fn ffi_perp_market_get_protected_maker_params() {
        let perp_market = PerpMarket {
            protected_maker_limit_price_divisor: 100,
            protected_maker_dynamic_divisor: 2,
            amm: AMM {
                oracle_std: 10_000,
                mark_std: 5_000,
                order_tick_size: 1_000,
                ..Default::default()
            },
            ..Default::default()
        };

        let params = perp_market.get_protected_maker_params();

        // Verify the structure matches what we expect
        assert_eq!(params.limit_price_divisor, 100);
        assert_eq!(params.dynamic_offset, 5_000); // max(10_000, 5_000) / 2
        assert_eq!(params.tick_size, 1_000);
    }

    #[test]
    fn ffi_calculate_auction_params_for_trigger_order() {
        use crate::{
            drift_idl::{
                accounts::PerpMarket,
                types::{Order, OrderType, PositionDirection},
            },
            ffi::{abi_types::OraclePriceData, calculate_auction_params_for_trigger_order},
        };
        let order = Order {
            order_type: OrderType::TriggerMarket,
            direction: PositionDirection::Long,
            slot: 1,
            auction_duration: 10,
            auction_start_price: 90_000,
            auction_end_price: 100_000,
            market_index: 0,
            market_type: MarketType::Perp,
            ..Default::default()
        };
        let oracle_price = OraclePriceData {
            price: 2 * PRICE_PRECISION_I64,
            confidence: 100,
            delay: 0,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };
        let perp_market = PerpMarket {
            contract_tier: ContractTier::A,
            market_index: 0,
            ..Default::default()
        };
        let result =
            calculate_auction_params_for_trigger_order(&order, &oracle_price, Some(&perp_market));
        assert!(result.is_ok(), "FFI call should succeed");
        let (duration, start, end) = result.unwrap();
        assert_eq!(duration, 20);
        assert!(start > 0);
        assert!(end > 0);
    }

    #[test]
    fn ffi_test_calculate_simplified_margin_requirement() {
        // Test the simplified margin requirement FFI function
        // This should match the results from the existing margin calculation test
        let btc_perp_index = 1_u16;
        let mut user = User::default();
        user.spot_positions[1] = SpotPosition {
            market_index: 1,
            scaled_balance: (1_000 * SPOT_BALANCE_PRECISION) as u64,
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };
        user.perp_positions[0] = PerpPosition {
            market_index: btc_perp_index,
            base_asset_amount: 100 * BASE_PRECISION_I64 as i64,
            quote_asset_amount: -5_000 * QUOTE_PRECISION as i64,
            ..Default::default()
        };

        // Create market state data similar to the existing test
        let mut market_state_data = crate::market_state::MarketStateData::default();

        // Add USDC spot market (market index 0) - required for quote asset
        let usdc_spot_market = usdc_spot_market();
        market_state_data.set_spot_market(usdc_spot_market);

        // Add SOL spot market (market index 1)
        let sol_spot_market = sol_spot_market();
        market_state_data.set_spot_market(sol_spot_market);

        // Add perp market with proper configuration
        let perp_market = PerpMarket {
            market_index: btc_perp_index,
            margin_ratio_initial: 1_000 * MARGIN_PRECISION, // 10%
            margin_ratio_maintenance: 500,                  // 5%
            amm: AMM {
                ..Default::default()
            },
            ..Default::default()
        };
        market_state_data.set_perp_market(perp_market);

        // Add oracle prices
        let sol_oracle_price = OraclePriceData {
            price: 240 * QUOTE_PRECISION as i64,
            confidence: 99 * PERCENTAGE_PRECISION as u64,
            delay: 2,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };

        // Add oracle prices
        let btc_oracle_price = OraclePriceData {
            price: 120_000 * QUOTE_PRECISION as i64,
            confidence: 99 * PERCENTAGE_PRECISION as u64,
            delay: 2,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };

        // USDC oracle price (market index 0) - required for quote asset
        let usdc_oracle_price = OraclePriceData {
            price: QUOTE_PRECISION as i64, // 1 USD
            confidence: 1,
            delay: 0,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };

        market_state_data.set_spot_oracle_price(0, usdc_oracle_price); // USDC
        market_state_data.set_spot_oracle_price(1, sol_oracle_price); // SOL
        market_state_data.set_perp_oracle_price(btc_perp_index, btc_oracle_price);

        // Test different margin requirement types
        let margin_types = [
            MarginRequirementType::Initial,
            MarginRequirementType::Maintenance,
        ];

        for margin_type in margin_types.iter() {
            let result = unsafe {
                margin_calculate_simplified_margin_requirement(
                    &user,
                    &market_state_data,
                    *margin_type,
                    0,
                )
            };

            // Verify the FFI call succeeds
            assert!(
                matches!(result, FfiResult::ROk(_)),
                "FFI call should succeed for margin type: {:?}",
                margin_type
            );

            let result = match result {
                FfiResult::ROk(data) => data,
                FfiResult::RErr(_) => panic!("FFI call failed for margin type: {:?}", margin_type),
            };

            // Verify we get reasonable values
            assert!(
                result.total_collateral != 0,
                "Total collateral should not be zero for margin type: {:?}",
                margin_type
            );
            assert!(
                result.margin_requirement > 0,
                "Margin requirement should be positive for margin type: {:?}",
                margin_type
            );
        }
    }

    #[test]
    fn ffi_test_incremental_margin_calculation() {
        // Test the cached margin calculation FFI functions
        let btc_perp_index = 1_u16;
        let mut user = User::default();
        user.spot_positions[1] = SpotPosition {
            market_index: 1,
            scaled_balance: (100 * SPOT_BALANCE_PRECISION) as u64, // Smaller amount to avoid overflow
            balance_type: SpotBalanceType::Deposit,
            ..Default::default()
        };
        user.perp_positions[0] = PerpPosition {
            market_index: btc_perp_index,
            base_asset_amount: 10 * BASE_PRECISION_I64 as i64, // Smaller amount
            quote_asset_amount: -500 * QUOTE_PRECISION as i64, // Smaller amount
            ..Default::default()
        };

        // Create market state data
        let market_state = crate::market_state::MarketState::default();

        // Add USDC spot market (market index 0) - required for quote asset
        let usdc_spot_market = usdc_spot_market();
        market_state.set_spot_market(usdc_spot_market);

        // Add SOL spot market (market index 1)
        let sol_spot_market = sol_spot_market();
        market_state.set_spot_market(sol_spot_market);

        // Add perp market with proper configuration
        let perp_market = PerpMarket {
            market_index: btc_perp_index,
            margin_ratio_initial: 1_000 * MARGIN_PRECISION, // 10%
            margin_ratio_maintenance: 500,                  // 5%
            amm: AMM {
                ..Default::default()
            },
            ..Default::default()
        };
        market_state.set_perp_market(perp_market);

        // Add oracle prices
        let sol_oracle_price = OraclePriceData {
            price: 240 * QUOTE_PRECISION as i64,
            confidence: 99 * PERCENTAGE_PRECISION as u64,
            delay: 2,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };

        let btc_oracle_price = OraclePriceData {
            price: 120_000 * QUOTE_PRECISION as i64,
            confidence: 99 * PERCENTAGE_PRECISION as u64,
            delay: 2,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };

        // USDC oracle price (market index 0) - required for quote asset
        let usdc_oracle_price = OraclePriceData {
            price: QUOTE_PRECISION as i64, // 1 USD
            confidence: 1,
            delay: 0,
            has_sufficient_number_of_data_points: true,
            sequence_id: None,
        };

        market_state.set_spot_oracle_price(0, usdc_oracle_price); // USDC
        market_state.set_spot_oracle_price(1, sol_oracle_price); // SOL
        market_state.set_perp_oracle_price(btc_perp_index, btc_oracle_price);

        let timestamp = 1_000_000;

        // Test different margin requirement types
        let margin_types = [MarginRequirementType::Maintenance];

        for margin_type in margin_types.iter() {
            // Test 1: Create cached margin calculation from user using FFI
            let mut calculator = IncrementalMarginCalculation::from_user(
                &user,
                &market_state,
                *margin_type,
                timestamp,
                None,
            );

            // Verify we get reasonable initial values
            assert!(
                calculator.total_collateral != 0,
                "Total collateral should not be zero for margin type: {:?}",
                margin_type
            );

            // Test 2: Update spot position using FFI
            let mut updated_spot_position = user.spot_positions[1].clone();
            updated_spot_position.scaled_balance = (200 * SPOT_BALANCE_PRECISION) as u64; // Double the balance

            let free_collateral_before = calculator.free_collateral();
            calculator.update_spot_position(&updated_spot_position, &market_state, timestamp + 1);

            // Verify the update affected the calculation
            assert!(
                calculator.free_collateral() != free_collateral_before,
                "free collateral should change after perp position update"
            );
            // The FFI function should have been called (values might not change due to implementation)
            // Just verify the function completed without error

            // Test 3: Update perp position using FFI
            let mut updated_perp_position = user.perp_positions[0].clone();
            updated_perp_position.base_asset_amount = 20 * BASE_PRECISION_I64 as i64; // Double the position

            calculator.update_perp_position(&updated_perp_position, &market_state, timestamp + 2);

            dbg!(&calculator);

            assert!(
                calculator.free_collateral() != free_collateral_before,
                "free collateral should change after perp position update"
            );

            // Verify the update affected the calculation
            assert!(
                calculator.total_collateral != 0,
                "Total collateral should still be non-zero after perp position update"
            );
            // The FFI function should have been called (values might not change due to implementation)
            // Just verify the function completed without error

            // Test 5: Verify metadata is accessible (FFI might not preserve margin type exactly)
            assert!(
                calculator.margin_type == *margin_type,
                "Margin type should match the input: expected {:?}, got {:?}",
                margin_type,
                calculator.margin_type
            );

            // Test 6: Verify other fields are accessible
            // Note: Free collateral can be negative if margin requirement exceeds total collateral
            assert!(
                calculator.free_collateral() != 0 || calculator.total_collateral == 0,
                "Free collateral should be calculated correctly"
            );
        }
    }
}

// Simplified Margin Calculation FFI declarations
extern "C" {
    #[allow(improper_ctypes)]
    pub fn margin_calculate_simplified_margin_requirement(
        user: &accounts::User,
        market_state: &crate::market_state::MarketStateData,
        margin_type: MarginRequirementType,
        margin_buffer: u32,
    ) -> FfiResult<SimplifiedMarginCalculation>;

    // Cached Margin Calculation FFI declarations
    #[allow(improper_ctypes)]
    pub fn incremental_margin_calculation_from_user(
        user: &accounts::User,
        market_state: &crate::market_state::MarketStateData,
        margin_type: MarginRequirementType,
        timestamp: u64,
        margin_buffer: u32,
    ) -> IncrementalMarginCalculation;

    #[allow(improper_ctypes)]
    pub fn incremental_margin_calculation_update_spot_position(
        cached: &mut IncrementalMarginCalculation,
        spot_position: &types::SpotPosition,
        market_state: &crate::market_state::MarketStateData,
        timestamp: u64,
    );

    #[allow(improper_ctypes)]
    pub fn incremental_margin_calculation_update_perp_position(
        cached: &mut IncrementalMarginCalculation,
        perp_position: &types::PerpPosition,
        market_state: &crate::market_state::MarketStateData,
        timestamp: u64,
    );
}

```

## File: crates/src/grpc/grpc_subscriber.rs
```
use std::{collections::HashMap, time::Duration};

use ahash::HashSet;
use futures_util::{
    sink::SinkExt,
    stream::{FuturesUnordered, StreamExt},
};
use log::{error, info, warn};
use solana_rpc_client_api::filter::Memcmp;
use solana_sdk::{clock::Slot, commitment_config::CommitmentLevel, pubkey::Pubkey};
use yellowstone_grpc_client::{
    ClientTlsConfig, GeyserGrpcBuilderError, GeyserGrpcClient, GeyserGrpcClientError, Interceptor,
};
use yellowstone_grpc_proto::{
    geyser::{
        CommitmentLevel as GeyserCommitmentLevel, SubscribeRequestFilterBlocksMeta,
        SubscribeUpdateAccountInfo, SubscribeUpdateBlockMeta,
    },
    prelude::{
        subscribe_request_filter_accounts_filter::Filter as AccountsFilterOneof,
        subscribe_request_filter_accounts_filter_memcmp::Data as AccountsFilterMemcmpOneof,
        subscribe_update::UpdateOneof, SubscribeRequest, SubscribeRequestFilterAccounts,
        SubscribeRequestFilterAccountsFilter, SubscribeRequestFilterAccountsFilterMemcmp,
        SubscribeRequestFilterSlots, SubscribeRequestFilterTransactions, SubscribeRequestPing,
    },
    tonic::{transport::Certificate, Status},
};

use crate::types::UnsubHandle;

use super::{AccountUpdate, OnAccountFn, OnTransactionFn, TransactionUpdate};

type SlotsFilterMap = HashMap<String, SubscribeRequestFilterSlots>;
type AccountFilterMap = HashMap<String, SubscribeRequestFilterAccounts>;
type TransactionFilterMap = HashMap<String, SubscribeRequestFilterTransactions>;
type Hooks = Vec<(AccountFilter, Box<OnAccountFn>)>;
type TransactionHooks = Vec<Box<OnTransactionFn>>;

/// Provides filter criteria for accounts over gRPC
///
/// There are two filter modes:
///
/// * `full` - requires all filters to trigger a match
/// * `partial` - any one filter will trigger a match
///
/// ```example(no_run)
/// // match on discriminator AND memcmp
///  let full = AccountFilter::full()
///     .with_discriminator(User::DISCRIMINATOR)
///     .with_memcmp(..);
///
/// // match on discriminator OR accounts
/// let partial = AccountFilter::partial()
///     .with_discriminator(User::DISCRIMINATOR)
///     .with_accounts([acc1,acc2])
/// ```
#[derive(Clone, Default, Debug)]
pub struct AccountFilter {
    /// optionally filter updates by discriminator
    discriminator: Option<&'static [u8]>,
    /// optionally filter updates by Solana Memcmp matches
    memcmp: Option<Memcmp>,
    /// optionally filter updates by pubkey
    accounts: Option<HashSet<Pubkey>>,
    /// true = full match mode, false = partial
    is_full: bool,
}

impl AccountFilter {
    /// Create a filter that matches ALL accounts!
    pub fn firehose() -> Self {
        AccountFilter::full()
    }
    /// Create a filter that matches iff all parameters are satisfied
    pub fn full() -> Self {
        AccountFilter {
            is_full: true,
            ..Default::default()
        }
    }
    /// Create a filter that matches when any criteria is satisfied
    pub fn partial() -> Self {
        AccountFilter {
            is_full: false,
            ..Default::default()
        }
    }
    /// add filter for given `pubkeys`
    pub fn with_accounts(mut self, pubkeys: impl Iterator<Item = Pubkey>) -> Self {
        self.accounts = Some(ahash::HashSet::from_iter(pubkeys));
        self
    }
    /// add filter for given anchor account `discriminator`
    pub fn with_discriminator(mut self, discriminator: &'static [u8]) -> Self {
        self.discriminator = Some(discriminator);
        self
    }
    /// add filter for given memcmp filter
    pub fn with_memcmp(mut self, memcmp: Memcmp) -> Self {
        self.memcmp = Some(memcmp);
        self
    }
    /// Returns true if pubkey/account matches the filter
    pub fn matches(&self, pubkey: &Pubkey, account: &SubscribeUpdateAccountInfo) -> bool {
        if !self.is_full {
            // partial matches
            self.discriminator.is_some_and(|x| x == &account.data[..8])
                || self.accounts.as_ref().is_some_and(|x| x.contains(pubkey))
                || self
                    .memcmp
                    .as_ref()
                    .is_some_and(|x| x.bytes_match(&account.data))
        } else {
            // full matches
            (match self.discriminator {
                Some(x) => x == &account.data[..8],
                None => true,
            }) && (match self.accounts.as_ref() {
                Some(x) => x.contains(pubkey),
                None => true,
            }) && (match self.memcmp.as_ref() {
                Some(x) => x.bytes_match(&account.data),
                None => true,
            })
        }
    }
}

#[derive(Debug, Clone)]
pub struct GrpcConnectionOpts {
    /// Apply a timeout to connecting to the uri.
    connect_timeout_ms: Option<u64>,
    /// Sets the tower service default internal buffer size, default is 1024
    buffer_size: Option<usize>,
    /// Sets whether to use an adaptive flow control. Uses hyper's default otherwise.
    http2_adaptive_window: Option<bool>,
    /// Set http2 KEEP_ALIVE_TIMEOUT. Uses hyper's default otherwise.
    http2_keep_alive_interval_ms: Option<u64>,
    /// Sets the max connection-level flow control for HTTP2, default is 65,535
    initial_connection_window_size: Option<u32>,
    ///Sets the SETTINGS_INITIAL_WINDOW_SIZE option for HTTP2 stream-level flow control, default is 65,535
    initial_stream_window_size: Option<u32>,
    ///Set http2 KEEP_ALIVE_TIMEOUT. Uses hyper's default otherwise.
    keep_alive_timeout_ms: Option<u64>,
    /// Set http2 KEEP_ALIVE_WHILE_IDLE. Uses hyper's default otherwise.
    keep_alive_while_idle: Option<bool>,
    /// Set whether TCP keepalive messages are enabled on accepted connections.
    tcp_keepalive_ms: Option<u64>,
    /// Set the value of TCP_NODELAY option for accepted connections. Enabled by default.
    tcp_nodelay: Option<bool>,
    /// Apply a timeout to each request.
    timeout_ms: Option<u64>,
    /// Max message size before decoding, full blocks can be super large, default is 1GiB
    max_decoding_message_size: usize,
}

impl Default for GrpcConnectionOpts {
    fn default() -> Self {
        Self {
            connect_timeout_ms: None,
            buffer_size: None,
            http2_adaptive_window: None,
            http2_keep_alive_interval_ms: None,
            initial_connection_window_size: None,
            initial_stream_window_size: None,
            keep_alive_timeout_ms: None,
            keep_alive_while_idle: None,
            tcp_keepalive_ms: None,
            tcp_nodelay: None,
            timeout_ms: None,
            max_decoding_message_size: 1024 * 1024 * 1024,
        }
    }
}

/// Options for the geyser subscription request
#[derive(Debug, Default, Clone)]
pub struct GeyserSubscribeOpts {
    /// Filter by Offset and Data, format: `offset,data in base58`
    pub accounts_memcmp: Vec<Memcmp>,
    /// Filter by Data size
    pub accounts_datasize: Option<u64>,
    /// subscribe must match one of these owners
    pub accounts_owners: Vec<String>,
    /// subscribe must match one of these pubkeys
    pub accounts_pubkeys: Vec<String>,
    /// Re-send message from slot
    pub from_slot: Option<u64>,
    /// Send ping in subscribe request
    pub ping: Option<i32>,
    /// Enable interslot updates
    pub interslot_updates: Option<bool>,
    /// Transaction filters: Filter txs that use any of these accounts
    pub transactions_accounts_include: Vec<String>,
    /// Transaction filters: Filter out txs that use any of these accounts
    pub transactions_accounts_exclude: Vec<String>,
    /// Transaction filters: Txs must include all of these accounts
    pub transactions_accounts_required: Vec<String>,
    /// Subscribe to block metadata updates
    pub blocks_meta: bool,
    /// subscribe to slot updates
    pub slot_updates: bool,
}

#[derive(Debug, thiserror::Error)]
/// drift gRPC error
pub enum GrpcError {
    #[error("grpc connect err: {0}")]
    Geyser(GeyserGrpcBuilderError),
    #[error("grpc request err: {0}")]
    Client(GeyserGrpcClientError),
    #[error("grpc stream err: {0}")]
    Stream(Status),
}

/// specialized Drift gRPC client
pub struct DriftGrpcClient {
    endpoint: String,
    x_token: String,
    grpc_opts: Option<GrpcConnectionOpts>,
    on_account_hooks: Hooks,
    on_slot: Box<dyn Fn(Slot) + Send + Sync + 'static>,
    on_transaction_hooks: TransactionHooks,
    on_block_meta: Box<dyn Fn(SubscribeUpdateBlockMeta) + Send + Sync + 'static>,
}

impl DriftGrpcClient {
    /// Create a new `DriftGrpcClient`
    ///
    /// It can be started by calling `subscribe`
    pub fn new(endpoint: String, x_token: String) -> Self {
        Self {
            endpoint,
            x_token,
            on_account_hooks: Default::default(),
            on_transaction_hooks: Default::default(),
            grpc_opts: None,
            on_slot: Box::new(move |_slot| {}),
            on_block_meta: Box::new(move |_meta| {}),
        }
    }

    /// Set gRPC network options
    pub fn grpc_connection_opts(mut self, grpc_opts: GrpcConnectionOpts) -> Self {
        let _ = self.grpc_opts.insert(grpc_opts);
        self
    }

    /// Add a callback on slot updates
    ///
    /// `on_slot` must prioritize fast handling or risk blocking the gRPC thread
    pub fn on_slot<F: Fn(Slot) + Send + Sync + 'static>(&mut self, on_slot: F) {
        self.on_slot = Box::new(on_slot);
    }

    /// Add a callback on block meta updates
    ///
    /// `on_block_meta` must prioritize fast handling or risk blocking the gRPC thread
    pub fn on_block_meta<F: Fn(SubscribeUpdateBlockMeta) + Send + Sync + 'static>(
        &mut self,
        on_block_meta: F,
    ) {
        self.on_block_meta = Box::new(on_block_meta);
    }

    /// Add a callback for all account updates matching `filter`
    ///
    /// This may be called many times to define multiple callbacks
    ///
    /// * `filter` - filter accounts by criteria
    /// * `on_account` - fn to receive callback on filter match
    ///
    /// DEV: `on_account` must prioritize fast handling or risk blocking the gRPC thread
    pub fn on_account<T: Fn(&AccountUpdate) + Send + Sync + 'static>(
        &mut self,
        filter: AccountFilter,
        on_account: T,
    ) {
        self.on_account_hooks.push((filter, Box::new(on_account)));
    }

    /// Add a callback for transaction updates
    /// !Use with `transaction_include_accounts` to subscribe to specific account txs
    ///
    /// This may be called many times to define multiple callbacks
    ///
    /// * `on_transaction` - fn to receive callback on accounts
    pub fn on_transaction<T: Fn(&TransactionUpdate) + Send + Sync + 'static>(
        &mut self,
        on_transaction: T,
    ) {
        self.on_transaction_hooks.push(Box::new(on_transaction));
    }

    /// Start subscription for geyser updates
    ///
    /// Returns an unsub handle on success
    pub async fn subscribe(
        self,
        commitment: CommitmentLevel,
        subscribe_opts: GeyserSubscribeOpts,
    ) -> Result<UnsubHandle, GrpcError> {
        let mut grpc_client = grpc_connect(
            self.endpoint.as_str(),
            self.x_token.as_str(),
            self.grpc_opts.clone().unwrap_or_default(),
        )
        .await
        .map_err(|err| {
            error!(target: "grpc", "connect failed: {err:?}");
            GrpcError::Geyser(err)
        })?;

        let resp = grpc_client.get_version().await.map_err(GrpcError::Client)?;
        info!("gRPC connected 🔌: {}", resp.version);
        let request = subscribe_opts.to_subscribe_request(commitment);
        info!(target: "grpc", "gRPC subscribing: {request:?}");

        let (unsub_tx, mut unsub_rx) = tokio::sync::oneshot::channel::<()>();

        // gRPC receives updates very frequently, don't want tokio scheduler moving it
        std::thread::spawn(|| {
            let rt = tokio::runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .unwrap();
            let ls = tokio::task::LocalSet::new();
            let geyser_task = ls.spawn_local(Self::geyser_subscribe(
                grpc_client,
                request,
                self.on_account_hooks,
                self.on_transaction_hooks,
                self.on_slot,
                self.on_block_meta,
            ));
            let mut waiter = FuturesUnordered::new();
            waiter.push(geyser_task);

            // nb: will cause grpc task to drop when triggered but-
            // it doesn't call any 'unsub' endpoint
            ls.block_on(&rt, async move {
                tokio::select! {
                    biased;
                    _ = &mut unsub_rx => (),
                    res = waiter.next() => {
                        if let Ok(Some(err)) = res.unwrap() {
                            log::error!(target: "grpc", "subscription task failed: {err:?}");
                        } else {
                            log::error!(target: "grpc", "subscription task ended unexpectedly");
                        }
                    }
                }
            });
            info!(target: "grpc", "gRPC connection unsubscribed");
        });

        info!(target: "grpc", "gRPC subscribed ⚡️");
        Ok(unsub_tx)
    }

    /// Run the gRPC subscription task
    ///
    /// It receives all configured updates and routes them to registered callbacks
    async fn geyser_subscribe(
        mut client: GeyserGrpcClient<impl Interceptor>,
        request: SubscribeRequest,
        on_account: Hooks,
        on_transaction: TransactionHooks,
        on_slot: impl Fn(Slot),
        on_block_meta: impl Fn(SubscribeUpdateBlockMeta),
    ) -> Option<GrpcError> {
        let max_retries = 3;
        let mut retry_count = 0;
        let mut latest_slot = 0;
        let mut last_error: Option<GrpcError> = None;
        loop {
            if retry_count >= max_retries {
                log::warn!(target: "grpc", "max retry attempts reached. disconnecting...");
                break;
            }
            let (mut subscribe_tx, mut stream) =
                match client.subscribe_with_request(Some(request.clone())).await {
                    Ok(res) => {
                        retry_count = 0;
                        res
                    }
                    Err(err) => {
                        log::warn!(target: "grpc", "failed subscription: {err:?}");
                        retry_count += 1;
                        tokio::time::sleep(Duration::from_secs(2_u64.pow(retry_count + 1))).await;
                        let _ = last_error.insert(GrpcError::Client(err));
                        continue;
                    }
                };

            while let Some(message) = stream.next().await {
                match message {
                    Ok(msg) => {
                        match msg.update_oneof {
                            Some(UpdateOneof::Account(account_update)) => {
                                let account = match account_update.account {
                                    Some(ref account) => account,
                                    None => {
                                        warn!(target: "grpc", "empty account update: {account_update:?}");
                                        continue;
                                    }
                                };
                                let pubkey = Pubkey::new_from_array(
                                    account.pubkey.as_slice().try_into().unwrap(),
                                );
                                log::trace!(target: "grpc", "account update: {pubkey}");
                                let update = AccountUpdate {
                                    owner: Pubkey::new_from_array(
                                        account.owner.as_slice().try_into().unwrap(),
                                    ),
                                    pubkey,
                                    slot: latest_slot,
                                    lamports: account.lamports,
                                    executable: account.executable,
                                    rent_epoch: account.rent_epoch,
                                    data: &account.data,
                                };

                                for (filter, hook) in &on_account {
                                    if filter.matches(&pubkey, account) {
                                        hook(&update);
                                    }
                                }
                            }
                            Some(UpdateOneof::Transaction(tx_update)) => {
                                let tx = match tx_update.transaction {
                                    Some(ref tx) => tx,
                                    None => {
                                        warn!(target: "grpc", "empty transaction update: {tx_update:?}");
                                        continue;
                                    }
                                };
                                let transaction = match tx.transaction {
                                    Some(ref tx) => tx,
                                    None => {
                                        warn!(target: "grpc", "empty transaction update: {tx_update:?}");
                                        continue;
                                    }
                                };
                                let meta = match tx.meta {
                                    Some(ref meta) => meta,
                                    None => {
                                        warn!(target: "grpc", "empty transaction meta: {tx_update:?}");
                                        continue;
                                    }
                                };
                                for hook in &on_transaction {
                                    let update = TransactionUpdate {
                                        slot: tx_update.slot,
                                        is_vote: tx.is_vote,
                                        transaction: transaction.clone(),
                                        meta: meta.clone(),
                                    };
                                    hook(&update);
                                }
                            }
                            Some(UpdateOneof::Slot(msg)) => {
                                log::trace!(target: "grpc", "slot: {}", msg.slot);
                                if msg.slot > latest_slot {
                                    latest_slot = msg.slot;
                                    on_slot(latest_slot);
                                }
                            }
                            Some(UpdateOneof::BlockMeta(msg)) => on_block_meta(msg),
                            Some(UpdateOneof::Ping(_)) => {
                                // This is necessary to keep load balancers that expect client pings alive. If your load balancer doesn't
                                // require periodic client pings then this is unnecessary
                                log::debug!(target: "grpc", "ping");
                                let ping = SubscribeRequest {
                                    ping: Some(SubscribeRequestPing { id: 1 }),
                                    ..Default::default()
                                };
                                match tokio::time::timeout(
                                    Duration::from_secs(5),
                                    subscribe_tx.send(ping),
                                )
                                .await
                                {
                                    Ok(Ok(_)) => (),
                                    Ok(Err(err)) => {
                                        log::warn!(target: "grpc", "ping failed: {err:?}");
                                    }
                                    Err(_) => {
                                        log::warn!(target: "grpc", "ping timeout");
                                    }
                                }
                            }
                            Some(UpdateOneof::Pong(_)) => {
                                log::trace!(target: "grpc", "pong");
                            }
                            Some(other_update) => {
                                warn!(target: "grpc", "unhandled update: {other_update:?}");
                            }
                            None => {
                                warn!(target: "grpc", "received empty update");
                                break;
                            }
                        }
                    }
                    Err(status) => {
                        error!(target: "grpc", "stream error: {status:?}");
                        let _ = last_error.insert(GrpcError::Stream(status));
                        break;
                    }
                }
            }
        }

        error!(target: "grpc", "gRPC stream closed");
        last_error
    }
}

impl GeyserSubscribeOpts {
    fn to_subscribe_request(&self, commitment: CommitmentLevel) -> SubscribeRequest {
        let mut accounts = AccountFilterMap::default();
        let mut filters = vec![];
        for filter in self.accounts_memcmp.iter() {
            filters.push(SubscribeRequestFilterAccountsFilter {
                filter: Some(AccountsFilterOneof::Memcmp(
                    SubscribeRequestFilterAccountsFilterMemcmp {
                        offset: filter.offset() as u64,
                        data: filter
                            .bytes()
                            .map(|b| AccountsFilterMemcmpOneof::Bytes(b.to_vec())),
                    },
                )),
            });
        }
        if let Some(datasize) = self.accounts_datasize {
            filters.push(SubscribeRequestFilterAccountsFilter {
                filter: Some(AccountsFilterOneof::Datasize(datasize)),
            });
        }

        if !self.accounts_pubkeys.is_empty() || !self.accounts_owners.is_empty() {
            accounts.insert(
                "client".to_owned(),
                SubscribeRequestFilterAccounts {
                    account: self.accounts_pubkeys.clone(),
                    owner: self.accounts_owners.clone(),
                    filters,
                    ..Default::default()
                },
            );
        }

        let mut slots = SlotsFilterMap::default();
        slots.insert(
            "client".to_owned(),
            SubscribeRequestFilterSlots {
                filter_by_commitment: Some(true),
                interslot_updates: self.interslot_updates,
            },
        );

        let mut blocks_meta = HashMap::new();
        if self.blocks_meta {
            blocks_meta.insert("client".to_owned(), SubscribeRequestFilterBlocksMeta {});
        }

        let mut transactions = TransactionFilterMap::default();
        if !self.transactions_accounts_include.is_empty()
            || !self.transactions_accounts_exclude.is_empty()
            || !self.transactions_accounts_required.is_empty()
        {
            transactions.insert(
                "client".to_owned(),
                SubscribeRequestFilterTransactions {
                    vote: Some(false),
                    failed: Some(false),
                    account_include: self.transactions_accounts_include.clone(),
                    account_exclude: self.transactions_accounts_exclude.clone(),
                    account_required: self.transactions_accounts_required.clone(),
                    ..Default::default()
                },
            );
        }

        let ping = self.ping.map(|id| SubscribeRequestPing { id });

        SubscribeRequest {
            slots,
            accounts,
            transactions,
            commitment: Some(match commitment {
                CommitmentLevel::Confirmed => GeyserCommitmentLevel::Confirmed,
                CommitmentLevel::Processed => GeyserCommitmentLevel::Processed,
                CommitmentLevel::Finalized => GeyserCommitmentLevel::Finalized,
            } as i32),
            ping,
            from_slot: self.from_slot,
            blocks_meta,
            ..Default::default()
        }
    }
}

/// Connect to gRPC endpoint
///
/// Returns a new `GeyserGrpcClient`
async fn grpc_connect(
    endpoint: &str,
    x_token: &str,
    opts: GrpcConnectionOpts,
) -> Result<GeyserGrpcClient<impl Interceptor>, GeyserGrpcBuilderError> {
    info!(target: "grpc", "gRPC connecting: {endpoint}...");
    let mut tls_config = ClientTlsConfig::new().with_native_roots();
    if let Ok(path) = &std::env::var("GRPC_CA_CERT") {
        let bytes = tokio::fs::read(path)
            .await
            .expect("GRPC_CA_CERT path exists");
        tls_config = tls_config.ca_certificate(Certificate::from_pem(bytes));
    }
    let mut builder = GeyserGrpcClient::build_from_shared(endpoint.to_string())?
        .x_token(Some(x_token))?
        .tls_config(tls_config)?
        .max_decoding_message_size(opts.max_decoding_message_size);

    if let Some(duration) = opts.connect_timeout_ms {
        builder = builder.connect_timeout(Duration::from_millis(duration));
    }
    if let Some(sz) = opts.buffer_size {
        builder = builder.buffer_size(sz);
    }
    if let Some(enabled) = opts.http2_adaptive_window {
        builder = builder.http2_adaptive_window(enabled);
    }
    if let Some(duration) = opts.http2_keep_alive_interval_ms {
        builder = builder.http2_keep_alive_interval(Duration::from_millis(duration));
    }
    if let Some(sz) = opts.initial_connection_window_size {
        builder = builder.initial_connection_window_size(sz);
    }
    if let Some(sz) = opts.initial_stream_window_size {
        builder = builder.initial_stream_window_size(sz);
    }
    if let Some(duration) = opts.keep_alive_timeout_ms {
        builder = builder.keep_alive_timeout(Duration::from_millis(duration));
    }
    if let Some(enabled) = opts.keep_alive_while_idle {
        builder = builder.keep_alive_while_idle(enabled);
    }
    if let Some(duration) = opts.tcp_keepalive_ms {
        builder = builder.tcp_keepalive(Some(Duration::from_millis(duration)));
    }
    if let Some(enabled) = opts.tcp_nodelay {
        builder = builder.tcp_nodelay(enabled);
    }
    if let Some(duration) = opts.timeout_ms {
        builder = builder.timeout(Duration::from_millis(duration));
    }

    builder.connect().await
}

#[cfg(test)]
mod test {
    use solana_sdk::pubkey::Pubkey;

    use super::*;

    fn create_test_account(data: Vec<u8>) -> SubscribeUpdateAccountInfo {
        SubscribeUpdateAccountInfo {
            data,
            ..Default::default()
        }
    }

    #[test]
    fn grpc_partial_match_discriminator() {
        let discriminator = &[1, 2, 3, 4, 5, 6, 7, 8];
        let filter = AccountFilter::partial().with_discriminator(discriminator);

        // Test matching discriminator
        let account = create_test_account(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        assert!(filter.matches(&Pubkey::new_unique(), &account));

        // Test non-matching discriminator
        let account = create_test_account(vec![8, 7, 6, 5, 4, 3, 2, 1, 9, 10]);
        assert!(!filter.matches(&Pubkey::new_unique(), &account));
    }

    #[test]
    fn grpc_partial_match_accounts() {
        let pubkey = Pubkey::new_unique();
        let filter = AccountFilter::partial().with_accounts([pubkey].into_iter());

        // Test matching pubkey
        let account = create_test_account(vec![1, 2, 3, 4]);
        assert!(filter.matches(&pubkey, &account));

        // Test non-matching pubkey
        let other_pubkey = Pubkey::new_unique();
        assert!(!filter.matches(&other_pubkey, &account));
    }

    #[test]
    fn grpc_partial_match_memcmp() {
        let memcmp = Memcmp::new_raw_bytes(0, vec![1, 2, 3]);
        let filter = AccountFilter::partial().with_memcmp(memcmp);

        // Test matching memcmp
        let account = create_test_account(vec![1, 2, 3, 4, 5]);
        assert!(filter.matches(&Pubkey::new_unique(), &account));

        // Test non-matching memcmp
        let account = create_test_account(vec![3, 2, 1, 4, 5]);
        assert!(!filter.matches(&Pubkey::new_unique(), &account));
    }

    #[test]
    fn grpc_full_match_all_filters() {
        let pubkey = Pubkey::new_unique();
        let discriminator = &[1, 2, 3, 4, 5, 6, 7, 8];
        let memcmp = Memcmp::new_raw_bytes(8, vec![9, 10]);

        let filter = AccountFilter::full()
            .with_discriminator(discriminator)
            .with_accounts([pubkey].into_iter())
            .with_memcmp(memcmp);

        // Test all match
        let account = create_test_account(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        assert!(filter.matches(&pubkey, &account));

        // Test discriminator mismatch
        let account = create_test_account(vec![8, 7, 6, 5, 4, 3, 2, 1, 9, 10]);
        assert!(!filter.matches(&pubkey, &account));

        // Test pubkey mismatch
        let other_pubkey = Pubkey::new_unique();
        let account = create_test_account(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        assert!(!filter.matches(&other_pubkey, &account));

        // Test memcmp mismatch
        let account = create_test_account(vec![1, 2, 3, 4, 5, 6, 7, 8, 10, 9]);
        assert!(!filter.matches(&pubkey, &account));
    }

    #[test]
    fn grpc_firehose_matches_everything() {
        let filter = AccountFilter::firehose();
        let pubkey = Pubkey::new_unique();
        let account = create_test_account(vec![1, 2, 3, 4]);

        assert!(filter.matches(&pubkey, &account));
    }
}

```

## File: crates/src/grpc/mod.rs
```
//! Drift gRPC module

use anchor_lang::Discriminator;
use solana_sdk::{
    clock::{Epoch, Slot},
    commitment_config::CommitmentLevel,
    pubkey::Pubkey,
};
pub mod grpc_subscriber;
use grpc_subscriber::{AccountFilter, GrpcConnectionOpts};
use yellowstone_grpc_proto::{
    geyser::SubscribeUpdateBlockMeta,
    prelude::{Transaction, TransactionStatusMeta},
};

use crate::types::accounts::User;

/// grpc transaction update callback
pub type OnTransactionFn = dyn Fn(&TransactionUpdate) + Send + Sync + 'static;
/// grpc oracle account update callback
pub type OnOracleFn = dyn Fn(&AccountUpdate) + Send + Sync + 'static;
/// grpc account update callback
pub type OnAccountFn = dyn Fn(&AccountUpdate) + Send + Sync + 'static;
/// grpc slot update callback
pub type OnSlotFn = dyn Fn(Slot) + Send + Sync + 'static;
/// grpc block metadata update callback
pub type OnBlockMetaFn = dyn Fn(SubscribeUpdateBlockMeta) + Send + Sync + 'static;

/// Account update from gRPC
#[derive(PartialEq, Eq, Clone)]
pub struct AccountUpdate<'a> {
    /// the account's pubkey
    pub pubkey: Pubkey,
    /// lamports in the account
    pub lamports: u64,
    /// data held in the account
    pub data: &'a [u8],
    /// the program that owns the account. If executable, the program that loads the account.
    pub owner: Pubkey,
    /// the account's data contains a loaded program (and is now read-only)
    pub executable: bool,
    /// the epoch at which the account will next owe rent
    pub rent_epoch: Epoch,
    /// Slot the update was retrieved
    pub slot: Slot,
}
/// Transaction update from gRPC
#[derive(Clone, Debug)]
pub struct TransactionUpdate {
    /// slot of the transaction
    pub slot: u64,
    /// true if this is a vote transaction
    pub is_vote: bool,
    pub transaction: Transaction,
    pub meta: TransactionStatusMeta,
}

/// Config options for drift gRPC subscription
///
/// ```example(no_run)
///   // subscribe to all user and users stats accounts
///   let opts = GrpcSubscribeOpts::default()
///                .usermap_on() // subscribe to ALL user accounts
///                .statsmap_on(); // subscribe to ALL user stats accounts
///
///  // cache specific user accounts only and set a new slot callback
///  let first_3_subaccounts = (0_u16..3).into_iter().map(|i| wallet.sub_account(i)).collect();
///  let opts = GrpcSubscribeOpts::default()
///                 .user_accounts(first_3_subaccounts);
///                 .on_slot(move |new_slot| {}) // slot callback
/// ```
///
pub struct GrpcSubscribeOpts {
    pub commitment: Option<CommitmentLevel>,
    /// cache user account updates (default: false)
    pub usermap: bool,
    /// cache oracle account updates (default: true)
    pub oraclemap: bool,
    /// toggle user stats map
    pub user_stats_map: bool,
    /// list of user (sub)accounts to subscribe
    pub user_accounts: Vec<Pubkey>,
    /// callback for slot updates
    pub on_slot: Option<Box<OnSlotFn>>,
    /// custom callback for account updates
    pub on_account: Option<Vec<(AccountFilter, Box<OnAccountFn>)>>,
    /// custom callback for tx updates
    pub on_transaction: Option<Box<OnTransactionFn>>,
    /// custom callback for oracle account updates
    pub on_oracle_update: Option<Box<OnOracleFn>>,
    /// Network level connection config
    pub connection_opts: GrpcConnectionOpts,
    /// Enable inter-slot update notifications
    pub interslot_updates: bool,
    /// Watch transactions including these accounts
    pub transaction_include_accounts: Vec<Pubkey>,
    /// Subscribe to block metadata updates
    pub subscribe_block_meta_updates: bool,
    /// custom callback for block meta updates
    pub on_block_meta: Option<Box<OnBlockMetaFn>>,
    /// Subscribe to slot updates
    pub subscribe_slot_updates: bool,
}

impl Default for GrpcSubscribeOpts {
    fn default() -> Self {
        Self {
            commitment: Some(CommitmentLevel::Confirmed),
            usermap: false,
            user_stats_map: false,
            oraclemap: true,
            user_accounts: Default::default(),
            transaction_include_accounts: Default::default(),
            on_slot: None,
            on_transaction: None,
            on_account: None,
            on_oracle_update: None,
            connection_opts: GrpcConnectionOpts::default(),
            interslot_updates: false,
            subscribe_block_meta_updates: false,
            subscribe_slot_updates: true,
            on_block_meta: None,
        }
    }
}

impl GrpcSubscribeOpts {
    /// Set the gRPC subscription's commitment level (default: 'confirmed')
    pub fn commitment(mut self, commitment: CommitmentLevel) -> Self {
        self.commitment = Some(commitment);
        self
    }
    /// Enables the subscription to receive updates for changes within a slot,  
    /// not just at the beginning of new slots. default: false
    pub fn interslot_updates_on(mut self) -> Self {
        self.interslot_updates = true;
        self
    }
    /// Cache ALL drift `User` account updates
    ///
    /// useful for e.g. building the DLOB, fast TX building for makers
    ///
    /// note: memory requirements ~2GiB
    pub fn usermap_on(mut self) -> Self {
        self.usermap = true;
        self
    }
    /// Disable oraclemap, will not cache oracle account updates
    pub fn oraclemap_off(mut self) -> Self {
        self.oraclemap = false;
        self
    }
    /// Cache ALL drift `UserStats` account updates
    ///
    /// useful for e.g. fast TX building for makers
    pub fn statsmap_on(mut self) -> Self {
        self.user_stats_map = true;
        self
    }
    /// Cache ALL drift `UserStats` account updates
    ///
    /// useful for e.g. fast TX building for makers
    pub fn statsmap_off(mut self) -> Self {
        self.user_stats_map = false;
        self
    }
    /// Cache account updates for given `users` only
    pub fn user_accounts(mut self, users: Vec<Pubkey>) -> Self {
        self.user_accounts = users;
        self
    }
    /// Set a callback to invoke on new slot updates
    ///
    /// * `on_slot` - the callback for new slot updates
    ///
    /// ! `on_slot` must not block the gRPC task
    pub fn on_slot(mut self, on_slot: impl Fn(Slot) + Send + Sync + 'static) -> Self {
        self.on_slot = Some(Box::new(on_slot));
        self
    }
    /// Set a callback to invoke on new block metadata updates
    ///
    /// Caller should also set `subscribe_block_meta(true)` or no updates will be received
    ///
    /// * `on_block_meta` - the callback for new block metadata updates
    ///
    /// ! `on_block_meta` must not block the gRPC task
    pub fn on_block_meta(
        mut self,
        on_block_meta: impl Fn(SubscribeUpdateBlockMeta) + Send + Sync + 'static,
    ) -> Self {
        self.on_block_meta = Some(Box::new(on_block_meta));
        self
    }
    /// Register a custom callback for account updates
    ///
    /// * `filter` - accounts matching filter will invoke the callback
    /// * `callback` - fn to invoke on matching account update
    ///
    /// ! `callback` must not block the gRPC task
    pub fn on_account(
        mut self,
        filter: AccountFilter,
        callback: impl Fn(&AccountUpdate) + Send + Sync + 'static,
    ) -> Self {
        match &mut self.on_account {
            Some(on_account) => {
                on_account.push((filter, Box::new(callback)));
            }
            None => {
                self.on_account = Some(vec![(filter, Box::new(callback))]);
            }
        }
        self
    }
    /// Register a custom callback for User account updates
    ///
    /// * `callback` - fn to invoke on all User account update
    ///
    /// ! `callback` must not block the gRPC task
    pub fn on_user_account(
        self,
        callback: impl Fn(&AccountUpdate) + Send + Sync + 'static,
    ) -> Self {
        let filter = AccountFilter::partial().with_discriminator(User::DISCRIMINATOR);
        self.on_account(filter, callback)
    }
    /// Register a custom callback for oracle account updates
    /// It will be called _before_ the oraclemap is updated
    ///
    /// * `callback` - fn to invoke on matching account update
    ///
    /// ! `callback` must not block the gRPC task
    pub fn on_oracle_update(
        mut self,
        callback: impl Fn(&AccountUpdate) + Send + Sync + 'static,
    ) -> Self {
        self.on_oracle_update = Some(Box::new(callback));
        self
    }
    /// Set network level connection opts
    pub fn connection_opts(mut self, opts: GrpcConnectionOpts) -> Self {
        self.connection_opts = opts;
        self
    }
    /// Subscribe to transactions including `accounts`
    pub fn transaction_include_accounts(mut self, accounts: Vec<Pubkey>) -> Self {
        self.transaction_include_accounts = accounts;
        self
    }
    /// Register a custom callback for transaction updates
    ///
    /// * `callback` - fn to invoke on matching account update
    ///
    /// ! `callback` must not block the gRPC task
    pub fn on_transaction(
        mut self,
        callback: impl Fn(&TransactionUpdate) + Send + Sync + 'static,
    ) -> Self {
        self.on_transaction = Some(Box::new(callback));
        self
    }
    /// Subscribe to slot updates (default: true)
    pub fn subscribe_slots(mut self, subscribe: bool) -> Self {
        self.subscribe_slot_updates = subscribe;
        self
    }
    /// Subscribe to slot updates (default: false)
    pub fn subscribe_block_meta(mut self, subscribe: bool) -> Self {
        self.subscribe_block_meta_updates = subscribe;
        self
    }
}

```

## File: crates/src/jit_client.rs
```
//! JIT proxy client
//!
//! Routes JIT maker orders via onchain jit-proxy program
use std::borrow::Cow;

use anchor_lang::{
    prelude::borsh::{self, BorshDeserialize, BorshSerialize},
    AnchorDeserialize, AnchorSerialize, InstructionData,
};
use solana_rpc_client_api::config::RpcSendTransactionConfig;
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    message::{v0, VersionedMessage},
    pubkey::Pubkey,
    signature::Signature,
};

use crate::{
    accounts::User,
    build_accounts,
    constants::{self, state_account, JIT_PROXY_ID},
    drift_idl,
    swift_order_subscriber::SignedOrderInfo,
    types::PositionDirection,
    DriftClient, MarketId, MarketType, PostOnlyParam, ReferrerInfo, SdkError, SdkResult,
    TransactionBuilder, Wallet,
};

#[derive(Clone, Copy, BorshSerialize, BorshDeserialize, PartialEq, Debug, Eq)]
pub enum PriceType {
    Limit,
    Oracle,
}

/// Taker account parameters for JIT tx building
pub struct JitTakerParams {
    taker: User,
    taker_key: Pubkey,
    taker_stats_key: Pubkey,
    taker_referrer_info: Option<ReferrerInfo>,
}

impl JitTakerParams {
    pub fn new(
        taker_key: Pubkey,
        taker_stats_key: Pubkey,
        taker: User,
        taker_referrer_info: Option<ReferrerInfo>,
    ) -> Self {
        Self {
            taker_key,
            taker_stats_key,
            taker,
            taker_referrer_info,
        }
    }
}

#[derive(Copy, Clone, Debug)]
/// Parameters for building a jit maker order
pub struct JitIxParams {
    pub max_position: i64,
    pub min_position: i64,
    pub bid: i64,
    pub ask: i64,
    pub price_type: PriceType,
    pub post_only: Option<PostOnlyParam>,
}

impl JitIxParams {
    pub fn new(
        max_position: i64,
        min_position: i64,
        bid: i64,
        ask: i64,
        price_type: PriceType,
        post_only: Option<PostOnlyParam>,
    ) -> Self {
        Self {
            max_position,
            min_position,
            bid,
            ask,
            price_type,
            post_only,
        }
    }
}

#[derive(Clone)]
pub struct JitProxyClient {
    drift_client: DriftClient,
    config: RpcSendTransactionConfig,
    cu_params: Option<ComputeBudgetParams>,
}

impl JitProxyClient {
    pub fn new(
        drift_client: DriftClient,
        config: Option<RpcSendTransactionConfig>,
        cu_params: Option<ComputeBudgetParams>,
    ) -> Self {
        Self {
            drift_client,
            config: config.unwrap_or_default(),
            cu_params,
        }
    }

    pub fn update_config(&mut self, config: RpcSendTransactionConfig) {
        self.config = config;
    }

    pub fn update_cu_params(&mut self, cu_params: ComputeBudgetParams) {
        self.cu_params = Some(cu_params);
    }

    /// Build a jit tx
    ///
    /// `taker_params` JIT taker account params
    /// `taker_order_id` order Id of the JIT order
    /// `jit_ix_params` bounds for the JIT fill
    /// `maker_params` tuple (pubkey, data) of maker's sub-account
    pub async fn build_jit_tx(
        &self,
        taker_order_id: u32,
        taker_params: &JitTakerParams,
        jit_ix_params: JitIxParams,
        maker_params: (&Pubkey, &User),
    ) -> SdkResult<VersionedMessage> {
        let order = taker_params
            .taker
            .orders
            .iter()
            .find(|order| order.order_id == taker_order_id)
            .ok_or(SdkError::JitOrderNotFound)?;

        let tx_builder = TransactionBuilder::new(
            self.drift_client.program_data(),
            *maker_params.0,
            Cow::Borrowed(maker_params.1),
            false,
        );

        let program_data = tx_builder.program_data();
        let account_data = tx_builder.account_data();

        let writable_markets = match order.market_type {
            MarketType::Perp => {
                vec![MarketId::perp(order.market_index)]
            }
            MarketType::Spot => {
                vec![MarketId::spot(order.market_index), MarketId::QUOTE_SPOT]
            }
        };

        let maker_authority = maker_params.1.authority;
        let mut accounts = build_accounts(
            program_data,
            self::accounts::Jit {
                state: *state_account(),
                user: *maker_params.0,
                user_stats: Wallet::derive_stats_account(&maker_authority),
                taker: taker_params.taker_key,
                taker_stats: taker_params.taker_stats_key,
                authority: maker_authority,
                drift_program: constants::PROGRAM_ID,
            },
            [&taker_params.taker, account_data].into_iter(),
            std::iter::empty(),
            writable_markets.iter(),
        );

        if let Some(referrer_info) = taker_params.taker_referrer_info {
            accounts.push(AccountMeta::new(referrer_info.referrer(), false));
            accounts.push(AccountMeta::new(referrer_info.referrer_stats(), false));
        }

        if order.market_type == drift_idl::types::MarketType::Spot {
            let spot_market_vault = self
                .drift_client
                .try_get_spot_market_account(order.market_index)?
                .vault;
            let quote_spot_market_vault = self
                .drift_client
                .try_get_spot_market_account(MarketId::QUOTE_SPOT.index())?
                .vault;
            accounts.push(AccountMeta::new_readonly(spot_market_vault, false));
            accounts.push(AccountMeta::new_readonly(quote_spot_market_vault, false));
        }

        let jit_params = self::instruction::JitParams {
            taker_order_id,
            max_position: jit_ix_params.max_position,
            min_position: jit_ix_params.min_position,
            bid: jit_ix_params.bid,
            ask: jit_ix_params.ask,
            price_type: jit_ix_params.price_type,
            post_only: jit_ix_params.post_only,
        };

        let ix = Instruction {
            program_id: JIT_PROXY_ID,
            accounts,
            data: instruction::Jit { params: jit_params }.data(),
        };

        let mut ixs = Vec::with_capacity(3);
        if let Some(cu_params) = self.cu_params {
            let cu_limit_ix =
                ComputeBudgetInstruction::set_compute_unit_price(cu_params.microlamports_per_cu());
            let cu_price_ix =
                ComputeBudgetInstruction::set_compute_unit_limit(cu_params.cu_limit());

            ixs.push(cu_limit_ix);
            ixs.push(cu_price_ix);
        }
        ixs.push(ix);

        let luts = program_data.lookup_tables;

        let message =
            v0::Message::try_compile(&maker_authority, ixs.as_slice(), luts, Default::default())
                .expect("failed to compile message");

        Ok(VersionedMessage::V0(message))
    }

    /// Build a swift fill tx against a taker order given by `taker_params`
    ///
    /// `signed_order_info` Fastlane (order) message to place-and-make against
    /// `taker_params` taker account params
    /// `jit_params` config for the JIT proxy
    /// `maker_pubkey` address of the maker's subaccount
    /// `maker_account_data` Maker's (User) account data corresponding with the `maker_pubkey`
    ///
    /// Returns a Solana `VersionedMessage` ready for signing
    pub async fn build_swift_ix(
        &self,
        signed_order_info: &SignedOrderInfo,
        taker_params: &JitTakerParams,
        jit_ix_params: &JitIxParams,
        maker_pubkey: &Pubkey,
        maker_account_data: &User,
    ) -> SdkResult<VersionedMessage> {
        let maker_authority = maker_account_data.authority;
        let program_data = self.drift_client.program_data();
        let signed_order_info_params = signed_order_info.order_params();
        let account_data = maker_account_data;
        let market_index = signed_order_info_params.market_index;
        let market_type = signed_order_info_params.market_type;

        let writable_markets = match market_type {
            MarketType::Perp => {
                vec![MarketId::perp(market_index)]
            }
            MarketType::Spot => {
                vec![MarketId::spot(market_index), MarketId::QUOTE_SPOT]
            }
        };

        let mut accounts = build_accounts(
            program_data,
            self::accounts::JitSignedMsg {
                state: *state_account(),
                authority: maker_authority,
                user: *maker_pubkey,
                user_stats: Wallet::derive_stats_account(&maker_authority),
                taker: taker_params.taker_key,
                taker_stats: taker_params.taker_stats_key,
                taker_signed_msg_user_orders: Wallet::derive_swift_order_account(
                    &taker_params.taker.authority,
                ),
                drift_program: constants::PROGRAM_ID,
            },
            [&taker_params.taker, account_data].into_iter(),
            std::iter::empty(),
            writable_markets.iter(),
        );

        if let Some(referrer_info) = taker_params.taker_referrer_info {
            accounts.push(AccountMeta::new(referrer_info.referrer(), false));
            accounts.push(AccountMeta::new(referrer_info.referrer_stats(), false));
        }

        if market_type == drift_idl::types::MarketType::Spot {
            let spot_market_vault = self
                .drift_client
                .try_get_spot_market_account(market_index)?
                .vault;
            let quote_spot_market_vault = self
                .drift_client
                .try_get_spot_market_account(MarketId::QUOTE_SPOT.index())?
                .vault;
            accounts.push(AccountMeta::new_readonly(spot_market_vault, false));
            accounts.push(AccountMeta::new_readonly(quote_spot_market_vault, false));
        }

        let jit_params = self::instruction::JitSignedMsgParams {
            signed_order_info_uuid: signed_order_info.order_uuid(),
            max_position: jit_ix_params.max_position,
            min_position: jit_ix_params.min_position,
            bid: jit_ix_params.bid,
            ask: jit_ix_params.ask,
            price_type: jit_ix_params.price_type,
            post_only: jit_ix_params.post_only,
        };

        let fill_ix = Instruction {
            program_id: JIT_PROXY_ID,
            accounts,
            data: instruction::JitSignedMsg { params: jit_params }.data(),
        };

        let message = TransactionBuilder::new(
            self.drift_client.program_data(),
            *maker_pubkey,
            Cow::Borrowed(maker_account_data),
            false,
        )
        .place_swift_order(signed_order_info, &taker_params.taker)
        .add_ix(fill_ix)
        .build();

        Ok(message)
    }

    /// Send a jit tx with given params
    ///
    /// `taker_order_id` Id of the order to take against
    /// `taker_params` taker account data for the tx
    /// `jit_params` bounds for the JIT fill
    /// `maker_authority` the maker's authority key
    /// `sub_account_id` the maker's sub-account for the fill
    pub async fn jit(
        &self,
        taker_order_id: u32,
        taker_params: &JitTakerParams,
        jit_params: JitIxParams,
        maker_authority: &Pubkey,
        sub_account_id: Option<u16>,
    ) -> SdkResult<Signature> {
        let sub_account =
            Wallet::derive_user_account(maker_authority, sub_account_id.unwrap_or_default());
        let sub_account_data = self.drift_client.get_user_account(&sub_account).await?;
        let tx = self
            .build_jit_tx(
                taker_order_id,
                taker_params,
                jit_params,
                (&sub_account, &sub_account_data),
            )
            .await?;
        self.drift_client
            .sign_and_send_with_config(tx, None, self.config)
            .await
    }

    /// Try fill against a swift order with JIT-proxy protection
    ///
    /// `signed_order_info` the swift order info
    /// `taker_params` taker account data for the tx
    /// `jit_params` bounds for the JIT fill
    /// `maker_authority` the maker's authority key
    /// `sub_account_id` the maker's sub-account for the fill
    pub async fn try_swift_fill(
        &self,
        signed_order_info: &SignedOrderInfo,
        taker_params: &JitTakerParams,
        jit_params: &JitIxParams,
        maker_authority: &Pubkey,
        sub_account_id: Option<u16>,
    ) -> SdkResult<Signature> {
        let sub_account =
            Wallet::derive_user_account(maker_authority, sub_account_id.unwrap_or_default());
        let sub_account_data = self.drift_client.get_user_account(&sub_account).await?;
        let tx = self
            .build_swift_ix(
                signed_order_info,
                taker_params,
                jit_params,
                &sub_account,
                &sub_account_data,
            )
            .await?;
        self.drift_client
            .sign_and_send_with_config(tx, None, self.config)
            .await
    }
}

#[derive(Clone, Copy)]
pub struct ComputeBudgetParams {
    microlamports_per_cu: u64,
    cu_limit: u32,
}

impl ComputeBudgetParams {
    pub fn new(microlamports_per_cu: u64, cu_limit: u32) -> Self {
        Self {
            microlamports_per_cu,
            cu_limit,
        }
    }

    pub fn microlamports_per_cu(&self) -> u64 {
        self.microlamports_per_cu
    }

    pub fn cu_limit(&self) -> u32 {
        self.cu_limit
    }
}

#[derive(Debug, Clone, Copy, AnchorSerialize, AnchorDeserialize, PartialEq)]
pub struct JitSwiftParams {
    pub signed_order_info_uuid: [u8; 8],
    pub max_position: i64,
    pub min_position: i64,
    pub bid: i64,
    pub ask: i64,
    pub price_type: PriceType,
    pub post_only: Option<PostOnlyParam>,
}

impl Default for JitSwiftParams {
    fn default() -> Self {
        Self {
            signed_order_info_uuid: [0; 8],
            max_position: 0,
            min_position: 0,
            bid: 0,
            ask: 0,
            price_type: PriceType::Limit,
            post_only: None,
        }
    }
}

impl JitSwiftParams {
    pub fn get_worst_price(
        self,
        oracle_price: i64,
        taker_direction: PositionDirection,
    ) -> SdkResult<u64> {
        match (taker_direction, self.price_type) {
            (PositionDirection::Long, PriceType::Limit) => Ok(self.ask.unsigned_abs()),
            (PositionDirection::Short, PriceType::Limit) => Ok(self.bid.unsigned_abs()),
            (PositionDirection::Long, PriceType::Oracle) => {
                Ok(oracle_price.saturating_add(self.ask).unsigned_abs())
            }
            (PositionDirection::Short, PriceType::Oracle) => {
                Ok(oracle_price.saturating_add(self.bid).unsigned_abs())
            }
        }
    }
}

pub mod instruction {
    //! copied from jit-proxy program
    //! simplifies dependency graph, unlikely to change frequently
    use super::*;
    use crate::PostOnlyParam;
    #[derive(BorshDeserialize, BorshSerialize)]
    pub struct Jit {
        pub params: JitParams,
    }
    impl anchor_lang::Discriminator for Jit {
        const DISCRIMINATOR: &[u8] = &[99, 42, 97, 140, 152, 62, 167, 234];
    }
    impl anchor_lang::InstructionData for Jit {}

    #[derive(Debug, Clone, Copy, AnchorSerialize, AnchorDeserialize)]
    pub struct JitParams {
        pub taker_order_id: u32,
        pub max_position: i64,
        pub min_position: i64,
        pub bid: i64,
        pub ask: i64,
        pub price_type: PriceType,
        pub post_only: Option<PostOnlyParam>,
    }

    #[derive(BorshDeserialize, BorshSerialize)]
    pub struct JitSignedMsg {
        pub params: JitSignedMsgParams,
    }
    impl anchor_lang::Discriminator for JitSignedMsg {
        const DISCRIMINATOR: &[u8] = &[134, 130, 156, 72, 37, 120, 153, 21];
    }
    impl anchor_lang::InstructionData for JitSignedMsg {}

    #[derive(Debug, Clone, Copy, AnchorSerialize, AnchorDeserialize)]
    pub struct JitSignedMsgParams {
        pub signed_order_info_uuid: [u8; 8],
        pub max_position: i64,
        pub min_position: i64,
        pub bid: i64,
        pub ask: i64,
        pub price_type: PriceType,
        pub post_only: Option<PostOnlyParam>,
    }
}

pub mod accounts {
    //! copied from jit-proxy program
    //! simplifies dependency graph, unlikely to change frequently
    use solana_sdk::instruction::AccountMeta;

    use super::*;
    use crate::drift_idl::traits::ToAccountMetas;

    /// this is generated from `#[derive(Accounts)]` from `__client_accounts_jit`
    #[derive(anchor_lang::AnchorSerialize)]
    pub struct Jit {
        pub state: Pubkey,
        pub user: Pubkey,
        pub user_stats: Pubkey,
        pub taker: Pubkey,
        pub taker_stats: Pubkey,
        pub authority: Pubkey,
        pub drift_program: Pubkey,
    }
    #[automatically_derived]
    impl ToAccountMetas for Jit {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            vec![
                AccountMeta::new_readonly(self.state, false),
                AccountMeta::new(self.user, false),
                AccountMeta::new(self.user_stats, false),
                AccountMeta::new(self.taker, false),
                AccountMeta::new(self.taker_stats, false),
                AccountMeta::new_readonly(self.authority, true),
                AccountMeta::new_readonly(self.drift_program, false),
            ]
        }
    }

    pub struct JitSignedMsg {
        pub state: Pubkey,
        pub user: Pubkey,
        pub user_stats: Pubkey,
        pub taker: Pubkey,
        pub taker_stats: Pubkey,
        pub taker_signed_msg_user_orders: Pubkey,
        pub authority: Pubkey,
        pub drift_program: Pubkey,
    }
    #[automatically_derived]
    impl ToAccountMetas for JitSignedMsg {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            vec![
                AccountMeta::new_readonly(self.state, false),
                AccountMeta::new(self.user, false),
                AccountMeta::new(self.user_stats, false),
                AccountMeta::new(self.taker, false),
                AccountMeta::new(self.taker_stats, false),
                AccountMeta::new(self.taker_signed_msg_user_orders, false),
                AccountMeta::new_readonly(self.authority, true),
                AccountMeta::new_readonly(self.drift_program, false),
            ]
        }
    }
}

```

## File: crates/src/jupiter.rs
```
//! Jupiter SDK helpers
pub use jupiter_swap_api_client::{
    quote::{QuoteResponse, SwapMode},
    swap::SwapInstructionsResponse,
    transaction_config::TransactionConfig,
    JupiterSwapApiClient,
};
use solana_sdk::{message::AddressLookupTableAccount, pubkey::Pubkey};

use crate::{
    types::{SdkError, SdkResult},
    utils, DriftClient,
};

/// Default Jupiter API url
const DEFAULT_JUPITER_API_URL: &str = "https://lite-api.jup.ag/swap/v1";

/// jupiter swap IXs and metadata for building a swap Tx
pub struct JupiterSwapInfo {
    pub quote: QuoteResponse,
    pub ixs: SwapInstructionsResponse,
    pub luts: Vec<AddressLookupTableAccount>,
}

pub trait JupiterSwapApi {
    fn jupiter_swap_query(
        &self,
        user_authority: &Pubkey,
        amount: u64,
        swap_mode: SwapMode,
        in_market: u16,
        out_market: u16,
        slippage_bps: u16,
        only_direct_routes: Option<bool>,
        excluded_dexes: Option<String>,
        transaction_config: Option<TransactionConfig>,
    ) -> impl std::future::Future<Output = SdkResult<JupiterSwapInfo>> + Send;
}

impl JupiterSwapApi for DriftClient {
    /// Fetch Jupiter swap ixs and metadata for a token swap
    ///
    /// This function queries Jupiter API to get the optimal swap route and corresponding instructions
    /// for swapping between two tokens.
    ///
    /// # Arguments
    ///
    /// * `rpc` - A Solana RPC client
    /// * `user_authority` - The public key of the user's wallet that will execute the swap
    /// * `amount` - The amount of input tokens to swap, in native units (smallest denomination)
    /// * `swap_mode` - The type of swap to perform (e.g. ExactIn, ExactOut)
    /// * `slippage_bps` - Maximum allowed slippage in basis points (1 bp = 0.01%)
    /// * `in_market` - The market index of the token to swap from
    /// * `out_market` - The market index of the token to swap to
    /// * `only_direct_routes` - If Some(true), only consider direct swap routes between the tokens
    /// * `excluded_dexes` - Optional comma-separated string of DEX names to exclude from routing
    /// * `transaction_config` - Optional configuration for the swap transaction
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing `JupiterSwapInfo` with the swap instructions and route details
    /// if successful, or a `SdkError` if the operation fails.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use solana_sdk::pubkey::Pubkey;
    ///
    /// let swap_info = jupiter_swap_query(
    ///     rpc_client,
    ///     user_wallet.pubkey(),
    ///     1_000_000, // 1 USDC
    ///     SwapMode::ExactIn,
    ///     50, // 0.5% slippage
    ///     usdc_mint,
    ///     sol_mint,
    ///     Some(true),
    ///     None,
    ///     None
    /// ).await?;
    /// ```
    async fn jupiter_swap_query(
        &self,
        user_authority: &Pubkey,
        amount: u64,
        swap_mode: SwapMode,
        slippage_bps: u16,
        in_market: u16,
        out_market: u16,
        only_direct_routes: Option<bool>,
        excluded_dexes: Option<String>,
        transaction_config: Option<TransactionConfig>,
    ) -> SdkResult<JupiterSwapInfo> {
        let jupiter_url =
            std::env::var("JUPITER_API_URL").unwrap_or(DEFAULT_JUPITER_API_URL.into());
        let jup_client = JupiterSwapApiClient::new(jupiter_url);

        let in_market = self.try_get_spot_market_account(in_market)?;
        let out_market = self.try_get_spot_market_account(out_market)?;

        // GET /quote
        let quote_request = jupiter_swap_api_client::quote::QuoteRequest {
            amount,
            swap_mode: Some(swap_mode),
            input_mint: in_market.mint,
            output_mint: out_market.mint,
            slippage_bps,
            only_direct_routes,
            excluded_dexes,
            ..Default::default()
        };

        let quote_response = jup_client.quote(&quote_request).await.map_err(|err| {
            log::error!("jupiter api request: {err:?}");
            SdkError::Generic(err.to_string())
        })?;
        // POST /swap-instructions
        let swap_instructions = jup_client
            .swap_instructions(&jupiter_swap_api_client::swap::SwapRequest {
                user_public_key: *user_authority,
                quote_response: quote_response.clone(),
                config: transaction_config.unwrap_or_default(),
            })
            .await
            .map_err(|err| {
                log::error!("jupiter api request: {err:?}");
                SdkError::Generic(err.to_string())
            })?;

        let res = self
            .rpc()
            .get_multiple_accounts(swap_instructions.address_lookup_table_addresses.as_slice())
            .await?;

        let luts = res
            .iter()
            .zip(swap_instructions.address_lookup_table_addresses.iter())
            .map(|(acc, key)| {
                utils::deserialize_alt(*key, acc.as_ref().expect("deser LUT")).expect("deser LUT")
            })
            .collect();

        Ok(JupiterSwapInfo {
            luts,
            quote: quote_response,
            ixs: swap_instructions,
        })
    }
}

```

## File: crates/src/lib.rs
[Truncated - showing first 1000 chars of 147KB file]
```
//! Drift SDK

use std::{
    borrow::Cow,
    collections::BTreeSet,
    sync::{Arc, RwLock},
    time::Duration,
};

#[cfg(feature = "titan")]
use crate::titan::TitanSwapInfo;
use crate::{
    account_map::AccountMap,
    blockhash_subscriber::BlockhashSubscriber,
    constants::{
        derive_perp_market_account, derive_revenue_share_escrow, derive_spot_market_account,
        ids::{drift_oracle_receiver_program, wormhole_program},
        state_account, MarketExt, ProgramData, DEFAULT_PUBKEY, PYTH_LAZER_STORAGE_ACCOUNT_KEY,
        SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RENT_PUBKEY,
    },
    drift_idl::traits::ToAccountMetas,
    ffi::OraclePriceData,
    grpc::grpc_subscriber::{AccountFilter, DriftGrpcClient, GeyserSubscribeOpts},
    jupiter::JupiterSwapInfo,
    marketmap::MarketMap,
    oraclemap::{Oracle, OracleMap},
    swift_order_subscriber::{SignedOrderInfo, SwiftOrderStream},
    types::{
        accounts::{PerpMarket, SpotMarket, State, User, UserStats},
        AccountU
```

## File: crates/src/market_state.rs
```
//! Unified HashMap for providing market and oracle data for margin calculations
//! replaces the programs AccountLoader types for FFI
use fxhash::FxBuildHasher;

use crate::{
    drift_idl::accounts::{PerpMarket, SpotMarket},
    OraclePriceData,
};
use std::{
    collections::HashMap,
    sync::{
        atomic::{AtomicPtr, Ordering},
        Arc,
    },
};

/// Internal data structure for market state
#[derive(Clone, Default)]
pub struct MarketStateData {
    pub spot_markets: HashMap<u16, SpotMarket, FxBuildHasher>,
    pub perp_markets: HashMap<u16, PerpMarket, FxBuildHasher>,
    pub spot_oracle_prices: HashMap<u16, OraclePriceData, FxBuildHasher>,
    pub perp_oracle_prices: HashMap<u16, OraclePriceData, FxBuildHasher>,
    pub spot_pyth_prices: HashMap<u16, i64, FxBuildHasher>, // Override spot with pyth price
    pub perp_pyth_prices: HashMap<u16, i64, FxBuildHasher>, // Override perp with pyth price
    pub pyth_oracle_diff_threshold_bps: u64, // Min bps diff to prefer pyth price over oracle. Defaults to 0 (always use pyth when set).
}

impl MarketStateData {
    pub fn set_spot_market(&mut self, market: SpotMarket) {
        self.spot_markets.insert(market.market_index, market);
    }

    pub fn set_perp_market(&mut self, market: PerpMarket) {
        self.perp_markets.insert(market.market_index, market);
    }

    pub fn set_spot_oracle_price(&mut self, market_index: u16, price: OraclePriceData) {
        self.spot_oracle_prices.insert(market_index, price);
    }

    pub fn set_perp_oracle_price(&mut self, market_index: u16, price: OraclePriceData) {
        self.perp_oracle_prices.insert(market_index, price);
    }

    pub fn set_spot_pyth_price(&mut self, market_index: u16, price_data: i64) {
        self.spot_pyth_prices.insert(market_index, price_data);
    }

    pub fn set_perp_pyth_price(&mut self, market_index: u16, price_data: i64) {
        self.perp_pyth_prices.insert(market_index, price_data);
    }
}

/// Optimized storage for drift markets and oracles
pub struct MarketState {
    state: AtomicPtr<Arc<MarketStateData>>,
}

impl MarketState {
    /// Create a lock-free market state with initial data
    pub fn new(data: MarketStateData) -> Self {
        let initial_state = Box::into_raw(Box::new(Arc::new(data)));
        Self {
            state: AtomicPtr::new(initial_state),
        }
    }

    /// Get a lock-free read-only reference to the current market state
    ///
    /// This returns an Arc<MarketStateData> that can be safely used for calculations
    /// without blocking writers. The Arc ensures the data remains valid even if
    /// the state is updated concurrently.
    pub fn load(&self) -> Arc<MarketStateData> {
        unsafe {
            let ptr = self.state.load(Ordering::Acquire);
            (*ptr).clone()
        }
    }

    /// Atomically update the entire market state
    ///
    /// This creates a new Arc<MarketStateData> with the updated data and atomically
    /// replaces the current state. All readers will see the new state on their
    /// next load() call. The old state is properly deallocated.
    fn store(&self, new_state: Arc<MarketStateData>) {
        let new_ptr = Box::into_raw(Box::new(new_state));
        let old_ptr = self.state.swap(new_ptr, Ordering::AcqRel);

        // Deallocate the old state
        if !old_ptr.is_null() {
            unsafe {
                let _ = Box::from_raw(old_ptr);
            }
        }
    }

    /// Update a single spot market
    pub fn set_spot_market(&self, market: SpotMarket) {
        let current = self.load();
        let mut new_data = (*current).clone();
        new_data.set_spot_market(market);
        self.store(Arc::new(new_data));
    }

    /// Update a single perp market
    pub fn set_perp_market(&self, market: PerpMarket) {
        let current = self.load();
        let mut new_data = (*current).clone();
        new_data.set_perp_market(market);
        self.store(Arc::new(new_data));
    }

    /// Update spot oracle price
    pub fn set_spot_oracle_price(&self, market_index: u16, price: OraclePriceData) {
        let current = self.load();
        let mut new_data = (*current).clone();
        new_data.set_spot_oracle_price(market_index, price);
        self.store(Arc::new(new_data));
    }

    /// Update perp oracle price
    pub fn set_perp_oracle_price(&self, market_index: u16, price: OraclePriceData) {
        let current = self.load();
        let mut new_data = (*current).clone();
        new_data.set_perp_oracle_price(market_index, price);
        self.store(Arc::new(new_data));
    }

    /// Update spot pyth price
    pub fn set_spot_pyth_price(&self, market_index: u16, price: i64) {
        let current = self.load();
        let mut new_data = (*current).clone();
        new_data.set_spot_pyth_price(market_index, price);
        self.store(Arc::new(new_data));
    }

    /// Update perp pyth price
    pub fn set_perp_pyth_price(&self, market_index: u16, price: i64) {
        let current = self.load();
        let mut new_data = (*current).clone();
        new_data.set_perp_pyth_price(market_index, price);
        self.store(Arc::new(new_data));
    }

    pub fn get_perp_oracle_price(&self, market_index: u16) -> Option<OraclePriceData> {
        let current = self.load();
        current.perp_oracle_prices.get(&market_index).copied()
    }

    pub fn get_spot_oracle_price(&self, market_index: u16) -> Option<OraclePriceData> {
        let current = self.load();
        current.spot_oracle_prices.get(&market_index).copied()
    }

    pub fn get_spot_pyth_price(&self, market_index: u16) -> Option<OraclePriceData> {
        let current = self.load();
        current
            .spot_pyth_prices
            .get(&market_index)
            .map(|&price| OraclePriceData {
                price,
                confidence: 0,
                delay: 0,
                has_sufficient_number_of_data_points: true,
                sequence_id: None,
            })
    }

    pub fn get_perp_pyth_price(&self, market_index: u16) -> Option<OraclePriceData> {
        let current = self.load();
        current
            .perp_pyth_prices
            .get(&market_index)
            .map(|&price| OraclePriceData {
                price,
                confidence: 0,
                delay: 0,
                has_sufficient_number_of_data_points: true,
                sequence_id: None,
            })
    }
    /// Batch update multiple markets atomically
    ///
    /// This is more efficient than multiple individual updates as it only
    /// creates one new state and performs one atomic swap.
    pub fn batch_update<F>(&self, update_fn: F)
    where
        F: FnOnce(&mut MarketStateData),
    {
        let current = self.load();
        let mut new_data = (*current).clone();
        update_fn(&mut new_data);
        self.store(Arc::new(new_data));
    }
}

impl Default for MarketState {
    fn default() -> Self {
        Self::new(MarketStateData::default())
    }
}

impl Drop for MarketState {
    fn drop(&mut self) {
        let ptr = self.state.load(Ordering::Acquire);
        if !ptr.is_null() {
            unsafe {
                let _ = Box::from_raw(ptr);
            }
        }
    }
}

```

## File: crates/src/marketmap.rs
```
use std::{
    collections::HashSet,
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
};

use anchor_lang::{AccountDeserialize, AnchorDeserialize};
use dashmap::DashMap;
use drift_pubsub_client::PubsubClient;
use futures_util::{
    stream::{FuturesOrdered, FuturesUnordered},
    StreamExt,
};
use serde_json::json;
use solana_account_decoder_client_types::UiAccountEncoding;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_rpc_client_api::{
    config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},
    request::RpcRequest,
    response::{OptionalContext, RpcKeyedAccount},
};
use solana_sdk::{clock::Slot, commitment_config::CommitmentConfig, pubkey::Pubkey};

use crate::{
    accounts::State,
    constants::{self, derive_perp_market_account, derive_spot_market_account, state_account},
    drift_idl::types::OracleSource,
    grpc::AccountUpdate,
    memcmp::get_market_filter,
    types::{MapOf, EMPTY_ACCOUNT_CALLBACK},
    websocket_account_subscriber::WebsocketAccountSubscriber,
    DataAndSlot, MarketId, MarketType, PerpMarket, SdkResult, SpotMarket, UnsubHandle,
};

const LOG_TARGET: &str = "marketmap";

pub trait Market {
    const MARKET_TYPE: MarketType;
    fn market_index(&self) -> u16;
    fn oracle_info(&self) -> (MarketId, Pubkey, OracleSource);
}

impl Market for PerpMarket {
    const MARKET_TYPE: MarketType = MarketType::Perp;

    fn market_index(&self) -> u16 {
        self.market_index
    }

    fn oracle_info(&self) -> (MarketId, Pubkey, OracleSource) {
        (
            MarketId::perp(self.market_index),
            self.amm.oracle,
            self.amm.oracle_source,
        )
    }
}

impl Market for SpotMarket {
    const MARKET_TYPE: MarketType = MarketType::Spot;

    fn market_index(&self) -> u16 {
        self.market_index
    }

    fn oracle_info(&self) -> (MarketId, Pubkey, OracleSource) {
        (
            MarketId::spot(self.market_index),
            self.oracle,
            self.oracle_source,
        )
    }
}

/// Dynamic map of Drift Spot or Perp market accounts
///
/// Caller can subscribe to updates via Ws with `.subscribe(..)`
/// or drive the map by calling `.sync()` periodically
pub struct MarketMap<T: AnchorDeserialize + Send> {
    pub marketmap: Arc<DashMap<u16, DataAndSlot<T>, ahash::RandomState>>,
    subscriptions: DashMap<u16, UnsubHandle, ahash::RandomState>,
    latest_slot: Arc<AtomicU64>,
    pubsub: Arc<PubsubClient>,
    commitment: CommitmentConfig,
}

impl<T> MarketMap<T>
where
    T: AnchorDeserialize + Clone + Send + Sync + Market + 'static,
{
    pub const SUBSCRIPTION_ID: &'static str = "marketmap";

    pub fn new(pubsub: Arc<PubsubClient>, commitment: CommitmentConfig) -> Self {
        Self {
            subscriptions: Default::default(),
            marketmap: Arc::default(),
            latest_slot: Arc::new(AtomicU64::new(0)),
            pubsub,
            commitment,
        }
    }

    /// Return a reference to the internal map data structure
    pub fn map(&self) -> Arc<MapOf<u16, DataAndSlot<T>>> {
        Arc::clone(&self.marketmap)
    }

    /// Returns a hook for driving the map with new `Account` updates
    pub(crate) fn on_account_fn(&self) -> impl Fn(&AccountUpdate) {
        let marketmap = self.map();
        move |update: &AccountUpdate| {
            let market = T::deserialize(&mut &update.data[8..]).expect("deser market");
            let idx = market.market_index();
            marketmap.insert(
                idx,
                DataAndSlot {
                    slot: update.slot,
                    data: market,
                },
            );
        }
    }

    /// Subscribe to market account updates without callback
    pub async fn subscribe(&self, markets: &[MarketId]) -> SdkResult<()> {
        self.subscribe_inner(markets, EMPTY_ACCOUNT_CALLBACK).await
    }

    /// Subscribe to market account updates with callback
    pub async fn subscribe_with_callback<F>(
        &self,
        markets: &[MarketId],
        on_account: F,
    ) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        self.subscribe_inner(markets, on_account).await
    }

    /// Subscribe to market account updates
    async fn subscribe_inner<F>(&self, markets: &[MarketId], on_account: F) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        log::debug!(target: LOG_TARGET, "subscribing: {:?}", T::MARKET_TYPE);

        let markets = HashSet::<MarketId>::from_iter(markets.iter().copied());
        let mut pending_subscriptions =
            Vec::<(u16, WebsocketAccountSubscriber)>::with_capacity(markets.len());
        for market in markets {
            if self.subscriptions.contains_key(&market.index()) {
                continue;
            }

            let market_pubkey = match T::MARKET_TYPE {
                MarketType::Perp => derive_perp_market_account(market.index()),
                MarketType::Spot => derive_spot_market_account(market.index()),
            };
            let market_subscriber = WebsocketAccountSubscriber::new(
                Arc::clone(&self.pubsub),
                market_pubkey,
                self.commitment,
            );

            pending_subscriptions.push((market.index(), market_subscriber));
        }

        let futs_iter = pending_subscriptions.into_iter().map(|(idx, fut)| {
            let marketmap = Arc::clone(&self.marketmap);
            let latest_slot = self.latest_slot.clone();
            let on_account = on_account.clone();
            async move {
                let unsub = fut
                    .subscribe(Self::SUBSCRIPTION_ID, false, {
                        move |update| {
                            if update.slot > latest_slot.load(Ordering::Relaxed) {
                                latest_slot.store(update.slot, Ordering::Relaxed);
                            }
                            marketmap.insert(
                                idx,
                                DataAndSlot {
                                    slot: update.slot,
                                    data: T::deserialize(&mut &update.data.as_slice()[8..])
                                        .expect("valid market"),
                                },
                            );
                            on_account(update);
                        }
                    })
                    .await;
                (idx, unsub)
            }
        });

        let mut subscription_futs = FuturesUnordered::from_iter(futs_iter);
        while let Some((market, unsub)) = subscription_futs.next().await {
            log::debug!(target: LOG_TARGET, "subscribed market: {market:?}");
            self.subscriptions.insert(market, unsub?);
        }

        log::debug!(target: LOG_TARGET, "subscribed: {:?}", T::MARKET_TYPE);

        Ok(())
    }

    /// Returns whether the market is subscribed to Ws updates or not
    pub fn is_subscribed(&self, market_index: u16) -> bool {
        self.subscriptions.contains_key(&market_index)
    }

    /// Unsubscribe from updates for the given `markets`
    pub fn unsubscribe(&self, markets: &[MarketId]) -> SdkResult<()> {
        for market in markets {
            if let Some((market, unsub)) = self.subscriptions.remove(&market.index()) {
                let _ = unsub.send(());
                self.marketmap.remove(&market);
            }
        }
        log::debug!(target: LOG_TARGET, "unsubscribed markets: {markets:?}");

        Ok(())
    }

    /// Unsubscribe from all market updates
    pub fn unsubscribe_all(&self) -> SdkResult<()> {
        let all_markets: Vec<MarketId> = self
            .subscriptions
            .iter()
            .map(|x| (*x.key(), T::MARKET_TYPE).into())
            .collect();
        self.unsubscribe(&all_markets)
    }

    pub fn values(&self) -> Vec<T> {
        self.marketmap.iter().map(|x| x.data.clone()).collect()
    }

    /// Returns a list of oracle info for each market
    pub fn oracles(&self) -> Vec<(MarketId, Pubkey, OracleSource)> {
        self.values().iter().map(|x| x.oracle_info()).collect()
    }

    pub fn len(&self) -> usize {
        self.marketmap.len()
    }

    pub fn contains(&self, market_index: &u16) -> bool {
        self.marketmap.contains_key(market_index)
    }

    pub fn get(&self, market_index: &u16) -> Option<DataAndSlot<T>> {
        self.marketmap
            .get(market_index)
            .map(|market| market.clone())
    }

    /// Sync all market accounts
    pub async fn sync(&self, rpc: &RpcClient) -> SdkResult<()> {
        log::debug!(
            target: LOG_TARGET,
            "syncing marketmap: {:?}",
            T::MARKET_TYPE
        );
        let (markets, latest_slot) = get_market_accounts_with_fallback::<T>(rpc).await?;
        for market in markets {
            self.marketmap.insert(
                market.market_index(),
                DataAndSlot {
                    data: market,
                    slot: latest_slot,
                },
            );
        }
        self.latest_slot.store(latest_slot, Ordering::Relaxed);

        log::debug!(
            target: LOG_TARGET,
            "synced {:?} marketmap with {} markets",
            T::MARKET_TYPE,
            self.marketmap.len()
        );
        Ok(())
    }

    pub fn get_latest_slot(&self) -> u64 {
        self.latest_slot.load(Ordering::Relaxed)
    }
}

/// Fetch all market (program) accounts with multiple fallbacks
///
/// Tries progressively less intensive RPC methods for wider compatibility with RPC providers:
///     getProgramAccounts, getMultipleAccounts, lastly multiple getAccountInfo
///
/// Returns deserialized accounts and retrieved slot
pub async fn get_market_accounts_with_fallback<T: Market + AnchorDeserialize>(
    rpc: &RpcClient,
) -> SdkResult<(Vec<T>, Slot)> {
    let mut markets = Vec::<T>::default();

    let account_config = RpcAccountInfoConfig {
        commitment: Some(rpc.commitment()),
        encoding: Some(UiAccountEncoding::Base64Zstd),
        ..RpcAccountInfoConfig::default()
    };

    let gpa_config = RpcProgramAccountsConfig {
        filters: Some(vec![get_market_filter(T::MARKET_TYPE)]),
        account_config: account_config.clone(),
        with_context: Some(true),
        sort_results: None,
    };

    // try 'getProgramAccounts'
    let response: Result<OptionalContext<Vec<RpcKeyedAccount>>, _> = rpc
        .send(
            RpcRequest::GetProgramAccounts,
            json!([constants::PROGRAM_ID.to_string(), gpa_config]),
        )
        .await;

    if let Ok(OptionalContext::Context(accounts)) = response {
        for account in accounts.value {
            let market_data = account.account.data.decode().expect("Market data");
            let data = T::deserialize(&mut &market_data[8..]).expect("deserializes Market");
            markets.push(data);
        }
        return Ok((markets, accounts.context.slot));
    }
    log::debug!(
        target: LOG_TARGET,
        "syncing with getProgramAccounts failed: {:?}",
        T::MARKET_TYPE
    );

    let state_response = rpc
        .get_account_with_config(state_account(), account_config)
        .await
        .expect("state account fetch");

    let state_data = state_response.value.expect("state has data").data;
    let state =
        State::try_deserialize_unchecked(&mut state_data.as_slice()).expect("state deserializes");

    let market_pdas: Vec<Pubkey> = match T::MARKET_TYPE {
        MarketType::Spot => (0..state.number_of_spot_markets)
            .map(derive_spot_market_account)
            .collect(),
        MarketType::Perp => (0..state.number_of_markets)
            .map(derive_perp_market_account)
            .collect(),
    };

    // try 'getMultipleAccounts'
    let mut market_requests = FuturesOrdered::new();
    for market_chunk in market_pdas.chunks(64) {
        market_requests
            .push_back(rpc.get_multiple_accounts_with_commitment(market_chunk, rpc.commitment()));
    }

    while let Some(market_response) = market_requests.next().await {
        match market_response {
            Ok(data) => {
                for market in data.value {
                    match market {
                        Some(market) => {
                            markets.push(
                                T::deserialize(&mut &market.data.as_slice()[8..])
                                    .expect("market deserializes"),
                            );
                        }
                        None => {
                            log::warn!(
                                target: LOG_TARGET,
                                "failed to fetch market account (missing)"
                            );
                            break;
                        }
                    }
                }
            }
            Err(err) => {
                log::warn!(
                    target: LOG_TARGET,
                    "failed to fetch market accounts: {err:?}"
                );
                return Err(err)?;
            }
        }
    }
    if market_pdas.len() == markets.len() {
        return Ok((markets, state_response.context.slot));
    }
    log::debug!(
        target: LOG_TARGET,
        "syncing with getMultipleAccounts failed: {:?}",
        T::MARKET_TYPE
    );

    // try multiple 'getAccount's
    let mut market_requests =
        FuturesOrdered::from_iter(market_pdas.iter().map(|acc| rpc.get_account_data(acc)));

    while let Some(market_response) = market_requests.next().await {
        match market_response {
            Ok(data) => {
                markets
                    .push(T::deserialize(&mut &data.as_slice()[8..]).expect("market deserializes"));
            }
            Err(err) => {
                log::warn!("failed to fetch market account: {err:?}");
                return Err(err)?;
            }
        }
    }

    Ok((markets, state_response.context.slot))
}

#[cfg(test)]
mod tests {
    use std::sync::Arc;

    use drift_pubsub_client::PubsubClient;
    use solana_rpc_client::nonblocking::rpc_client::RpcClient;
    use solana_sdk::commitment_config::CommitmentConfig;

    use super::{get_market_accounts_with_fallback, MarketMap};
    use crate::{
        accounts::{PerpMarket, SpotMarket},
        utils::{get_ws_url, test_envs::devnet_endpoint},
        MarketId,
    };

    #[tokio::test]
    async fn marketmap_subscribe() {
        let map = MarketMap::<PerpMarket>::new(
            Arc::new(
                PubsubClient::new(&get_ws_url(&devnet_endpoint()).unwrap())
                    .await
                    .expect("ws connects"),
            ),
            CommitmentConfig::confirmed(),
        );

        assert!(map
            .subscribe(&[MarketId::perp(0), MarketId::perp(1), MarketId::perp(1)])
            .await
            .is_ok());
        assert!(map.is_subscribed(0));
        assert!(map.is_subscribed(1));
        assert_eq!(map.subscriptions.len(), 2);

        assert!(map.unsubscribe_all().is_ok());
        assert_eq!(map.subscriptions.len(), 0);
        assert!(!map.is_subscribed(0));
        assert!(!map.is_subscribed(1));
    }

    #[tokio::test]
    async fn get_market_accounts_with_fallback_works() {
        let result: Result<(Vec<PerpMarket>, _), _> =
            get_market_accounts_with_fallback::<PerpMarket>(&RpcClient::new(devnet_endpoint()))
                .await;

        assert!(result.is_ok_and(|r| r.0.len() > 0 && r.1 > 0));

        let result =
            get_market_accounts_with_fallback::<SpotMarket>(&RpcClient::new(devnet_endpoint()))
                .await;

        assert!(result.is_ok_and(|r| r.0.len() > 0 && r.1 > 0));
    }
}

#[cfg(feature = "rpc_tests")]
mod rpc_tests {
    use solana_sdk::commitment_config::CommitmentConfig;

    use super::*;
    use crate::utils::test_envs::mainnet_endpoint;

    #[tokio::test]
    async fn test_marketmap_perp() {
        let commitment = CommitmentConfig {
            commitment: CommitmentConfig::Processed,
        };

        let marketmap = MarketMap::<PerpMarket>::new(commitment, mainnet_endpoint(), true);
        marketmap.subscribe().await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;

        dbg!(marketmap.size());
        assert!(marketmap.size() == 28);

        dbg!(marketmap.get_latest_slot());

        marketmap.unsubscribe().await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;

        assert_eq!(marketmap.size(), 0);
        assert_eq!(marketmap.subscribed.load(Ordering::Relaxed), false);
    }

    #[tokio::test]
    async fn test_marketmap_spot() {
        let commitment = CommitmentConfig {
            commitment: CommitmentConfig::Processed,
        };

        let marketmap = MarketMap::<SpotMarket>::new(commitment, RPC, true);
        marketmap.subscribe().await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;

        dbg!(marketmap.size());
        assert!(marketmap.size() == 13);

        dbg!(marketmap.get_latest_slot());

        marketmap.unsubscribe().await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;

        assert_eq!(marketmap.size(), 0);
        assert_eq!(marketmap.subscribed.get(), false);
    }
}

```

## File: crates/src/math/account_list_builder.rs
```
use ahash::{HashMap, HashMapExt};
use arrayvec::ArrayVec;
use solana_sdk::{account::Account, pubkey::Pubkey};

use crate::{
    accounts::State,
    constants::{self, oracle_source_to_owner, state_account},
    ffi::{AccountWithKey, AccountsList},
    types::accounts::User,
    utils::zero_account_to_bytes,
    DriftClient, MarketId, SdkError, SdkResult,
};

/// Builds a list of users's associated spot, perp, and oracle accounts
///
/// ```example(no_run)
/// let mut builder = AccountsListBuilder::default();
/// let accounts_list = builder.try_build(client, user).expect("build accounts");
/// ```
#[derive(Default)]
pub struct AccountsListBuilder {
    /// placeholder account values populated with real market & oracle account data
    perp_accounts: ArrayVec<AccountWithKey, 16>,
    spot_accounts: ArrayVec<AccountWithKey, 16>,
    oracle_accounts: ArrayVec<AccountWithKey, 32>,
}

impl AccountsListBuilder {
    /// Constructs an accounts list from `user` positions sync
    ///
    /// * `client` - drift client instance
    /// * `user` - the account to build against
    /// * `force_markets` - additional market accounts that should be included in the account list
    ///
    /// It relies on the `client` being subscribed to all the necessary markets and oracles
    pub fn try_build(
        &mut self,
        client: &DriftClient,
        user: &User,
        force_markets: &[MarketId],
    ) -> SdkResult<AccountsList<'_>> {
        let mut oracle_markets = HashMap::<Pubkey, MarketId>::with_capacity(16);
        let drift_state_account = client.try_get_account::<State>(state_account())?;

        let force_spot_iter = force_markets
            .iter()
            .filter(|m| m.is_spot())
            .map(|m| m.index());

        let spot_market_idxs = ahash::HashSet::from_iter(
            user.spot_positions
                .iter()
                .filter(|p| !p.is_available())
                .map(|p| p.market_index)
                .chain(force_spot_iter)
                .chain(std::iter::once(MarketId::QUOTE_SPOT.index())),
        );

        for idx in spot_market_idxs {
            let market = client.try_get_spot_market_account(idx)?;
            oracle_markets.insert(market.oracle, MarketId::spot(market.market_index));
            self.spot_accounts.push(
                (
                    market.pubkey,
                    Account {
                        data: zero_account_to_bytes(market),
                        owner: constants::PROGRAM_ID,
                        ..Default::default()
                    },
                )
                    .into(),
            );
        }

        let force_perp_iter = force_markets
            .iter()
            .filter(|m| m.is_perp())
            .map(|m| m.index());
        let perp_market_idxs = ahash::HashSet::from_iter(
            user.perp_positions
                .iter()
                .filter(|p| !p.is_available())
                .map(|p| p.market_index)
                .chain(force_perp_iter),
        );

        for idx in perp_market_idxs {
            let market = client.try_get_perp_market_account(idx)?;
            oracle_markets.insert(market.amm.oracle, MarketId::perp(market.market_index));
            self.perp_accounts.push(
                (
                    market.pubkey,
                    Account {
                        data: zero_account_to_bytes(market),
                        owner: constants::PROGRAM_ID,
                        ..Default::default()
                    },
                )
                    .into(),
            );
        }

        let mut latest_oracle_slot = 0;
        for (oracle_key, market) in oracle_markets.iter() {
            let oracle = client
                .try_get_oracle_price_data_and_slot(*market)
                .ok_or(SdkError::NoMarketData(*market))?;

            latest_oracle_slot = oracle.slot.max(latest_oracle_slot);
            let oracle_owner = oracle_source_to_owner(client.context, oracle.source);
            self.oracle_accounts.push(
                (
                    *oracle_key,
                    Account {
                        data: oracle.raw,
                        owner: oracle_owner,
                        ..Default::default()
                    },
                )
                    .into(),
            );
        }

        Ok(AccountsList {
            perp_markets: self.perp_accounts.as_mut_slice(),
            spot_markets: self.spot_accounts.as_mut_slice(),
            oracles: self.oracle_accounts.as_mut_slice(),
            oracle_guard_rails: Some(drift_state_account.oracle_guard_rails),
            latest_slot: latest_oracle_slot,
        })
    }

    /// Constructs an accounts list from `user` positions
    /// fetching from RPC as necessary
    ///
    /// * `client` - drift client instance
    /// * `user` - the account to build against
    /// * `force_markets` - additional market accounts that should be included in the account list
    ///
    /// like `try_build` but will fall back to network queries to fetch market/oracle accounts as required
    /// if the client is already subscribed to necessary market/oracles then no network requests are made.
    pub async fn build(
        &mut self,
        client: &DriftClient,
        user: &User,
        force_markets: &[MarketId],
    ) -> SdkResult<AccountsList<'_>> {
        let mut oracle_markets = HashMap::<Pubkey, MarketId>::with_capacity(16);
        let drift_state_account = client.try_get_account::<State>(state_account())?;

        // TODO: could batch the requests
        let force_spot_iter = force_markets
            .iter()
            .filter(|m| m.is_spot())
            .map(|m| m.index());
        let spot_market_idxs = ahash::HashSet::from_iter(
            user.spot_positions
                .iter()
                .filter(|p| !p.is_available())
                .map(|p| p.market_index)
                .chain(force_spot_iter)
                .chain(std::iter::once(MarketId::QUOTE_SPOT.index())),
        );

        for market_idx in spot_market_idxs.iter() {
            let market = client.get_spot_market_account(*market_idx).await?;
            oracle_markets.insert(market.oracle, MarketId::spot(market.market_index));

            self.spot_accounts.push(
                (
                    market.pubkey,
                    Account {
                        data: zero_account_to_bytes(market),
                        owner: constants::PROGRAM_ID,
                        ..Default::default()
                    },
                )
                    .into(),
            );
        }

        let force_perp_iter = force_markets
            .iter()
            .filter(|m| m.is_perp())
            .map(|m| m.index());
        let perp_market_idxs = ahash::HashSet::from_iter(
            user.perp_positions
                .iter()
                .filter(|p| !p.is_available())
                .map(|p| p.market_index)
                .chain(force_perp_iter),
        );

        for market_idx in perp_market_idxs.iter() {
            let market = client.get_perp_market_account(*market_idx).await?;
            oracle_markets.insert(market.amm.oracle, MarketId::perp(market.market_index));

            self.perp_accounts.push(
                (
                    market.pubkey,
                    Account {
                        data: zero_account_to_bytes(market),
                        owner: constants::PROGRAM_ID,
                        ..Default::default()
                    },
                )
                    .into(),
            );
        }

        let mut latest_oracle_slot = 0;
        for (oracle_key, market) in oracle_markets.iter() {
            let oracle = client.get_oracle_price_data_and_slot(*market).await?;

            latest_oracle_slot = oracle.slot.max(latest_oracle_slot);
            let oracle_owner = oracle_source_to_owner(client.context, oracle.source);
            self.oracle_accounts.push(
                (
                    *oracle_key,
                    Account {
                        data: oracle.raw,
                        owner: oracle_owner,
                        ..Default::default()
                    },
                )
                    .into(),
            );
        }

        Ok(AccountsList {
            perp_markets: self.perp_accounts.as_mut_slice(),
            spot_markets: self.spot_accounts.as_mut_slice(),
            oracles: self.oracle_accounts.as_mut_slice(),
            oracle_guard_rails: Some(drift_state_account.oracle_guard_rails),
            latest_slot: latest_oracle_slot,
        })
    }
}

```

## File: crates/src/math/auction.rs
```
use std::cmp::min;

use crate::{
    drift_idl::types::{Order, OrderType, PositionDirection},
    is_one_of_variant,
};

pub fn is_auction_complete(order: &Order, slot: u64) -> bool {
    if order.auction_duration == 0 {
        return true;
    }

    (order.slot + order.auction_duration as u64) < slot
}

#[track_caller]
pub fn get_auction_price(order: &Order, slot: u64, price: i64) -> i128 {
    if is_one_of_variant(
        &order.order_type,
        &[
            OrderType::Market,
            OrderType::TriggerMarket,
            OrderType::Limit,
            OrderType::TriggerLimit,
        ],
    ) {
        get_auction_price_for_fixed_auction(order, slot)
    } else if order.order_type == OrderType::Oracle {
        get_auction_price_for_oracle_offset_auction(order, slot, price)
    } else {
        panic!("Invalid order type")
    }
}

fn get_auction_price_for_fixed_auction(order: &Order, slot: u64) -> i128 {
    let slots_elapsed = slot - order.slot;

    let auction_start_price = order.auction_start_price as i128;
    let auction_end_price = order.auction_end_price as i128;
    let delta_denominator: i128 = order.auction_duration.into();
    let delta_numerator: i128 = min(slots_elapsed, order.auction_duration as u64).into();

    if delta_denominator == 0 {
        return auction_start_price;
    }

    match order.direction {
        PositionDirection::Long => {
            let price_delta =
                auction_end_price - auction_start_price * delta_numerator / delta_denominator;
            auction_start_price + price_delta
        }
        PositionDirection::Short => {
            let price_delta =
                auction_start_price - auction_end_price * delta_numerator / delta_denominator;
            auction_start_price - price_delta
        }
    }
}

fn get_auction_price_for_oracle_offset_auction(
    order: &Order,
    slot: u64,
    oracle_price: i64,
) -> i128 {
    let slots_elapsed = slot - order.slot;

    let auction_start_price = order.auction_start_price as i128;
    let auction_end_price = order.auction_end_price as i128;
    let delta_denominator: i128 = order.auction_duration.into();
    let delta_numerator: i128 = min(slots_elapsed, order.auction_duration as u64).into();

    if delta_denominator == 0 {
        return auction_start_price;
    }

    let price_offset = match order.direction {
        PositionDirection::Long => {
            let price_delta =
                auction_end_price - auction_start_price * delta_numerator / delta_denominator;
            auction_start_price + price_delta
        }
        PositionDirection::Short => {
            let price_delta =
                auction_start_price - auction_end_price * delta_numerator / delta_denominator;
            auction_start_price - price_delta
        }
    };

    oracle_price as i128 + price_offset
}

```

## File: crates/src/math/constants.rs
```
// PRECISIONS
pub const AMM_RESERVE_PRECISION: u128 = 1_000_000_000; //expo = -9;
pub const AMM_RESERVE_PRECISION_I128: i128 = (AMM_RESERVE_PRECISION) as i128;
pub const BASE_PRECISION: u128 = AMM_RESERVE_PRECISION; //expo = -9;
pub const BASE_PRECISION_I128: i128 = AMM_RESERVE_PRECISION_I128;
pub const BASE_PRECISION_U64: u64 = AMM_RESERVE_PRECISION as u64; //expo = -9;
pub const BASE_PRECISION_I64: i64 = AMM_RESERVE_PRECISION_I128 as i64; //expo = -9;
pub const PERP_DECIMALS: u32 = 9;

pub const PRICE_PRECISION: u128 = 1_000_000; //expo = -6;
pub const PRICE_PRECISION_I128: i128 = PRICE_PRECISION as i128;
pub const PRICE_PRECISION_U64: u64 = 1_000_000; //expo = -6;
pub const PRICE_PRECISION_I64: i64 = 1_000_000; //expo = -6;

pub const PEG_PRECISION: u128 = 1_000_000; //expo = -6
pub const PEG_PRECISION_I128: i128 = PEG_PRECISION as i128; //expo = -6

pub const QUOTE_PRECISION: u128 = 1_000_000; // expo = -6
pub const QUOTE_PRECISION_I128: i128 = 1_000_000; // expo = -6
pub const QUOTE_PRECISION_I64: i64 = 1_000_000; // expo = -6
pub const QUOTE_PRECISION_U64: u64 = 1_000_000; // expo = -6

pub const FUNDING_RATE_BUFFER: u128 = 1_000; // expo = -3
pub const FUNDING_RATE_BUFFER_I128: i128 = FUNDING_RATE_BUFFER as i128; // expo = -3

pub const MARGIN_PRECISION: u32 = 10_000; // expo = -4
pub const MARGIN_PRECISION_U128: u128 = 10_000; // expo = -4
pub const SPOT_WEIGHT_PRECISION: u32 = MARGIN_PRECISION; // expo = -4
pub const SPOT_WEIGHT_PRECISION_U128: u128 = SPOT_WEIGHT_PRECISION as u128; // expo = -4
pub const SPOT_WEIGHT_PRECISION_I128: i128 = SPOT_WEIGHT_PRECISION as i128; // expo = -4

pub const LIQUIDATION_PCT_PRECISION: u128 = 10_000;

pub const SPOT_BALANCE_PRECISION: u128 = 1_000_000_000; // expo = -9
pub const SPOT_BALANCE_PRECISION_U64: u64 = 1_000_000_000; // expo = -9
pub const SPOT_CUMULATIVE_INTEREST_PRECISION: u128 = 10_000_000_000; // expo = -10

pub const PERCENTAGE_PRECISION: u128 = 1_000_000; // expo -6 (represents 100%)
pub const PERCENTAGE_PRECISION_I128: i128 = PERCENTAGE_PRECISION as i128;
pub const PERCENTAGE_PRECISION_U64: u64 = PERCENTAGE_PRECISION as u64;
pub const PERCENTAGE_PRECISION_I64: i64 = PERCENTAGE_PRECISION as i64;
pub const TEN_BPS: i128 = PERCENTAGE_PRECISION_I128 / 1000;
pub const TEN_BPS_I64: i64 = TEN_BPS as i64;
pub const TWO_PT_TWO_PCT: i128 = 22_000;

pub const BID_ASK_SPREAD_PRECISION: u64 = PERCENTAGE_PRECISION as u64; // expo = -6
pub const BID_ASK_SPREAD_PRECISION_I64: i64 = (BID_ASK_SPREAD_PRECISION) as i64;
pub const BID_ASK_SPREAD_PRECISION_U128: u128 = BID_ASK_SPREAD_PRECISION as u128; // expo = -6
pub const BID_ASK_SPREAD_PRECISION_I128: i128 = BID_ASK_SPREAD_PRECISION as i128; // expo = -6

pub const CONCENTRATION_PRECISION: u128 = PERCENTAGE_PRECISION; // expo 6
pub const IF_FACTOR_PRECISION: u128 = PERCENTAGE_PRECISION; // expo 6

pub const SPOT_UTILIZATION_PRECISION: u128 = PERCENTAGE_PRECISION; // expo = -6
pub const SPOT_UTILIZATION_PRECISION_U32: u32 = PERCENTAGE_PRECISION as u32; // expo = -6
pub const SPOT_RATE_PRECISION: u128 = PERCENTAGE_PRECISION; // expo = -6
pub const SPOT_RATE_PRECISION_U32: u32 = PERCENTAGE_PRECISION as u32; // expo = -6
pub const LIQUIDATION_FEE_PRECISION: u32 = PERCENTAGE_PRECISION as u32; // expo = -6
pub const LIQUIDATION_FEE_PRECISION_U128: u128 = LIQUIDATION_FEE_PRECISION as u128; // expo = -6
pub const SPOT_IMF_PRECISION: u32 = PERCENTAGE_PRECISION as u32; // expo = -6

pub const LAMPORTS_PER_SOL_I64: i64 = 1_000_000_000;

pub const AMM_TIMES_PEG_TO_QUOTE_PRECISION_RATIO_I128: i128 =
    AMM_TIMES_PEG_TO_QUOTE_PRECISION_RATIO as i128;
pub const PRICE_TIMES_AMM_TO_QUOTE_PRECISION_RATIO_I128: i128 =
    PRICE_TIMES_AMM_TO_QUOTE_PRECISION_RATIO as i128; // expo 9

pub const LIQUIDATION_FEE_TO_MARGIN_PRECISION_RATIO: u32 = // expo 2
    LIQUIDATION_FEE_PRECISION / MARGIN_PRECISION;
pub const LIQUIDATION_FEE_TO_MARGIN_PRECISION_RATIO_U128: u128 = // expo 2
    LIQUIDATION_FEE_TO_MARGIN_PRECISION_RATIO as u128;
pub const LIQUIDATION_FEE_INCREASE_PER_SLOT: u32 = LIQUIDATION_FEE_PRECISION / 1_000_000; // .01 bps per slot

pub const PRICE_TIMES_AMM_TO_QUOTE_PRECISION_RATIO: u128 =
    PRICE_PRECISION * AMM_TO_QUOTE_PRECISION_RATIO; // expo 9

pub const AMM_TIMES_PEG_TO_QUOTE_PRECISION_RATIO: u128 =
    AMM_RESERVE_PRECISION * PEG_PRECISION / QUOTE_PRECISION; // expo: 9

pub const AMM_TO_QUOTE_PRECISION_RATIO: u128 = AMM_RESERVE_PRECISION / QUOTE_PRECISION; // expo: 3

pub const LIQUIDATION_FEE_ADJUST_GRACE_PERIOD_SLOTS: u64 = 1_500; // ~10 minutes

```

## File: crates/src/math/leverage.rs
```
use solana_sdk::pubkey::Pubkey;

use super::{
    account_list_builder::AccountsListBuilder,
    constants::{AMM_RESERVE_PRECISION, BASE_PRECISION, MARGIN_PRECISION, PRICE_PRECISION},
};
use crate::{
    accounts::PerpMarket,
    ffi::{
        calculate_margin_requirement_and_total_collateral_and_liability_info, MarginCalculation,
        MarginContextMode,
    },
    types::accounts::User,
    ContractType, DriftClient, MarginMode, MarginRequirementType, MarketId, PositionDirection,
    SdkError, SdkResult,
};

pub fn get_leverage(client: &DriftClient, user: &User) -> SdkResult<u128> {
    let mut builder = AccountsListBuilder::default();
    let mut accounts = builder.try_build(client, user, &[])?;
    let margin_calculation = calculate_margin_requirement_and_total_collateral_and_liability_info(
        user,
        &mut accounts,
        MarginContextMode::StandardMaintenance,
    )?;

    let net_asset_value = calculate_net_asset_value(
        margin_calculation.total_collateral,
        margin_calculation.total_spot_liability_value,
    );

    if net_asset_value == i128::MIN {
        return Err(SdkError::MathError(
            "Net asset value is less than i128::MIN",
        ));
    }

    let total_liability_value = margin_calculation
        .total_perp_liability_value
        .checked_add(margin_calculation.total_spot_liability_value)
        .expect("fits u128");

    let leverage = calculate_leverage(total_liability_value, net_asset_value);

    Ok(leverage)
}

pub fn get_spot_asset_value(client: &DriftClient, user: &User) -> SdkResult<i128> {
    let mut builder = AccountsListBuilder::default();
    let mut accounts = builder.try_build(client, user, &[])?;

    let margin_calculation = calculate_margin_requirement_and_total_collateral_and_liability_info(
        user,
        &mut accounts,
        MarginContextMode::StandardMaintenance,
    )?;

    Ok(margin_calculation.total_spot_asset_value
        - margin_calculation.total_spot_liability_value as i128)
}

fn calculate_net_asset_value(total_collateral: i128, total_spot_liability_value: u128) -> i128 {
    if total_spot_liability_value <= i128::MAX as u128 {
        total_collateral - total_spot_liability_value as i128
    } else {
        let overflow = total_spot_liability_value - i128::MAX as u128;
        if overflow <= total_collateral as u128 + 1 {
            total_collateral - (i128::MAX as u128 - (overflow - 1)) as i128
        } else {
            i128::MIN
        }
    }
}

fn calculate_leverage(total_liability_value: u128, net_asset_value: i128) -> u128 {
    let sign: i128 = if net_asset_value < 0 { -1 } else { 1 };

    let leverage = (total_liability_value as f64) / (net_asset_value.abs() as f64);

    sign as u128 * (leverage * PRICE_PRECISION as f64) as u128
}

/// Provides margin calculation helpers for User accounts
///
/// sync, requires client is subscribed to necessary markets beforehand
pub trait UserMargin {
    /// Calculate user's max. trade size in USDC for a given market and direction
    ///
    /// * `user` - the user account
    /// * `market` - the market to trade
    /// * `trade_side` - the direction of the trade
    ///
    /// Returns max USDC trade size (PRICE_PRECISION)
    fn max_trade_size(
        &self,
        user: &Pubkey,
        market: MarketId,
        trade_side: PositionDirection,
    ) -> SdkResult<u64>;
    fn calculate_perp_buying_power(
        &self,
        user: &User,
        market: &PerpMarket,
        oracle_price: i64,
        collateral_buffer: u64,
    ) -> SdkResult<u128>;
    /// Calculate the user's live margin information
    fn calculate_margin_info(&self, user: &User) -> SdkResult<MarginCalculation>;
}

impl UserMargin for DriftClient {
    fn calculate_margin_info(&self, user: &User) -> SdkResult<MarginCalculation> {
        let mut builder = AccountsListBuilder::default();
        let mut accounts = builder.try_build(self, user, &[])?;
        calculate_margin_requirement_and_total_collateral_and_liability_info(
            user,
            &mut accounts,
            MarginContextMode::StandardMaintenance,
        )
    }
    fn max_trade_size(
        &self,
        user: &Pubkey,
        market: MarketId,
        trade_side: PositionDirection,
    ) -> SdkResult<u64> {
        let oracle = self
            .try_get_oracle_price_data_and_slot(market)
            .ok_or(SdkError::NoMarketData(market))?;
        let oracle_price = oracle.data.price;
        let user_account = self.try_get_account::<User>(user)?;

        if market.is_perp() {
            let market_account = self.try_get_perp_market_account(market.index())?;

            let position = user_account
                .get_perp_position(market_account.market_index)
                .map_err(|_| SdkError::NoMarketData(MarketId::perp(market_account.market_index)))?;
            // add any position we have on the opposite side of the current trade
            // because we can "flip" the size of this position without taking any extra leverage.
            let is_reduce_only = position.base_asset_amount.is_negative() as u8 != trade_side as u8;
            let opposite_side_liability_value = calculate_perp_liability_value(
                position.base_asset_amount,
                oracle_price,
                market_account.contract_type == ContractType::Prediction,
            );

            let lp_buffer = ((oracle_price as u64 * market_account.amm.order_step_size)
                / AMM_RESERVE_PRECISION as u64)
                * position.lp_shares.max(1);

            let max_position_size = self.calculate_perp_buying_power(
                &user_account,
                &market_account,
                oracle_price,
                lp_buffer,
            )?;

            Ok(max_position_size as u64 + opposite_side_liability_value * is_reduce_only as u64)
        } else {
            // TODO: implement for spot
            Err(SdkError::Generic("spot market unimplemented".to_string()))
        }
    }
    /// Calculate buying power = free collateral / initial margin ratio
    ///
    /// Returns buying power in `QUOTE_PRECISION` units
    fn calculate_perp_buying_power(
        &self,
        user: &User,
        market: &PerpMarket,
        oracle_price: i64,
        collateral_buffer: u64,
    ) -> SdkResult<u128> {
        let position = user
            .get_perp_position(market.market_index)
            .map_err(|_| SdkError::NoMarketData(MarketId::perp(market.market_index)))?;

        let worst_case_base_amount =
            position.worst_case_base_asset_amount(oracle_price, market.contract_type)?;

        let margin_info = self.calculate_margin_info(user)?;
        let free_collateral = margin_info
            .get_free_collateral()
            .checked_sub(collateral_buffer as u128)
            .ok_or(SdkError::MathError("underflow"))?;

        let margin_ratio = market
            .get_margin_ratio(
                worst_case_base_amount.unsigned_abs(),
                MarginRequirementType::Initial,
                user.margin_mode == MarginMode::HighLeverage,
            )
            .expect("got margin ratio");
        let margin_ratio = margin_ratio.max(user.max_margin_ratio);

        Ok((free_collateral * MARGIN_PRECISION as u128) / margin_ratio as u128)
    }
}

#[inline]
pub fn calculate_perp_liability_value(
    base_asset_amount: i64,
    price: i64,
    is_prediction_market: bool,
) -> u64 {
    let max_prediction_price = PRICE_PRECISION as i64;
    let max_price =
        max_prediction_price * base_asset_amount.is_negative() as i64 * is_prediction_market as i64;
    (base_asset_amount * (max_price - price) / BASE_PRECISION as i64).unsigned_abs()
}

#[cfg(test)]
mod tests {
    use super::calculate_perp_liability_value;

    #[test]
    fn calculate_perp_liability_value_works() {
        use crate::math::constants::{BASE_PRECISION_I64, PRICE_PRECISION_I64};
        // test values taken from TS sdk
        assert_eq!(
            calculate_perp_liability_value(1 * BASE_PRECISION_I64, 5 * PRICE_PRECISION_I64, false),
            5_000_000
        );
        assert_eq!(
            calculate_perp_liability_value(-1 * BASE_PRECISION_I64, 5 * PRICE_PRECISION_I64, false),
            5_000_000
        );
        assert_eq!(
            calculate_perp_liability_value(-1 * BASE_PRECISION_I64, 10_000, true),
            990_000
        );
        assert_eq!(
            calculate_perp_liability_value(1 * BASE_PRECISION_I64, 90_000, true),
            90_000
        );
    }
}

#[cfg(feature = "rpc_tests")]
mod rpc_tests {
    use solana_sdk::signature::Keypair;

    use super::*;
    use crate::{
        utils::test_envs::{mainnet_endpoint, test_keypair},
        Context, RpcAccountProvider, Wallet,
    };

    #[tokio::test]
    async fn test_get_spot_market_value() {
        let wallet: Wallet = test_keypair().into();
        let pubkey = wallet.authority().clone();
        let drift_client = DriftClient::new(
            Context::MainNet,
            RpcAccountProvider::new(&mainnet_endpoint()),
            wallet,
        )
        .await
        .expect("drift client");
        drift_client.subscribe().await.expect("subscribe");

        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;

        let mut user = crate::user::DriftUser::new(
            Wallet::derive_user_account(&pubkey, 0, &constants::PROGRAM_ID),
            drift_client.clone(),
        )
        .await
        .expect("drift user");
        user.subscribe().await.expect("subscribe");

        let spot_asset_value = get_spot_asset_value(&drift_client, &user.get_user_account())
            .expect("spot asset value");
        println!("spot_asset_value: {}", spot_asset_value);
    }

    #[tokio::test]
    async fn test_leverage() {
        let wallet: Wallet = test_keypair().into();
        let pubkey = wallet.authority().clone();
        let drift_client = DriftClient::new(
            Context::MainNet,
            RpcAccountProvider::new & (mainnet_endpoint()),
            wallet,
        )
        .await
        .expect("drift client");
        drift_client.subscribe().await.expect("subscribe");

        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;

        let mut user = crate::user::DriftUser::new(
            Wallet::derive_user_account(&pubkey, 0, &constants::PROGRAM_ID),
            drift_client.clone(),
        )
        .await
        .expect("drift user");
        user.subscribe().await.expect("subscribe");

        let leverage = get_leverage(&drift_client, &user.get_user_account()).expect("leverage");
        println!("leverage: {}", leverage);
    }
}

```

## File: crates/src/math/liquidation.rs
```
//!
//! liquidation and margin helpers
//!

use std::ops::Neg;

use super::get_oracle_normalization_factor;
use crate::{
    ffi::{
        self, calculate_margin_requirement_and_total_collateral_and_liability_info, AccountsList,
        MarginContextMode,
    },
    math::{
        account_list_builder::AccountsListBuilder,
        constants::{
            AMM_RESERVE_PRECISION_I128, BASE_PRECISION_I128, LIQUIDATION_PCT_PRECISION,
            MARGIN_PRECISION, QUOTE_PRECISION, QUOTE_PRECISION_I128, QUOTE_PRECISION_I64,
            SPOT_WEIGHT_PRECISION,
        },
    },
    types::{
        accounts::{PerpMarket, SpotMarket, User},
        MarginRequirementType, PerpPosition,
    },
    DriftClient, MarginMode, MarketId, SdkError, SdkResult, SpotPosition,
};

/// Info on a position's liquidation price and unrealized PnL
#[derive(Debug)]
pub struct LiquidationAndPnlInfo {
    // PRICE_PRECISION
    pub liquidation_price: i64,
    // PRICE_PRECISION
    pub unrealized_pnl: i128,
    // The oracle price used in calculations
    // BASE_PRECISION
    pub oracle_price: i64,
}

/// Calculate the liquidation price and unrealized PnL of a user's perp position (given by `market_index`)
pub async fn calculate_liquidation_price_and_unrealized_pnl(
    client: &DriftClient,
    user: &User,
    market_index: u16,
) -> SdkResult<LiquidationAndPnlInfo> {
    let perp_market = client
        .program_data()
        .perp_market_config_by_index(market_index)
        .expect("market exists");

    let position = user
        .get_perp_position(market_index)
        .map_err(|_| SdkError::NoPosition(market_index))?;

    // build a list of all user positions for margin calculations
    let mut builder = AccountsListBuilder::default();
    let mut accounts_list = builder.build(client, user, &[]).await?;

    let oracle = accounts_list
        .oracles
        .iter()
        .find(|o| o.key == perp_market.amm.oracle)
        .expect("oracle loaded");
    let oracle_source = perp_market.amm.oracle_source;
    let oracle_price = ffi::get_oracle_price(
        oracle_source,
        &mut (oracle.key, oracle.account.clone()),
        accounts_list.latest_slot,
    )?
    .price;

    // matching spot market e.g. sol-perp => SOL spot
    let spot_market = client
        .program_data()
        .spot_market_configs()
        .iter()
        .find(|x| x.oracle == perp_market.amm.oracle);

    Ok(LiquidationAndPnlInfo {
        unrealized_pnl: calculate_unrealized_pnl_inner(&position, oracle_price)?,
        liquidation_price: calculate_liquidation_price_inner(
            user,
            perp_market,
            spot_market,
            oracle_price,
            &mut accounts_list,
        )?,
        oracle_price,
    })
}

/// Calculate the unrealized pnl for user perp position, given by `market_index`
pub async fn calculate_unrealized_pnl(
    client: &DriftClient,
    user: &User,
    market_index: u16,
) -> SdkResult<i128> {
    if let Ok(position) = user.get_perp_position(market_index) {
        let oracle_price = client
            .get_oracle_price_data_and_slot(MarketId::perp(market_index))
            .await
            .map(|x| x.data.price)?;

        calculate_unrealized_pnl_inner(&position, oracle_price)
    } else {
        Err(SdkError::NoPosition(market_index))
    }
}

pub fn calculate_unrealized_pnl_inner(
    position: &PerpPosition,
    oracle_price: i64,
) -> SdkResult<i128> {
    let base_asset_value = (position.base_asset_amount as i128 * oracle_price.max(0) as i128)
        / AMM_RESERVE_PRECISION_I128;
    let pnl = base_asset_value + position.quote_entry_amount as i128;

    Ok(pnl)
}

/// Calculate the liquidation price of a user's perp position (given by `market_index`)
///
/// Returns the liquidation price (PRICE_PRECISION / 1e6)
pub async fn calculate_liquidation_price(
    client: &DriftClient,
    user: &User,
    market_index: u16,
) -> SdkResult<i64> {
    let mut accounts_builder = AccountsListBuilder::default();
    let mut account_maps = accounts_builder.build(client, user, &[]).await?;
    let perp_market = client
        .program_data()
        .perp_market_config_by_index(market_index)
        .expect("market exists");

    let oracle = client
        .get_oracle_price_data_and_slot(MarketId::perp(market_index))
        .await?;

    // matching spot market e.g. sol-perp => SOL spot
    let spot_market = client
        .program_data()
        .spot_market_configs()
        .iter()
        .find(|x| x.oracle == perp_market.amm.oracle);

    calculate_liquidation_price_inner(
        user,
        perp_market,
        spot_market,
        oracle.data.price,
        &mut account_maps,
    )
}

/// Calculate liquidation price of a users perp postion
/// considers all of the users open positions
///
/// - `perp_market` Market info of the perp position
/// - `spot_market` Corresponding spot market (e.g. SOL-perp => SOL spot)
/// - `accounts` collection of all accounts (markets, oracles) to perform margin calculations
///
pub fn calculate_liquidation_price_inner(
    user: &User,
    perp_market: &PerpMarket,
    spot_market: Option<&SpotMarket>,
    oracle_price: i64,
    accounts: &mut AccountsList,
) -> SdkResult<i64> {
    let margin_calculation = calculate_margin_requirement_and_total_collateral_and_liability_info(
        user,
        accounts,
        MarginContextMode::StandardMaintenance,
    )?;

    // calculate perp free collateral delta
    let perp_position = user
        .get_perp_position(perp_market.market_index)
        .map_err(|_| SdkError::NoPosition(perp_market.market_index))?;

    let perp_free_collateral_delta = calculate_perp_free_collateral_delta(
        &perp_position,
        perp_market,
        oracle_price,
        user.margin_mode,
    );

    // user holding spot asset case
    let mut spot_free_collateral_delta = 0;
    if let Some(spot_market) = spot_market {
        if let Ok(spot_position) = user.get_spot_position(spot_market.market_index) {
            if !spot_position.is_available() {
                spot_free_collateral_delta =
                    calculate_spot_free_collateral_delta(&spot_position, spot_market);
                let (numerator, denominator) = get_oracle_normalization_factor(
                    perp_market.amm.oracle_source,
                    spot_market.oracle_source,
                );
                spot_free_collateral_delta = (((spot_free_collateral_delta as i128)
                    * numerator as i128)
                    / denominator as i128) as i64;
            }
        }
    }

    // calculate liquidation price
    // what price delta causes free collateral == 0
    let free_collateral = margin_calculation.get_free_collateral();
    let free_collateral_delta = perp_free_collateral_delta + spot_free_collateral_delta;
    if free_collateral_delta == 0 {
        return Ok(-1);
    }
    let liquidation_price_delta =
        (free_collateral as i64 * QUOTE_PRECISION_I64) / free_collateral_delta;

    let liquidation_price = (oracle_price - liquidation_price_delta).max(-1);
    Ok(liquidation_price)
}

pub fn calculate_perp_free_collateral_delta(
    position: &PerpPosition,
    market: &PerpMarket,
    oracle_price: i64,
    margin_mode: MarginMode,
) -> i64 {
    let current_base_asset_amount = position.base_asset_amount;

    let worst_case_base_amount = position
        .worst_case_base_asset_amount(oracle_price, market.contract_type)
        .unwrap();
    let margin_ratio = market
        .get_margin_ratio(
            worst_case_base_amount.unsigned_abs(),
            MarginRequirementType::Maintenance,
            margin_mode.is_high_leverage_mode(MarginRequirementType::Maintenance),
        )
        .unwrap();
    let margin_ratio = (margin_ratio as i64 * QUOTE_PRECISION_I64) / MARGIN_PRECISION as i64;

    if worst_case_base_amount == 0 {
        return 0;
    }

    let mut fcd = if current_base_asset_amount > 0 {
        ((QUOTE_PRECISION_I64 - margin_ratio) as i128 * current_base_asset_amount as i128)
            / BASE_PRECISION_I128
    } else {
        ((QUOTE_PRECISION_I64.neg() - margin_ratio) as i128
            * current_base_asset_amount.abs() as i128)
            / BASE_PRECISION_I128
    } as i64;

    let order_base_amount = worst_case_base_amount - current_base_asset_amount as i128;
    if order_base_amount != 0 {
        fcd -= ((margin_ratio as i128 * order_base_amount.abs()) / BASE_PRECISION_I128) as i64;
    }

    fcd
}

pub fn calculate_spot_free_collateral_delta(position: &SpotPosition, market: &SpotMarket) -> i64 {
    let market_precision = 10_i128.pow(market.decimals);
    let signed_token_amount = position.get_signed_token_amount(market).unwrap();
    let delta = if signed_token_amount > 0 {
        let weight = market
            .get_asset_weight(
                signed_token_amount.unsigned_abs(),
                0, // unused by Maintenance margin type, hence 0
                MarginRequirementType::Maintenance,
            )
            .unwrap() as i128;
        (((QUOTE_PRECISION_I128 * weight) / SPOT_WEIGHT_PRECISION as i128) * signed_token_amount)
            / market_precision
    } else {
        let weight = market
            .get_liability_weight(
                signed_token_amount.unsigned_abs(),
                MarginRequirementType::Maintenance,
            )
            .unwrap() as i128;
        (((QUOTE_PRECISION_I128.neg() * weight) / SPOT_WEIGHT_PRECISION as i128)
            * signed_token_amount.abs())
            / market_precision
    };

    delta.try_into().expect("ftis i64")
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub struct MarginRequirementInfo {
    /// initial margin requirement (PRICE_PRECISION)
    pub initial: u128,
    /// maintenance margin requirement (PRICE_PRECISION)
    pub maintenance: u128,
}

/// Calculate the margin requirements of `user`
pub fn calculate_margin_requirements(
    client: &DriftClient,
    user: &User,
) -> SdkResult<MarginRequirementInfo> {
    calculate_margin_requirements_inner(
        user,
        &mut AccountsListBuilder::default().try_build(client, user, &[])?,
    )
}

/// Calculate the margin requirements of `user` (internal)
fn calculate_margin_requirements_inner(
    user: &User,
    accounts: &mut AccountsList,
) -> SdkResult<MarginRequirementInfo> {
    let maintenance_result = calculate_margin_requirement_and_total_collateral_and_liability_info(
        user,
        accounts,
        MarginContextMode::StandardMaintenance,
    )?;

    let initial_result = calculate_margin_requirement_and_total_collateral_and_liability_info(
        user,
        accounts,
        MarginContextMode::StandardInitial,
    )?;

    Ok(MarginRequirementInfo {
        maintenance: maintenance_result.margin_requirement,
        initial: initial_result.margin_requirement,
    })
}

pub fn calculate_max_pct_to_liquidate(
    user: &User,
    margin_shortage: u128,
    slot: u64,
    initial_pct_to_liquidate: u128,
    liquidation_duration: u128,
) -> SdkResult<u128> {
    // if margin shortage is tiny, accelerate liquidation
    if margin_shortage < 50 * QUOTE_PRECISION {
        return Ok(LIQUIDATION_PCT_PRECISION);
    }

    if slot < user.last_active_slot {
        return Err(SdkError::MathError("slot < user.last_active_slot"));
    }
    let slots_elapsed = slot - user.last_active_slot;

    let pct_freeable = slots_elapsed as u128 * LIQUIDATION_PCT_PRECISION
        .checked_div(liquidation_duration) // ~ 1 minute if per slot is 400ms
        .unwrap_or(LIQUIDATION_PCT_PRECISION) // if divide by zero, default to 100%
        + initial_pct_to_liquidate
        .min(LIQUIDATION_PCT_PRECISION);

    let total_margin_shortage = margin_shortage + user.liquidation_margin_freed as u128;
    let max_margin_freed = total_margin_shortage * pct_freeable / LIQUIDATION_PCT_PRECISION;

    let margin_freeable = max_margin_freed.saturating_sub(user.liquidation_margin_freed as u128);

    Ok((margin_freeable * LIQUIDATION_PCT_PRECISION) / margin_shortage)
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CollateralInfo {
    /// total collateral (QUOTE_PRECISION)
    pub total: i128,
    /// free collateral (QUOTE_PRECISION)
    pub free: i128,
}

pub fn calculate_collateral(
    client: &DriftClient,
    user: &User,
    margin_requirement_type: MarginRequirementType,
) -> SdkResult<CollateralInfo> {
    let mut accounts_builder = AccountsListBuilder::default();
    calculate_collateral_inner(
        user,
        &mut accounts_builder.try_build(client, user, &[])?,
        margin_requirement_type,
    )
}

fn calculate_collateral_inner(
    user: &User,
    accounts: &mut AccountsList,
    margin_requirement_type: MarginRequirementType,
) -> SdkResult<CollateralInfo> {
    let result = calculate_margin_requirement_and_total_collateral_and_liability_info(
        user,
        accounts,
        MarginContextMode::StandardCustom(margin_requirement_type),
    )?;

    Ok(CollateralInfo {
        total: result.total_collateral,
        free: result.get_free_collateral() as i128,
    })
}

#[cfg(test)]
mod tests {
    use solana_sdk::{account::Account, pubkey::Pubkey};

    use super::*;
    use crate::{
        constants::{
            ids::pyth_program,
            {self},
        },
        drift_idl::types::{HistoricalOracleData, MarketStatus, OracleSource, SpotPosition, AMM},
        math::constants::{
            AMM_RESERVE_PRECISION, BASE_PRECISION_I64, LIQUIDATION_FEE_PRECISION, PEG_PRECISION,
            PRICE_PRECISION_I64, SPOT_BALANCE_PRECISION, SPOT_BALANCE_PRECISION_U64,
            SPOT_CUMULATIVE_INTEREST_PRECISION,
        },
        utils::test_utils::*,
        MarketId,
    };

    const SOL_ORACLE: Pubkey = solana_sdk::pubkey!("J83w4HKfqxwcq3BEMMkPFSppX3gqekLyLJBexebFVkix");
    const BTC_ORACLE: Pubkey = solana_sdk::pubkey!("GVXRSBjFk6e6J3NbVPXohDJetcTjaeeuykUpbQF8UoMU");

    fn sol_spot_market() -> SpotMarket {
        SpotMarket {
            market_index: 1,
            oracle_source: OracleSource::Pyth,
            oracle: SOL_ORACLE,
            cumulative_deposit_interest: SPOT_CUMULATIVE_INTEREST_PRECISION.into(),
            cumulative_borrow_interest: SPOT_CUMULATIVE_INTEREST_PRECISION.into(),
            decimals: 9,
            initial_asset_weight: 8 * SPOT_WEIGHT_PRECISION / 10,
            maintenance_asset_weight: 9 * SPOT_WEIGHT_PRECISION / 10,
            initial_liability_weight: 12 * SPOT_WEIGHT_PRECISION / 10,
            maintenance_liability_weight: 11 * SPOT_WEIGHT_PRECISION / 10,
            liquidator_fee: LIQUIDATION_FEE_PRECISION / 1000,
            deposit_balance: (1_000 * SPOT_BALANCE_PRECISION).into(),
            ..SpotMarket::default()
        }
    }

    fn sol_perp_market() -> PerpMarket {
        PerpMarket {
            amm: AMM {
                base_asset_reserve: (100 * AMM_RESERVE_PRECISION).into(),
                quote_asset_reserve: (100 * AMM_RESERVE_PRECISION).into(),
                bid_base_asset_reserve: (101 * AMM_RESERVE_PRECISION).into(),
                bid_quote_asset_reserve: (99 * AMM_RESERVE_PRECISION).into(),
                ask_base_asset_reserve: (99 * AMM_RESERVE_PRECISION).into(),
                ask_quote_asset_reserve: (101 * AMM_RESERVE_PRECISION).into(),
                sqrt_k: (100 * AMM_RESERVE_PRECISION).into(),
                peg_multiplier: (100 * PEG_PRECISION).into(),
                order_step_size: 10_000_000,
                oracle: SOL_ORACLE,
                ..AMM::default()
            },
            market_index: 0,
            margin_ratio_initial: 1000,
            margin_ratio_maintenance: 500,
            unrealized_pnl_maintenance_asset_weight: SPOT_WEIGHT_PRECISION,
            status: MarketStatus::Initialized,
            ..PerpMarket::default()
        }
    }

    fn btc_perp_market() -> PerpMarket {
        PerpMarket {
            amm: AMM {
                base_asset_reserve: (100 * AMM_RESERVE_PRECISION).into(),
                quote_asset_reserve: (100 * AMM_RESERVE_PRECISION).into(),
                bid_base_asset_reserve: (101 * AMM_RESERVE_PRECISION).into(),
                bid_quote_asset_reserve: (99 * AMM_RESERVE_PRECISION).into(),
                ask_base_asset_reserve: (99 * AMM_RESERVE_PRECISION).into(),
                ask_quote_asset_reserve: (101 * AMM_RESERVE_PRECISION).into(),
                sqrt_k: (100 * AMM_RESERVE_PRECISION).into(),
                oracle: BTC_ORACLE,
                ..AMM::default()
            },
            market_index: 1,
            margin_ratio_initial: 1000,
            margin_ratio_maintenance: 500,
            imf_factor: 1000, // 1_000/1_000_000 = .001
            unrealized_pnl_initial_asset_weight: SPOT_WEIGHT_PRECISION,
            unrealized_pnl_maintenance_asset_weight: SPOT_WEIGHT_PRECISION,
            status: MarketStatus::Initialized,
            ..PerpMarket::default()
        }
    }

    fn usdc_spot_market() -> SpotMarket {
        SpotMarket {
            market_index: 0,
            oracle_source: OracleSource::QuoteAsset,
            cumulative_deposit_interest: SPOT_CUMULATIVE_INTEREST_PRECISION.into(),
            decimals: 6,
            initial_asset_weight: SPOT_WEIGHT_PRECISION,
            maintenance_asset_weight: SPOT_WEIGHT_PRECISION,
            deposit_balance: (100_000 * SPOT_BALANCE_PRECISION).into(),
            liquidator_fee: 0,
            historical_oracle_data: HistoricalOracleData {
                last_oracle_price: PRICE_PRECISION_I64,
                last_oracle_conf: 0,
                last_oracle_delay: 0,
                last_oracle_price_twap: PRICE_PRECISION_I64,
                last_oracle_price_twap5min: PRICE_PRECISION_I64,
                ..HistoricalOracleData::default()
            },
            ..SpotMarket::default()
        }
    }

    #[cfg(feature = "rpc_tests")]
    #[tokio::test]
    async fn calculate_liq_price() {
        use solana_client::nonblocking::rpc_client::RpcClient;

        use crate::{utils::test_envs::mainnet_endpoint, Wallet};

        let wallet = Wallet::read_only(solana_sdk::pubkey!(
            "DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2"
        ));
        let client = DriftClient::new(
            crate::Context::MainNet,
            RpcClient::new(mainnet_endpoint()),
            wallet.clone(),
        )
        .await
        .unwrap();
        assert!(client.subscribe().await.is_ok());
        let user = client
            .get_user_account(&wallet.sub_account(0))
            .await
            .unwrap();

        dbg!(calculate_liquidation_price_and_unrealized_pnl(&client, &user, 4).unwrap());
    }

    #[cfg(feature = "rpc_tests")]
    #[tokio::test]
    async fn calculate_margin_requirements_works() {
        use solana_client::nonblocking::rpc_client::RpcClient;

        use crate::{utils::test_envs::mainnet_endpoint, Wallet};

        let wallet = Wallet::read_only(solana_sdk::pubkey!(
            "DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2"
        ));
        let client = DriftClient::new(
            crate::Context::MainNet,
            RpcClient::new(mainnet_endpoint()),
            wallet.clone(),
        )
        .await
        .unwrap();
        client.subscribe().await.unwrap();
        let user = client
            .get_user_account(&wallet.sub_account(0))
            .await
            .unwrap();

        dbg!(calculate_margin_requirements(&client, &user).await.unwrap());
    }

    #[test]
    fn calculate_margin_requirements_works() {
        let sol_perp_index = 0;
        let btc_perp_index = 1;
        let mut user = User::default();
        user.perp_positions[0] = PerpPosition {
            market_index: sol_perp_index,
            base_asset_amount: -2 * BASE_PRECISION_I64,
            ..Default::default()
        };
        user.perp_positions[1] = PerpPosition {
            market_index: btc_perp_index,
            base_asset_amount: (1 * BASE_PRECISION_I64) / 20,
            ..Default::default()
        };
        user.spot_positions[0] = SpotPosition {
            market_index: MarketId::QUOTE_SPOT.index(),
            scaled_balance: 1_000 * SPOT_BALANCE_PRECISION_U64,
            ..Default::default()
        };

        let mut sol_oracle_price = get_pyth_price(100, 6);
        crate::create_account_info!(sol_oracle_price, &SOL_ORACLE, pyth_program::ID, sol_oracle);
        crate::create_anchor_account_info!(
            sol_perp_market(),
            Pubkey::new_unique(),
            PerpMarket,
            sol_perp
        );
        let mut btc_oracle_price = get_pyth_price(50_000, 6);
        crate::create_account_info!(btc_oracle_price, &BTC_ORACLE, pyth_program::ID, btc_oracle);
        crate::create_anchor_account_info!(
            usdc_spot_market(),
            Pubkey::new_unique(),
            SpotMarket,
            usdc_spot
        );
        crate::create_anchor_account_info!(
            btc_perp_market(),
            Pubkey::new_unique(),
            PerpMarket,
            btc_perp
        );

        let mut perps = [sol_perp, btc_perp];
        let mut spot = [usdc_spot];
        let mut oracles = [sol_oracle, btc_oracle];
        let mut accounts_map = AccountsList::new(&mut perps, &mut spot, &mut oracles);

        let margin_info = calculate_margin_requirements_inner(&user, &mut accounts_map).unwrap();

        assert_eq!(
            MarginRequirementInfo {
                initial: 27_000_0000,
                maintenance: 135_000_000
            },
            margin_info
        );
    }

    #[test]
    fn liquidation_price_short() {
        let sol_perp_index = 0;
        let mut user = User::default();
        user.perp_positions[0] = PerpPosition {
            market_index: sol_perp_index,
            base_asset_amount: -2 * BASE_PRECISION_I64,
            ..Default::default()
        };
        user.spot_positions[0] = SpotPosition {
            market_index: MarketId::QUOTE_SPOT.index(),
            scaled_balance: 250_u64 * SPOT_BALANCE_PRECISION_U64,
            ..Default::default()
        };

        let sol_usdc_price = 100;

        let mut sol_oracle_price = get_pyth_price(sol_usdc_price, 6);
        crate::create_account_info!(sol_oracle_price, &SOL_ORACLE, pyth_program::ID, sol_oracle);
        crate::create_anchor_account_info!(
            usdc_spot_market(),
            constants::PROGRAM_ID,
            SpotMarket,
            usdc_spot
        );
        crate::create_anchor_account_info!(
            sol_perp_market(),
            constants::PROGRAM_ID,
            PerpMarket,
            sol_perp
        );
        let mut perps = [sol_perp];
        let mut spot = [usdc_spot];
        let mut oracles = [sol_oracle];
        let mut accounts_map = AccountsList::new(&mut perps, &mut spot, &mut oracles);

        let sol_spot = sol_spot_market();
        let sol_perp = sol_perp_market();
        let liquidation_price = calculate_liquidation_price_inner(
            &user,
            &sol_perp,
            Some(&sol_spot),
            sol_usdc_price * QUOTE_PRECISION_I64,
            &mut accounts_map,
        )
        .unwrap();

        dbg!(liquidation_price);
        assert_eq!(liquidation_price, 119_047_619);
    }

    #[test]
    fn liquidation_price_long() {
        let mut user = User::default();
        user.perp_positions[0] = PerpPosition {
            market_index: sol_perp_market().market_index,
            base_asset_amount: 5 * BASE_PRECISION_I64,
            quote_asset_amount: -5 * (100 * QUOTE_PRECISION_I64),
            ..Default::default()
        };
        user.spot_positions[0] = SpotPosition {
            market_index: MarketId::QUOTE_SPOT.index(),
            scaled_balance: 250_u64 * SPOT_BALANCE_PRECISION_U64,
            ..Default::default()
        };
        let sol_usdc_price = 100;
        let mut sol_oracle_price = get_pyth_price(sol_usdc_price, 6);
        crate::create_account_info!(sol_oracle_price, &SOL_ORACLE, pyth_program::ID, sol_oracle);
        crate::create_anchor_account_info!(
            usdc_spot_market(),
            constants::PROGRAM_ID,
            SpotMarket,
            usdc_spot
        );
        crate::create_anchor_account_info!(
            sol_perp_market(),
            constants::PROGRAM_ID,
            PerpMarket,
            sol_perp
        );

        let mut perps = [sol_perp];
        let mut spot = [usdc_spot];
        let mut oracles = [sol_oracle];
        let mut accounts_map = AccountsList::new(&mut perps, &mut spot, &mut oracles);

        let liquidation_price = calculate_liquidation_price_inner(
            &user,
            &sol_perp_market(),
            Some(&sol_spot_market()),
            sol_usdc_price * QUOTE_PRECISION_I64,
            &mut accounts_map,
        )
        .unwrap();

        dbg!(liquidation_price);
        assert_eq!(liquidation_price, 52_631_579);
    }

    #[test]
    fn liquidation_price_short_with_spot_balance() {
        let mut user = User::default();
        user.perp_positions[0] = PerpPosition {
            market_index: btc_perp_market().market_index,
            base_asset_amount: -250_000_000, // 0.25btc
            ..Default::default()
        };
        user.spot_positions[0] = SpotPosition {
            market_index: 1,
            scaled_balance: 200 * SPOT_BALANCE_PRECISION_U64,
            ..Default::default()
        };
        let sol_usdc_price = 100;
        let mut sol_oracle_price = get_pyth_price(sol_usdc_price, 6);
        crate::create_account_info!(sol_oracle_price, &SOL_ORACLE, pyth_program::ID, sol_oracle);

        let btc_usdc_price = 40_000;
        let mut btc_oracle_price = get_pyth_price(btc_usdc_price, 6);
        crate::create_account_info!(btc_oracle_price, &BTC_ORACLE, pyth_program::ID, btc_oracle);
        crate::create_anchor_account_info!(
            usdc_spot_market(),
            constants::PROGRAM_ID,
            SpotMarket,
            usdc_spot
        );
        crate::create_anchor_account_info!(
            sol_spot_market(),
            constants::PROGRAM_ID,
            SpotMarket,
            sol_spot
        );
        crate::create_anchor_account_info!(
            btc_perp_market(),
            constants::PROGRAM_ID,
            PerpMarket,
            btc_perp
        );
        let mut perps = [btc_perp];
        let mut spot = [usdc_spot, sol_spot];
        let mut oracles = [sol_oracle, btc_oracle];
        let mut accounts_map = AccountsList::new(&mut perps, &mut spot, &mut oracles);
        let liquidation_price = calculate_liquidation_price_inner(
            &user,
            &btc_perp_market(),
            None,
            btc_usdc_price * QUOTE_PRECISION_I64,
            &mut accounts_map,
        )
        .unwrap();
        assert_eq!(liquidation_price, 68_571_428_571);
    }

    #[test]
    fn liquidation_price_long_with_spot_balance() {
        let sol_usdc_price = 100;
        let mut user = User::default();
        user.perp_positions[0] = PerpPosition {
            market_index: sol_perp_market().market_index,
            base_asset_amount: 5 * BASE_PRECISION_I64,
            quote_asset_amount: -5 * (100 * QUOTE_PRECISION_I64),
            ..Default::default()
        };
        user.spot_positions[0] = SpotPosition {
            market_index: 1,
            scaled_balance: 2 * SPOT_BALANCE_PRECISION_U64,
            ..Default::default()
        };

        let mut sol_oracle_price = get_pyth_price(sol_usdc_price, 6);
        crate::create_account_info!(sol_oracle_price, &SOL_ORACLE, pyth_program::ID, sol_oracle);
        crate::create_anchor_account_info!(
            usdc_spot_market(),
            constants::PROGRAM_ID,
            SpotMarket,
            usdc_spot
        );
        crate::create_anchor_account_info!(
            sol_spot_market(),
            constants::PROGRAM_ID,
            SpotMarket,
            sol_spot
        );
        crate::create_anchor_account_info!(
            sol_perp_market(),
            constants::PROGRAM_ID,
            PerpMarket,
            sol_perp
        );

        let mut perps = [sol_perp];
        let mut spot = [usdc_spot, sol_spot];
        let mut sol_oracle = [sol_oracle];
        let mut accounts_map = AccountsList::new(&mut perps, &mut spot, &mut sol_oracle);

        let liquidation_price = calculate_liquidation_price_inner(
            &user,
            &sol_perp_market(),
            Some(&sol_spot_market()),
            sol_usdc_price * QUOTE_PRECISION_I64,
            &mut accounts_map,
        )
        .unwrap();
        dbg!(liquidation_price);
        assert_eq!(liquidation_price, 76_335_878);
    }

    #[test]
    fn liquidation_price_no_positions() {
        let user = User::default();
        let mut accounts_map = AccountsList::new(&mut [], &mut [], &mut []);
        assert!(calculate_liquidation_price_inner(
            &user,
            &sol_perp_market(),
            None,
            100,
            &mut accounts_map
        )
        .is_err());
    }

    #[test]
    fn unrealized_pnl_short() {
        let position = PerpPosition {
            market_index: sol_perp_market().market_index,
            base_asset_amount: -1 * BASE_PRECISION_I64,
            quote_entry_amount: 80 * QUOTE_PRECISION_I64,
            ..Default::default()
        };
        let sol_usdc_price = 60 * QUOTE_PRECISION_I64;

        let unrealized_pnl = calculate_unrealized_pnl_inner(&position, sol_usdc_price).unwrap();

        dbg!(unrealized_pnl);
        // entry at $80, upnl at $60
        assert_eq!(unrealized_pnl, 20_i128 * QUOTE_PRECISION_I64 as i128);
    }

    #[test]
    fn liquidation_price_hedged_short() {
        let mut user = User::default();
        user.perp_positions[0] = PerpPosition {
            market_index: sol_perp_market().market_index,
            base_asset_amount: -10 * BASE_PRECISION_I64,
            quote_entry_amount: 80 * QUOTE_PRECISION_I64,
            ..Default::default()
        };
        user.spot_positions[0] = SpotPosition {
            market_index: sol_spot_market().market_index,
            scaled_balance: 10 * SPOT_BALANCE_PRECISION as u64,
            ..Default::default()
        };
        let sol_usdc_price = 60;
        let mut sol_oracle_price = get_pyth_price(sol_usdc_price, 6);

        crate::create_account_info!(sol_oracle_price, &SOL_ORACLE, pyth_program::ID, sol_oracle);

        crate::create_anchor_account_info!(
            usdc_spot_market(),
            Pubkey::new_unique(),
            SpotMarket,
            usdc_spot
        );
        crate::create_anchor_account_info!(
            sol_perp_market(),
            Pubkey::new_unique(),
            PerpMarket,
            sol_perp
        );
        crate::create_anchor_account_info!(
            sol_spot_market(),
            Pubkey::new_unique(),
            SpotMarket,
            sol_spot
        );

        let mut perps = [sol_perp];
        let mut spot = [usdc_spot, sol_spot];
        let mut sol_oracle = [sol_oracle];
        let mut accounts_map = AccountsList::new(&mut perps, &mut spot, &mut sol_oracle);

        let liq_price = calculate_liquidation_price_inner(
            &user,
            &sol_perp_market(),
            Some(&sol_spot_market()),
            sol_usdc_price * QUOTE_PRECISION_I64,
            &mut accounts_map,
        )
        .expect("got price");
        dbg!(liq_price);

        assert_eq!(liq_price, 60 * QUOTE_PRECISION_I64);
    }

    #[test]
    fn unrealized_pnl_long() {
        let position = PerpPosition {
            market_index: sol_perp_market().market_index,
            base_asset_amount: 1 * BASE_PRECISION_I64,
            quote_entry_amount: -80 * QUOTE_PRECISION_I64,
            ..Default::default()
        };
        let sol_usdc_price = 100 * QUOTE_PRECISION_I64;

        let unrealized_pnl = calculate_unrealized_pnl_inner(&position, sol_usdc_price).unwrap();

        dbg!(unrealized_pnl);
        // entry at $80, upnl at $100
        assert_eq!(unrealized_pnl, 20_i128 * QUOTE_PRECISION_I64 as i128);
    }
}

```

## File: crates/src/math/mod.rs
```
use crate::{
    drift_idl::{
        errors::ErrorCode,
        types::{MarginCalculationMode, MarginRequirementType, MarketIdentifier},
    },
    math::constants::{
        BASE_PRECISION, LIQUIDATION_FEE_ADJUST_GRACE_PERIOD_SLOTS,
        LIQUIDATION_FEE_INCREASE_PER_SLOT, LIQUIDATION_FEE_PRECISION_U128,
        LIQUIDATION_FEE_TO_MARGIN_PRECISION_RATIO, PRICE_PRECISION,
        PRICE_TIMES_AMM_TO_QUOTE_PRECISION_RATIO,
    },
    types::{OracleSource, PositionDirection, SdkError, SdkResult},
};

pub mod account_list_builder;
pub mod auction;
pub mod constants;
pub mod leverage;
pub mod liquidation;
pub mod order;

#[derive(Clone, Copy, Debug)]
pub struct MarginContext {
    pub margin_type: MarginRequirementType,
    pub mode: MarginCalculationMode,
    pub strict: bool,
    pub margin_buffer: u128,
    pub fuel_bonus_numerator: i64,
    pub fuel_bonus: u64,
    pub fuel_perp_delta: Option<(u16, i64)>,
    pub fuel_spot_deltas: [(u16, i128); 2],
}

impl MarginContext {
    pub fn standard(margin_type: MarginRequirementType) -> Self {
        Self {
            margin_type,
            mode: MarginCalculationMode::Standard {
                track_open_orders_fraction: false,
            },
            strict: false,
            margin_buffer: 0,
            fuel_bonus_numerator: 0,
            fuel_bonus: 0,
            fuel_perp_delta: None,
            fuel_spot_deltas: [(0, 0); 2],
        }
    }

    pub fn strict(mut self, strict: bool) -> Self {
        self.strict = strict;
        self
    }

    pub fn margin_buffer(mut self, margin_buffer: u32) -> Self {
        self.margin_buffer = margin_buffer as u128;
        self
    }

    // how to change the user's spot position to match how it was prior to instruction change
    // i.e. diffs are ADDED to perp
    pub fn fuel_perp_delta(mut self, market_index: u16, delta: i64) -> Self {
        self.fuel_perp_delta = Some((market_index, delta));
        self
    }

    pub fn fuel_spot_delta(mut self, market_index: u16, delta: i128) -> Self {
        self.fuel_spot_deltas[0] = (market_index, delta);
        self
    }

    pub fn fuel_spot_deltas(mut self, deltas: [(u16, i128); 2]) -> Self {
        self.fuel_spot_deltas = deltas;
        self
    }

    pub fn track_open_orders_fraction(mut self) -> Result<Self, ErrorCode> {
        match self.mode {
            MarginCalculationMode::Standard {
                track_open_orders_fraction: ref mut track,
            } => {
                *track = true;
            }
            _ => {
                return Err(ErrorCode::InvalidMarginCalculation);
            }
        }
        Ok(self)
    }

    pub fn liquidation(margin_buffer: u32) -> Self {
        Self {
            margin_type: MarginRequirementType::Maintenance,
            mode: MarginCalculationMode::Liquidation {
                market_to_track_margin_requirement: None,
            },
            margin_buffer: margin_buffer as u128,
            strict: false,
            fuel_bonus_numerator: 0,
            fuel_bonus: 0,
            fuel_perp_delta: None,
            fuel_spot_deltas: [(0, 0); 2],
        }
    }

    pub fn track_market_margin_requirement(
        mut self,
        market_identifier: MarketIdentifier,
    ) -> Result<Self, ErrorCode> {
        match self.mode {
            MarginCalculationMode::Liquidation {
                market_to_track_margin_requirement: ref mut market_to_track,
                ..
            } => {
                *market_to_track = Some(market_identifier);
            }
            _ => {
                return Err(ErrorCode::InvalidMarginCalculation);
            }
        }
        Ok(self)
    }
}

/// Returns (numerator, denominator) pair to normalize prices from 2 different oracle source
fn get_oracle_normalization_factor(a: OracleSource, b: OracleSource) -> (u64, u64) {
    match (a, b) {
        // 1M scaling relationships
        (OracleSource::PythLazer, OracleSource::PythLazer1M)
        | (OracleSource::PythPull, OracleSource::Pyth1MPull) => (1_000_000, 1),
        (OracleSource::PythLazer1M, OracleSource::PythLazer)
        | (OracleSource::Pyth1MPull, OracleSource::PythPull) => (1, 1_000_000),
        // 1K scaling relationships
        (OracleSource::PythLazer, OracleSource::PythLazer1K)
        | (OracleSource::PythPull, OracleSource::Pyth1KPull) => (1_000, 1),
        (OracleSource::PythLazer1K, OracleSource::PythLazer)
        | (OracleSource::Pyth1KPull, OracleSource::PythPull) => (1, 1_000),
        _ => (1, 1),
    }
}

/// ## panics if `tick_size` is 0
#[inline]
pub fn standardize_price(price: u64, tick_size: u64, direction: PositionDirection) -> u64 {
    if price == 0 {
        return 0;
    }

    let remainder = price.rem_euclid(tick_size);

    if remainder == 0 {
        return price;
    }

    match direction {
        PositionDirection::Long => price - remainder,
        PositionDirection::Short => (price + tick_size) - remainder,
    }
}

/// ## panics if `tick_size` is 0
#[inline]
pub fn standardize_price_i64(price: i64, tick_size: u64, direction: PositionDirection) -> i64 {
    if price == 0 {
        return 0;
    }

    let remainder = price.rem_euclid(tick_size as i64);

    if remainder == 0 {
        return price;
    }

    match direction {
        PositionDirection::Long => price - remainder,
        PositionDirection::Short => (price + tick_size as i64) - remainder,
    }
}

/// ## panics if `step_size` is 0
#[inline]
pub fn standardize_base_asset_amount(base_asset_amount: u64, step_size: u64) -> u64 {
    let remainder = base_asset_amount.rem_euclid(step_size);
    base_asset_amount - remainder
}

/// ## panics if `step_size` is 0
#[inline]
pub fn standardize_base_asset_amount_ceil(base_asset_amount: u64, step_size: u64) -> u64 {
    let next_tick = (step_size.abs_diff(base_asset_amount % step_size)) % step_size;
    base_asset_amount + next_tick
}

pub fn get_liquidation_fee(
    base_liquidation_fee: u32,
    max_liquidation_fee: u32,
    last_active_user_slot: u64,
    current_slot: u64,
) -> SdkResult<u32> {
    if current_slot < last_active_user_slot {
        return Err(SdkError::MathError("slot < user.last_active_slot"));
    }
    let slots_elapsed = current_slot - last_active_user_slot;

    if slots_elapsed < LIQUIDATION_FEE_ADJUST_GRACE_PERIOD_SLOTS {
        return Ok(base_liquidation_fee);
    }

    let liquidation_fee = base_liquidation_fee
        .saturating_add((slots_elapsed * LIQUIDATION_FEE_INCREASE_PER_SLOT as u64) as u32);

    Ok(liquidation_fee.min(max_liquidation_fee))
}

pub fn calculate_base_asset_amount_to_cover_margin_shortage(
    margin_shortage: u128,
    margin_ratio: u32,
    liquidation_fee: u32,
    if_liquidation_fee: u32,
    oracle_price: i64,
    quote_oracle_price: i64,
) -> SdkResult<u64> {
    let margin_ratio = margin_ratio * LIQUIDATION_FEE_TO_MARGIN_PRECISION_RATIO;

    if oracle_price == 0 || margin_ratio <= liquidation_fee {
        return Ok(u64::MAX);
    }

    let adjusted_margin = (margin_ratio - liquidation_fee) as u128;

    let oracle_product = oracle_price as i128 * quote_oracle_price as i128;
    let price_term = (oracle_product * adjusted_margin as i128)
        / (PRICE_PRECISION as i128 * LIQUIDATION_FEE_PRECISION_U128 as i128);

    let fee_term =
        oracle_price as i128 * if_liquidation_fee as i128 / LIQUIDATION_FEE_PRECISION_U128 as i128;

    let divisor = price_term - fee_term;

    if divisor <= 0 {
        return Ok(u64::MAX);
    }

    let result =
        margin_shortage.saturating_mul(PRICE_TIMES_AMM_TO_QUOTE_PRECISION_RATIO) / divisor as u128;

    Ok(result as u64) // truncate at u64 max
}

pub fn calculate_perp_if_fee(
    margin_shortage: u128,
    user_base_asset_amount: u64,
    margin_ratio: u32,
    liquidator_fee: u32,
    oracle_price: i64,
    quote_oracle_price: i64,
    max_if_liquidation_fee: u32,
) -> u32 {
    if oracle_price == 0
        || quote_oracle_price == 0
        || user_base_asset_amount == 0
        || margin_ratio <= liquidator_fee
    {
        return 0;
    }

    let margin_ratio = margin_ratio * LIQUIDATION_FEE_TO_MARGIN_PRECISION_RATIO;
    let price = (oracle_price as u128 * quote_oracle_price as u128) / PRICE_PRECISION;

    // implied_if_fee = (margin_shortage / (user_base_asset_amount * price)) * scaling
    let fee_component = ((margin_shortage * BASE_PRECISION * PRICE_PRECISION)
        / ((user_base_asset_amount as u128) * price)) as u32; // cap at u32::MAX

    // implied_if_fee = (margin_ratio - liquidator_fee - fee_component) * 95%
    let implied_if_fee = margin_ratio
        .saturating_sub(liquidator_fee)
        .saturating_sub(fee_component)
        .saturating_mul(19)
        / 20;

    implied_if_fee.min(max_if_liquidation_fee)
}

```

## File: crates/src/math/order.rs
```
use crate::{
    drift_idl::types::{Order, OrderType, PositionDirection},
    ffi::OraclePriceData,
    math::auction::{get_auction_price, is_auction_complete},
};

pub fn get_limit_price(
    order: &Order,
    oracle_price_data: &OraclePriceData,
    slot: u64,
    fallback_price: Option<u64>,
) -> u64 {
    if has_auction_price(order, slot) {
        get_auction_price(order, slot, oracle_price_data.price)
            .try_into()
            .unwrap()
    } else if order.oracle_price_offset != 0 {
        (oracle_price_data.price as i128 + order.oracle_price_offset as i128)
            .try_into()
            .unwrap()
    } else if order.price == 0 {
        match fallback_price {
            Some(price) => price,
            None => {
                dbg!(order);
                panic!("Order price is 0 and no fallback price provided");
            }
        }
    } else {
        order.price
    }
}

fn has_auction_price(order: &Order, slot: u64) -> bool {
    !is_auction_complete(order, slot)
        && (order.auction_start_price != 0 || order.auction_end_price != 0)
}

pub fn is_resting_limit_order(order: &Order, slot: u64) -> bool {
    if !order.is_limit_order() {
        return false;
    }

    if order.order_type == OrderType::TriggerLimit {
        return match order.direction {
            PositionDirection::Long if order.trigger_price < order.price => {
                return false;
            }
            PositionDirection::Short if order.trigger_price > order.price => {
                return false;
            }
            _ => is_auction_complete(order, slot),
        };
    };

    order.post_only || is_auction_complete(order, slot)
}

```

## File: crates/src/memcmp.rs
```
use anchor_lang::Discriminator;
use solana_rpc_client_api::filter::{Memcmp, RpcFilterType};

use crate::types::{
    accounts::{PerpMarket, SpotMarket, User, UserStats},
    MarketType,
};

pub fn get_user_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(0, User::DISCRIMINATOR.to_vec()))
}

pub fn get_hlm_user_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(4_355, vec![1]))
}

pub fn get_non_idle_user_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(4_350, vec![0]))
}

pub fn get_user_with_auction_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(4_354, vec![1]))
}

pub fn get_user_with_order_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(4_352, vec![1]))
}

pub fn get_user_stats_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(0, UserStats::DISCRIMINATOR.to_vec()))
}

pub fn get_user_stats_is_referred_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(188, vec![2]))
}

pub fn get_user_stats_is_referred_or_referrer_filter() -> RpcFilterType {
    RpcFilterType::Memcmp(Memcmp::new_raw_bytes(188, vec![3]))
}

pub fn get_market_filter(market_type: MarketType) -> RpcFilterType {
    match market_type {
        MarketType::Spot => {
            RpcFilterType::Memcmp(Memcmp::new_raw_bytes(0, SpotMarket::DISCRIMINATOR.to_vec()))
        }
        MarketType::Perp => {
            RpcFilterType::Memcmp(Memcmp::new_raw_bytes(0, PerpMarket::DISCRIMINATOR.to_vec()))
        }
    }
}

```

## File: crates/src/oraclemap.rs
```
use std::sync::{
    atomic::{AtomicU64, Ordering},
    Arc,
};

use ahash::HashSet;
use dashmap::{DashMap, ReadOnlyView};
use drift_pubsub_client::PubsubClient;
use futures_util::{
    stream::{FuturesOrdered, FuturesUnordered},
    StreamExt,
};
use log::warn;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    account::Account, clock::Slot, commitment_config::CommitmentConfig, pubkey::Pubkey,
};

use crate::{
    drift_idl::types::OracleSource,
    ffi::{get_oracle_price, OraclePriceData},
    grpc::AccountUpdate as GrpcAccountUpdate,
    types::{AccountUpdate, MapOf, EMPTY_ACCOUNT_CALLBACK},
    websocket_account_subscriber::WebsocketAccountSubscriber,
    MarketId, SdkError, SdkResult, UnsubHandle,
};

const LOG_TARGET: &str = "oraclemap";

#[allow(dead_code)]
#[derive(Clone, Debug)]
/// Captures shared relationship between oracles and markets/source types
enum OracleShareMode {
    /// Oracle is used by 1 or more markets
    Normal { source: OracleSource },
    /// Oracle is shared by markets with mixed sources
    Mixed { sources: Vec<OracleSource> },
}

#[derive(Clone, Default, Debug)]
pub struct Oracle {
    pub pubkey: Pubkey,
    pub data: OraclePriceData,
    pub source: OracleSource,
    pub slot: u64,
    pub raw: Vec<u8>,
}

/// Dynamic map of Drift market oracle data
///
/// Caller can subscribe to some subset of markets for Ws backed updates
/// Alternatively, the caller may drive the map by calling `sync` periodically
pub struct OracleMap {
    /// Oracle data keyed by pubkey and source
    pub oraclemap: Arc<DashMap<(Pubkey, u8), Oracle, ahash::RandomState>>,
    /// Oracle subscription handles by pubkey
    subscriptions: DashMap<Pubkey, UnsubHandle, ahash::RandomState>,
    /// Oracle (pubkey, source) by MarketId (immutable)
    pub oracle_by_market: ReadOnlyView<MarketId, (Pubkey, OracleSource), ahash::RandomState>,
    /// map from oracle to consuming markets/source types
    shared_oracles: ReadOnlyView<Pubkey, OracleShareMode, ahash::RandomState>,
    latest_slot: Arc<AtomicU64>,
    commitment: CommitmentConfig,
    pubsub: Arc<PubsubClient>,
}

impl OracleMap {
    pub const SUBSCRIPTION_ID: &'static str = "oraclemap";

    /// Create a new `OracleMap`
    ///
    /// * `rpc_client` - Shared RPC client instance
    /// * `pubsub_client` - Shared Pubsub client instance
    /// * `all_oracles` - Exhaustive list of all Drift oracle pubkeys and source by market
    ///
    pub fn new(
        pubsub_client: Arc<PubsubClient>,
        all_oracles: &[(MarketId, Pubkey, OracleSource)],
        commitment: CommitmentConfig,
    ) -> Self {
        log::debug!(target: LOG_TARGET, "all oracles: {:?}", all_oracles);
        let oracle_by_market: DashMap<MarketId, (Pubkey, OracleSource), ahash::RandomState> =
            all_oracles
                .iter()
                .copied()
                .map(|(market, pubkey, source)| (market, (pubkey, source)))
                .collect();
        let oracle_by_market = oracle_by_market.into_read_only();

        let shared_oracles = DashMap::<Pubkey, OracleShareMode, ahash::RandomState>::default();
        for (_market, (pubkey, source)) in oracle_by_market.iter() {
            shared_oracles
                .entry(*pubkey)
                .and_modify(|m| match m {
                    OracleShareMode::Normal {
                        source: existing_source,
                    } => {
                        if existing_source != source {
                            *m = OracleShareMode::Mixed {
                                sources: vec![*existing_source, *source],
                            }
                        }
                    }
                    OracleShareMode::Mixed { sources } => {
                        if !sources.contains(source) {
                            sources.push(*source);
                        }
                    }
                })
                .or_insert(OracleShareMode::Normal { source: *source });
        }

        Self {
            oraclemap: Arc::default(),
            shared_oracles: shared_oracles.into_read_only(),
            oracle_by_market,
            subscriptions: Default::default(),
            latest_slot: Arc::new(AtomicU64::new(0)),
            commitment,
            pubsub: pubsub_client,
        }
    }

    /// Subscribe to oracle updates for given `markets` without callback
    pub async fn subscribe(&self, markets: &[MarketId]) -> SdkResult<()> {
        self.subscribe_inner(markets, EMPTY_ACCOUNT_CALLBACK).await
    }

    pub async fn subscribe_with_callback<F>(
        &self,
        markets: &[MarketId],
        on_account: F,
    ) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        self.subscribe_inner(markets, on_account).await
    }

    /// Subscribe to oracle updates for given `markets`
    ///
    /// Can be called multiple times to subscribe to additional markets
    ///
    /// Panics
    ///
    /// If the `market` oracle pubkey is not loaded
    async fn subscribe_inner<F>(&self, markets: &[MarketId], on_account: F) -> SdkResult<()>
    where
        F: Fn(&crate::AccountUpdate) + Send + Sync + 'static + Clone,
    {
        let markets = HashSet::from_iter(markets);
        log::debug!(target: LOG_TARGET, "subscribe market oracles: {markets:?}");

        let mut pending_subscriptions =
            Vec::<WebsocketAccountSubscriber>::with_capacity(markets.len());

        for market in markets {
            let (oracle_pubkey, _oracle_source) =
                self.oracle_by_market.get(market).expect("oracle exists");

            // markets can share oracle pubkeys, only want one sub per oracle pubkey
            if self.subscriptions.contains_key(oracle_pubkey)
                || pending_subscriptions
                    .iter()
                    .any(|sub| &sub.pubkey == oracle_pubkey)
            {
                log::debug!(
                    target: LOG_TARGET,
                    "subscription exists: {market:?}/{oracle_pubkey:?}"
                );
                continue;
            }

            let oracle_subscriber = WebsocketAccountSubscriber::new(
                Arc::clone(&self.pubsub),
                *oracle_pubkey,
                self.commitment,
            );

            pending_subscriptions.push(oracle_subscriber);
        }

        let futs_iter = pending_subscriptions.into_iter().map(|sub_fut| {
            let oraclemap = Arc::clone(&self.oraclemap);
            let oracle_shared_mode = self
                .shared_oracles
                .get(&sub_fut.pubkey)
                .expect("oracle exists")
                .clone();
            let oracle_shared_mode_ref = oracle_shared_mode.clone();
            let on_account = on_account.clone();
            async move {
                let unsub = sub_fut
                    .subscribe(Self::SUBSCRIPTION_ID, true, move |update| {
                        match &oracle_shared_mode_ref {
                            OracleShareMode::Normal { source } => {
                                update_handler(update, *source, &oraclemap)
                            }
                            OracleShareMode::Mixed { sources } => {
                                for source in sources {
                                    update_handler(update, *source, &oraclemap);
                                }
                            }
                        }
                        on_account(update);
                    })
                    .await;
                ((sub_fut.pubkey, oracle_shared_mode), unsub)
            }
        });

        let mut subscription_futs = FuturesUnordered::from_iter(futs_iter);

        while let Some(((pubkey, oracle_share_mode), unsub)) = subscription_futs.next().await {
            log::debug!(
                target: LOG_TARGET,
                "subscribed market oracle: {oracle_share_mode:?}"
            );
            self.subscriptions.insert(pubkey, unsub?);
        }

        log::debug!(target: LOG_TARGET, "subscribed");
        Ok(())
    }

    /// Unsubscribe from oracle updates for the given `markets`
    pub fn unsubscribe(&self, markets: &[MarketId]) -> SdkResult<()> {
        for market in markets {
            if let Some((oracle_pubkey, oracle_source)) = self.oracle_by_market.get(market) {
                if let Some((_, unsub)) = self.subscriptions.remove(oracle_pubkey) {
                    let _ = unsub.send(());
                    self.oraclemap
                        .remove(&(*oracle_pubkey, *oracle_source as u8));
                }
            }
        }
        log::debug!(target: LOG_TARGET, "unsubscribed markets: {markets:?}");

        Ok(())
    }

    /// Unsubscribe from all oracle updates
    pub fn unsubscribe_all(&self) -> SdkResult<()> {
        let all_markets: Vec<MarketId> = self.oracle_by_market.keys().copied().collect();
        self.unsubscribe(&all_markets)
    }

    /// Fetches account data for each market oracle set by `markets`
    ///
    /// This may be invoked manually to resync oracle data for some set of markets
    pub async fn sync(&self, markets: &[MarketId], rpc: &RpcClient) -> SdkResult<()> {
        let markets = HashSet::<MarketId>::from_iter(markets.iter().copied());
        log::debug!(target: LOG_TARGET, "sync oracles for: {markets:?}");

        let mut oracle_sources = Vec::with_capacity(markets.len());
        let mut oracle_pubkeys = Vec::with_capacity(markets.len());

        for (_, (pubkey, source)) in self
            .oracle_by_market
            .iter()
            .filter(|(m, _)| markets.contains(m))
        {
            oracle_pubkeys.push(*pubkey);
            oracle_sources.push(*source);
        }

        let (synced_oracles, latest_slot) =
            match get_multi_account_data_with_fallback(rpc, &oracle_pubkeys).await {
                Ok(result) => result,
                Err(err) => {
                    warn!(target: LOG_TARGET, "failed to sync oracle accounts");
                    return Err(err);
                }
            };

        if synced_oracles.len() != oracle_pubkeys.len() {
            warn!(target: LOG_TARGET, "failed to sync all oracle accounts");
            return Err(SdkError::InvalidOracle);
        }

        for ((oracle_pubkey, oracle_account), oracle_source) in
            synced_oracles.iter().zip(oracle_sources)
        {
            self.oraclemap
                .entry((*oracle_pubkey, oracle_source as u8))
                .and_modify(|o| {
                    log::debug!(
                        target: LOG_TARGET,
                        "sync oracle update: {:?}/{}",
                        oracle_source,
                        oracle_pubkey
                    );
                    let price_data = get_oracle_price(
                        oracle_source,
                        &mut (*oracle_pubkey, oracle_account.clone()),
                        latest_slot,
                    )
                    .expect("valid oracle data");

                    o.raw.clone_from(&oracle_account.data);
                    o.data = price_data;
                    o.slot = latest_slot;
                })
                .or_insert({
                    log::debug!(
                        target: LOG_TARGET,
                        "sync oracle new: {:?}/{}",
                        oracle_source,
                        oracle_pubkey
                    );
                    let price_data = get_oracle_price(
                        oracle_source,
                        &mut (*oracle_pubkey, oracle_account.clone()),
                        latest_slot,
                    )
                    .expect("valid oracle data");

                    Oracle {
                        pubkey: *oracle_pubkey,
                        data: price_data,
                        slot: latest_slot,
                        source: oracle_source,
                        raw: oracle_account.data.clone(),
                    }
                });
        }

        self.latest_slot.store(latest_slot, Ordering::Relaxed);
        log::debug!(
            target: LOG_TARGET,
            "synced {} oracles",
            synced_oracles.len()
        );

        Ok(())
    }

    /// Number of oracles known to the `OracleMap`
    #[allow(dead_code)]
    pub fn len(&self) -> usize {
        self.oraclemap.len()
    }

    /// Returns true if the oraclemap has a Ws subscription for `market`
    pub fn is_subscribed(&self, market: &MarketId) -> bool {
        if let Some((oracle_pubkey, _oracle_source)) = self.oracle_by_market.get(market) {
            self.subscriptions.contains_key(oracle_pubkey)
        } else {
            false
        }
    }

    /// Get the address of a perp market oracle
    pub fn current_perp_oracle(&self, market_index: u16) -> Option<Pubkey> {
        self.get_by_market(&MarketId::perp(market_index))
            .map(|x| x.pubkey)
    }

    /// Get the address of a spot market oracle
    pub fn current_spot_oracle(&self, market_index: u16) -> Option<Pubkey> {
        self.get_by_market(&MarketId::spot(market_index))
            .map(|x| x.pubkey)
    }

    /// Return Oracle data by market, if known
    pub fn get_by_market(&self, market: &MarketId) -> Option<Oracle> {
        if let Some((oracle_pubkey, oracle_source)) = self.oracle_by_market.get(market) {
            self.oraclemap
                .get(&(*oracle_pubkey, *oracle_source as u8))
                .map(|o| o.clone())
        } else {
            None
        }
    }

    #[allow(dead_code)]
    pub fn values(&self) -> Vec<Oracle> {
        self.oraclemap.iter().map(|x| x.clone()).collect()
    }

    pub fn get_latest_slot(&self) -> u64 {
        self.latest_slot.load(Ordering::Relaxed)
    }
    /// Return a reference to the internal map data structure
    pub fn map(&self) -> Arc<MapOf<(Pubkey, u8), Oracle>> {
        Arc::clone(&self.oraclemap)
    }

    /// Returns a hook for driving the map with new `Account` updates
    pub(crate) fn on_account_fn(&self) -> impl Fn(&GrpcAccountUpdate) {
        let oraclemap = self.map();
        let oracle_lookup = self.shared_oracles.clone();

        move |update: &GrpcAccountUpdate| match oracle_lookup.get(&update.pubkey).unwrap() {
            OracleShareMode::Normal { source } => {
                update_handler_grpc(update, *source, &oraclemap);
            }
            OracleShareMode::Mixed { sources } => {
                for source in sources {
                    update_handler_grpc(update, *source, &oraclemap);
                }
            }
        }
    }
}

/// Handler fn for new oracle account data
#[inline]
fn update_handler_grpc(
    update: &GrpcAccountUpdate,
    oracle_source: OracleSource,
    oracle_map: &DashMap<(Pubkey, u8), Oracle, ahash::RandomState>,
) {
    let lamports = update.lamports;
    let slot = update.slot;
    match get_oracle_price(
        oracle_source,
        &mut (
            update.pubkey,
            Account {
                owner: update.owner,
                data: update.data.to_vec(),
                lamports,
                executable: false,
                rent_epoch: u64::MAX,
            },
        ),
        slot,
    ) {
        Ok(price_data) => {
            oracle_map
                .entry((update.pubkey, oracle_source as u8))
                .and_modify(|o| {
                    o.data = price_data;
                    o.slot = slot;
                    o.raw.resize(update.data.len(), 0);
                    o.raw.clone_from_slice(update.data);
                })
                .or_insert(Oracle {
                    pubkey: update.pubkey,
                    source: oracle_source,
                    data: price_data,
                    slot,
                    raw: update.data.to_vec(),
                });
        }
        Err(err) => {
            log::error!("Failed to get oracle price: {err:?}, {:?}", update.pubkey)
        }
    }
}

/// Handler fn for new oracle account data
fn update_handler(
    update: &AccountUpdate,
    oracle_source: OracleSource,
    oracle_map: &DashMap<(Pubkey, u8), Oracle, ahash::RandomState>,
) {
    let oracle_pubkey = update.pubkey;
    let lamports = update.lamports;
    match get_oracle_price(
        oracle_source,
        &mut (
            oracle_pubkey,
            Account {
                owner: update.owner,
                data: update.data.clone(),
                lamports,
                ..Default::default()
            },
        ),
        update.slot,
    ) {
        Ok(price_data) => {
            oracle_map
                .entry((oracle_pubkey, oracle_source as u8))
                .and_modify(|o| {
                    o.data = price_data;
                    o.slot = update.slot;
                    o.raw = update.data.to_vec();
                })
                .or_insert(Oracle {
                    pubkey: oracle_pubkey,
                    source: oracle_source,
                    data: price_data,
                    slot: update.slot,
                    raw: update.data.to_vec(),
                });
        }
        Err(err) => {
            log::error!("Failed to get oracle price: {err:?}, {oracle_pubkey:?}")
        }
    }
}

/// Fetch all accounts with multiple fallbacks
///
/// Tries progressively less intensive RPC methods for wider compatibility with RPC providers:
///    getMultipleAccounts, lastly multiple getAccountInfo
///
/// Returns deserialized accounts and retrieved slot
async fn get_multi_account_data_with_fallback(
    rpc: &RpcClient,
    pubkeys: &[Pubkey],
) -> SdkResult<(Vec<(Pubkey, Account)>, Slot)> {
    let mut account_data = Vec::with_capacity(pubkeys.len());

    // try 'getMultipleAccounts'
    let mut gma_requests = FuturesOrdered::new();
    for keys in pubkeys.chunks(64) {
        gma_requests.push_back(async move {
            let response = rpc
                .get_multiple_accounts_with_commitment(keys, rpc.commitment())
                .await;
            (response, keys)
        });
    }

    let mut gma_slot = 0;
    while let Some((gma_response, keys)) = gma_requests.next().await {
        match gma_response {
            Ok(response) => {
                gma_slot = response.context.slot;
                for (oracle, pubkey) in response.value.into_iter().zip(keys) {
                    match oracle {
                        Some(oracle) => {
                            account_data.push((*pubkey, oracle));
                        }
                        None => {
                            log::warn!(
                                target: LOG_TARGET,
                                "failed to fetch oracle account (missing)"
                            );
                            break;
                        }
                    }
                }
            }
            Err(err) => {
                log::warn!(
                    target: LOG_TARGET,
                    "failed to fetch oracle accounts: {err:?}"
                );
                return Err(err)?;
            }
        }
    }

    if account_data.len() == pubkeys.len() {
        return Ok((account_data, gma_slot));
    }
    log::debug!(
        target: LOG_TARGET,
        "syncing with getMultipleAccounts failed"
    );

    // try multiple 'getAccount's
    let mut account_requests = FuturesOrdered::from_iter(pubkeys.iter().map(|p| async move {
        (
            p,
            rpc.get_account_with_commitment(p, rpc.commitment()).await,
        )
    }));

    let mut latest_slot = 0;
    while let Some((pubkey, response)) = account_requests.next().await {
        match response {
            Ok(response) => {
                let account = response.value.ok_or({
                    log::warn!("failed to fetch oracle account");
                    SdkError::InvalidOracle
                })?;
                latest_slot = latest_slot.max(response.context.slot);
                account_data.push((*pubkey, account));
            }
            Err(err) => {
                log::warn!("failed to fetch oracle account: {err:?}");
                return Err(err)?;
            }
        }
    }

    Ok((account_data, latest_slot))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::{
        get_ws_url,
        test_envs::{devnet_endpoint, mainnet_endpoint},
    };

    const SOL_PERP_ORACLE: Pubkey =
        solana_sdk::pubkey!("BAtFj4kQttZRVep3UZS2aZRDixkGYgWsbqTBVDbnSsPF");

    #[tokio::test]
    async fn oraclemap_sync() {
        let all_oracles = vec![
            (
                MarketId::spot(0),
                solana_sdk::pubkey!("5SSkXsEKQepHHAewytPVwdej4epN1nxgLVM84L4KXgy7"),
                OracleSource::PythStableCoin,
            ),
            (MarketId::perp(0), SOL_PERP_ORACLE, OracleSource::PythPull),
            (
                MarketId::perp(1),
                solana_sdk::pubkey!("486kr3pmFPfTsS4aZgcsQ7kS4i9rjMsYYZup6HQNSTT4"),
                OracleSource::PythPull,
            ),
            (MarketId::spot(1), SOL_PERP_ORACLE, OracleSource::PythPull),
        ];
        let rpc = Arc::new(RpcClient::new(devnet_endpoint().into()));
        let pubsub = Arc::new(
            PubsubClient::new(&get_ws_url(&devnet_endpoint()).unwrap())
                .await
                .expect("ws connects"),
        );
        let map = OracleMap::new(pubsub, &all_oracles, rpc.commitment());

        // - dups ignored
        // - markets with same oracle pubkey, make at most 1 sub
        let markets = [
            MarketId::perp(0),
            MarketId::spot(1),
            MarketId::perp(1),
            MarketId::spot(1),
        ];
        map.sync(&markets, &rpc).await.expect("subd");
    }

    #[tokio::test]
    async fn oraclemap_subscribe_mixed_spot_perp_source() {
        // bonk oracle uses a precision trick via 'oracle source'
        // with same oracle pubkey
        let all_oracles = vec![
            (
                MarketId::perp(0),
                solana_sdk::pubkey!("3m6i4RFWEDw2Ft4tFHPJtYgmpPe21k56M3FHeWYrgGBz"),
                OracleSource::PythLazer,
            ),
            (
                MarketId::perp(4),
                solana_sdk::pubkey!("BERaNi6cpEresbq6HC1EQGaB1H1UjvEo4NGnmYSSJof4"),
                OracleSource::PythLazer1M,
            ),
            (
                MarketId::spot(32),
                solana_sdk::pubkey!("BERaNi6cpEresbq6HC1EQGaB1H1UjvEo4NGnmYSSJof4"),
                OracleSource::PythLazer,
            ),
        ];
        let pubsub = Arc::new(
            PubsubClient::new(&get_ws_url(&mainnet_endpoint()).unwrap())
                .await
                .expect("ws connects"),
        );
        let map = OracleMap::new(pubsub, &all_oracles, CommitmentConfig::confirmed());

        let markets = [MarketId::perp(0), MarketId::spot(32), MarketId::perp(4)];
        map.subscribe(&markets).await.expect("subd");
        assert_eq!(map.len(), 3);
        assert!(map.is_subscribed(&MarketId::spot(32)));
        assert!(map.is_subscribed(&MarketId::perp(4)));
    }

    #[tokio::test]
    async fn oraclemap_subscribes() {
        let _ = env_logger::try_init();
        let all_oracles = vec![
            (
                MarketId::spot(0),
                solana_sdk::pubkey!("5SSkXsEKQepHHAewytPVwdej4epN1nxgLVM84L4KXgy7"),
                OracleSource::PythStableCoin,
            ),
            (MarketId::perp(0), SOL_PERP_ORACLE, OracleSource::PythPull),
            (
                MarketId::perp(1),
                solana_sdk::pubkey!("486kr3pmFPfTsS4aZgcsQ7kS4i9rjMsYYZup6HQNSTT4"),
                OracleSource::PythPull,
            ),
            (MarketId::spot(1), SOL_PERP_ORACLE, OracleSource::PythPull),
        ];
        let pubsub = Arc::new(
            PubsubClient::new(&get_ws_url(&devnet_endpoint()).unwrap())
                .await
                .expect("ws connects"),
        );
        let map = OracleMap::new(pubsub, &all_oracles, CommitmentConfig::confirmed());

        // - dups ignored
        // - markets with same oracle pubkey, make at most 1 sub
        let markets = [
            MarketId::perp(0),
            MarketId::spot(1),
            MarketId::perp(1),
            MarketId::spot(1),
        ];
        map.subscribe(&markets).await.expect("subd");
        assert_eq!(map.len(), 2);
        let markets = [MarketId::perp(0), MarketId::spot(1)];
        map.subscribe(&markets).await.expect("subd");
        assert_eq!(map.len(), 2);

        assert!(map.is_subscribed(&MarketId::perp(0)));
        assert!(map.is_subscribed(&MarketId::perp(1)));

        // check unsub ok
        assert!(map.unsubscribe(&[MarketId::perp(0)]).is_ok());
        assert!(!map.is_subscribed(&MarketId::perp(0)));
    }

    #[tokio::test]
    async fn oraclemap_unsubscribe_all() {
        let all_oracles = vec![
            (
                MarketId::spot(0),
                solana_sdk::pubkey!("5SSkXsEKQepHHAewytPVwdej4epN1nxgLVM84L4KXgy7"),
                OracleSource::PythStableCoin,
            ),
            (
                MarketId::perp(1),
                solana_sdk::pubkey!("486kr3pmFPfTsS4aZgcsQ7kS4i9rjMsYYZup6HQNSTT4"),
                OracleSource::PythPull,
            ),
        ];
        let map = OracleMap::new(
            Arc::new(
                PubsubClient::new(&get_ws_url(&devnet_endpoint()).unwrap())
                    .await
                    .expect("ws connects"),
            ),
            &all_oracles,
            CommitmentConfig::confirmed(),
        );
        map.subscribe(&[MarketId::spot(0), MarketId::perp(1)])
            .await
            .expect("subd");
        assert!(map.unsubscribe_all().is_ok());
        assert_eq!(map.len(), 0);
    }

    #[cfg(feature = "rpc_tests")]
    #[tokio::test]
    async fn test_oracle_map() {
        use crate::{
            drift_idl::accounts::{PerpMarket, SpotMarket},
            marketmap::MarketMap,
        };
        let commitment = CommitmentConfig::processed();

        let spot_market_map =
            MarketMap::<SpotMarket>::new(commitment.clone(), mainnet_endpoint(), true);
        let perp_market_map =
            MarketMap::<PerpMarket>::new(commitment.clone(), mainnet_endpoint(), true);

        let _ = spot_market_map.sync().await;
        let _ = perp_market_map.sync().await;

        let perp_oracles = perp_market_map.oracles();
        let spot_oracles = spot_market_map.oracles();

        let mut oracles = vec![];
        oracles.extend(perp_oracles.clone());
        oracles.extend(spot_oracles.clone());

        let mut oracle_infos = vec![];
        for oracle_info in oracles {
            if !oracle_infos.contains(&oracle_info) {
                oracle_infos.push(oracle_info)
            }
        }

        let oracle_infos_len = oracle_infos.len();
        dbg!(oracle_infos_len);

        let oracle_map = OracleMap::new(
            commitment,
            &mainnet_endpoint(),
            true,
            perp_oracles,
            spot_oracles,
        );

        let _ = oracle_map.subscribe().await;

        dbg!(oracle_map.size());

        dbg!("sleeping");
        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;
        dbg!("done sleeping");

        let rlb_perp_market_oracle_pubkey = perp_market_map
            .get(&17)
            .expect("rlb perp market")
            .data
            .amm
            .oracle;
        let rlb_oracle = oracle_map
            .get(&rlb_perp_market_oracle_pubkey)
            .expect("rlb oracle");
        dbg!("rlb oracle info:");
        dbg!(rlb_oracle.data.price);
        dbg!(rlb_oracle.slot);

        dbg!("perp market oracles");
        let mut last_sol_price = 0;
        let mut last_sol_slot = 0;
        let mut last_btc_price = 0;
        let mut last_btc_slot = 0;
        for _ in 0..10 {
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            dbg!();
            let sol_perp_market_oracle_pubkey = perp_market_map
                .get(&0)
                .expect("sol perp market")
                .data
                .amm
                .oracle;
            let sol_oracle = oracle_map
                .get(&sol_perp_market_oracle_pubkey)
                .expect("sol oracle");
            dbg!("sol oracle info:");
            dbg!(sol_oracle.data.price);
            dbg!(sol_oracle.slot);
            dbg!(
                "sol price change: {}",
                sol_oracle.data.price - last_sol_price
            );
            dbg!("sol slot change: {}", sol_oracle.slot - last_sol_slot);
            last_sol_price = sol_oracle.data.price;
            last_sol_slot = sol_oracle.slot;

            dbg!();

            let btc_perp_market_oracle_pubkey = perp_market_map
                .get(&1)
                .expect("btc perp market")
                .data
                .amm
                .oracle;
            let btc_oracle = oracle_map
                .get(&btc_perp_market_oracle_pubkey)
                .expect("btc oracle");
            dbg!("btc oracle info:");
            dbg!(btc_oracle.data.price);
            dbg!(btc_oracle.slot);
            dbg!(
                "btc price change: {}",
                btc_oracle.data.price - last_btc_price
            );
            dbg!("btc slot change: {}", btc_oracle.slot - last_btc_slot);
            last_btc_price = btc_oracle.data.price;
            last_btc_slot = btc_oracle.slot;
        }

        dbg!();

        dbg!("spot market oracles");
        let mut last_rndr_price = 0;
        let mut last_rndr_slot = 0;
        let mut last_weth_price = 0;
        let mut last_weth_slot = 0;
        for _ in 0..10 {
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            dbg!();
            let rndr_spot_market_oracle_pubkey = spot_market_map
                .get(&11)
                .expect("sol perp market")
                .data
                .oracle;
            let rndr_oracle = oracle_map
                .get(&rndr_spot_market_oracle_pubkey)
                .expect("sol oracle");
            dbg!("rndr oracle info:");
            dbg!(rndr_oracle.data.price);
            dbg!(rndr_oracle.slot);
            dbg!(
                "rndr price change: {}",
                rndr_oracle.data.price - last_rndr_price
            );
            dbg!("rndr slot change: {}", rndr_oracle.slot - last_rndr_slot);
            last_rndr_price = rndr_oracle.data.price;
            last_rndr_slot = rndr_oracle.slot;

            dbg!();

            let weth_spot_market_oracle_pubkey = spot_market_map
                .get(&4)
                .expect("sol perp market")
                .data
                .oracle;
            let weth_oracle = oracle_map
                .get(&weth_spot_market_oracle_pubkey)
                .expect("sol oracle");
            dbg!("weth oracle info:");
            dbg!(weth_oracle.data.price);
            dbg!(weth_oracle.slot);
            dbg!(
                "weth price change: {}",
                weth_oracle.data.price - last_weth_price
            );
            dbg!("weth slot change: {}", weth_oracle.slot - last_weth_slot);
            last_weth_price = weth_oracle.data.price;
            last_weth_slot = weth_oracle.slot;
        }

        let _ = oracle_map.unsubscribe().await;
    }
}

```

## File: crates/src/polled_account_subscriber.rs
```
use std::{sync::Arc, time::Duration};

use log::error;
use solana_account_decoder_client_types::UiAccountEncoding;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_rpc_client_api::config::RpcAccountInfoConfig;
use solana_sdk::pubkey::Pubkey;
use tokio::sync::oneshot;

use crate::{AccountUpdate, UnsubHandle};

/// Subscribes to account updates at regular polled intervals
pub struct PolledAccountSubscriber {
    pubkey: Pubkey,
    interval: Duration,
    rpc_client: Arc<RpcClient>,
}

impl PolledAccountSubscriber {
    /// Create a new polling account subscriber
    ///
    /// `poll_interval` configurable polling interval
    /// `pubkey` the account to poll
    /// `rpc_client` Provides account fetching implementation
    pub fn new(
        pubkey: Pubkey,
        poll_interval: Duration,
        rpc_client: Arc<RpcClient>,
    ) -> PolledAccountSubscriber {
        Self {
            pubkey,
            interval: poll_interval,
            rpc_client: Arc::clone(&rpc_client),
        }
    }

    /// Start the account subscriber
    ///
    /// `on_update` callback to receive new account values
    ///
    /// Returns channel for unsubscribing
    pub fn subscribe<F>(&self, on_update: F) -> UnsubHandle
    where
        F: 'static + Send + Fn(&AccountUpdate),
    {
        let (unsub_tx, mut unsub_rx) = oneshot::channel();

        tokio::spawn({
            let mut interval = tokio::time::interval(self.interval);
            let pubkey = self.pubkey;
            let rpc_client = Arc::clone(&self.rpc_client);

            let config = RpcAccountInfoConfig {
                encoding: Some(UiAccountEncoding::Base64Zstd),
                commitment: Some(rpc_client.commitment()),
                ..Default::default()
            };
            async move {
                loop {
                    tokio::select! {
                        biased;
                        _ = interval.tick() => {
                            match rpc_client.get_account_with_config(&pubkey, config.clone()).await {
                                Ok(response) => {
                                    if let Some(new_account) = response.value {
                                        on_update(
                                            &AccountUpdate {
                                                owner: new_account.owner,
                                                lamports: new_account.lamports,
                                                pubkey,
                                                data: new_account.data.clone(),
                                                slot: response.context.slot,
                                            }
                                        );
                                    }
                                }
                                Err(err) => error!("{err:?}"),
                            }
                        }
                        _ = &mut unsub_rx => {
                            break;
                        }
                    }
                }
            }
        });

        unsub_tx
    }
}

#[cfg(test)]
mod tests {
    use anchor_lang::AccountSerialize;
    use serde_json::json;
    use solana_account_decoder::encode_ui_account;
    use solana_account_decoder_client_types::UiAccountEncoding;
    use solana_rpc_client::rpc_client::Mocks;
    use solana_rpc_client_api::request::RpcRequest;
    use solana_sdk::account::Account;

    use super::*;
    use crate::{accounts::User, SpotPosition};

    #[tokio::test]
    async fn polled_account_subscriber_updates() {
        // mock account response
        let owner = Pubkey::new_unique();
        let sub_account = Pubkey::new_unique();

        let mut mock_user = User {
            authority: owner,
            ..Default::default()
        };
        mock_user.spot_positions[1] = SpotPosition {
            scaled_balance: 12_345,
            market_index: 1,
            ..Default::default()
        };

        let mut buf = Vec::<u8>::default();
        mock_user.try_serialize(&mut buf).expect("serializes");

        let mock_account = Account {
            data: buf,
            ..Default::default()
        };

        let mut response_mocks = Mocks::default();
        let account_response = json!({
            "context": {
                "slot": 12_345,
            },
            "value": encode_ui_account(&sub_account, &mock_account, UiAccountEncoding::Base64Zstd, None, None),
        });
        response_mocks.insert(RpcRequest::GetAccountInfo, account_response);

        let mock_rpc = RpcClient::new_mock_with_mocks(
            "https://api.mainnet-beta.solana.com".into(),
            response_mocks,
        );

        // test
        let subscriber =
            PolledAccountSubscriber::new(sub_account, Duration::from_secs(1), Arc::new(mock_rpc));
        let _unsub = subscriber.subscribe(move |user| {
            assert_eq!(user.data, mock_account.data,);
        });
        let _ = tokio::time::sleep(Duration::from_millis(500)).await;
    }
}

```

## File: crates/src/priority_fee_subscriber.rs
```
use std::{
    sync::{Arc, Mutex, RwLock},
    time::Duration,
};

use log::warn;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{clock::Slot, pubkey::Pubkey};
use tokio::sync::oneshot;

pub const DEFAULT_REFRESH_FREQUENCY: Duration = Duration::from_millis(5 * 400);
pub const DEFAULT_SLOT_WINDOW: Slot = 30;

/// Subscribes to network priority fees given some accounts.
///
/// This subscriber periodically fetches recent prioritization fees for a set of Solana accounts in a background task.
/// If fetching fails, it will retry up to 3 times before stopping the background task and marking itself as unsubscribed.
/// After unsubscribing (either manually or due to repeated failures), queries for the priority fee can be checked safely using `priority_fee_safe()`.
///
/// # Example
/// ```rust
/// # use drift_rs::PriorityFeeSubscriber;
/// # use solana_sdk::pubkey::Pubkey;
/// let endpoint = "https://api.mainnet-beta.solana.com".to_string();
/// let accounts = vec![Pubkey::new_unique()];
/// let subscriber = PriorityFeeSubscriber::new(endpoint, &accounts);
/// let subscriber = subscriber.subscribe();
/// // ... later, after the background task has populated fees ...
/// if subscriber.is_subscribed() {
///     let fee = subscriber.priority_fee(); // may panic if not yet populated
///     // use fee
/// } else {
///     // handle unsubscribed or stopped state
/// }
/// // Or, use the safe method:
/// if let Some(fee) = subscriber.priority_fee_safe() {
///     // use fee
/// } else {
///     // handle unsubscribed or stopped state
/// }
/// ```
pub struct PriorityFeeSubscriber {
    config: PriorityFeeSubscriberConfig,
    /// Accounts to lock for the priority fee calculation
    writeable_accounts: Vec<Pubkey>,
    rpc_client: RpcClient,
    latest_fees: RwLock<Vec<u64>>,
    /// unsubscriber handler
    unsub: Mutex<Option<oneshot::Sender<()>>>,
}

/// Options for `PriorityFeeSubscriber`
pub struct PriorityFeeSubscriberConfig {
    /// how frequently to re-poll the priority fee
    pub refresh_frequency: Option<Duration>,
    /// # of historic slots to consider in the fee calculation
    /// max: 150
    pub window: Option<Slot>,
}

impl PriorityFeeSubscriber {
    /// Create new `PriorityFeeSubscriber` assuming a tx will lock `writeable_accounts`
    pub fn new(endpoint: String, writeable_accounts: &[Pubkey]) -> Self {
        Self::with_config(
            RpcClient::new(endpoint),
            writeable_accounts,
            PriorityFeeSubscriberConfig {
                refresh_frequency: Some(DEFAULT_REFRESH_FREQUENCY),
                window: Some(DEFAULT_SLOT_WINDOW),
            },
        )
    }

    /// Create new `PriorityFeeSubscriber` assuming a tx will lock `writeable_accounts`
    pub fn with_config(
        rpc_client: RpcClient,
        writeable_accounts: &[Pubkey],
        config: PriorityFeeSubscriberConfig,
    ) -> Self {
        Self {
            config,
            writeable_accounts: writeable_accounts.to_vec(),
            rpc_client,
            latest_fees: RwLock::new(Default::default()),
            unsub: Mutex::default(),
        }
    }

    /// Start the priority fee subscriber task
    ///
    /// Returns a handle to the subscriber for querying results
    pub fn subscribe(self) -> Arc<PriorityFeeSubscriber> {
        let (unsub_tx, mut unsub_rx) = oneshot::channel();
        {
            let mut guard = self.unsub.try_lock().expect("uncontested");
            guard.replace(unsub_tx);
        }

        let arc = Arc::new(self);

        tokio::spawn({
            let this = Arc::clone(&arc);
            async move {
                let mut refresh = tokio::time::interval(
                    this.config
                        .refresh_frequency
                        .unwrap_or(DEFAULT_REFRESH_FREQUENCY),
                );
                let window = this
                    .config
                    .window
                    .unwrap_or(DEFAULT_SLOT_WINDOW)
                    .clamp(5, 150) as usize; // 150 max slots from node cache

                let max_attempts = 3;
                let mut attempts = 0;
                loop {
                    let _ = refresh.tick().await;
                    let response = this
                        .rpc_client
                        .get_recent_prioritization_fees(this.writeable_accounts.as_slice())
                        .await;

                    match response {
                        Ok(response) => {
                            attempts = 0;
                            let mut latest_fees: Vec<u64> = response
                                .iter()
                                .take(window)
                                .map(|x| x.prioritization_fee)
                                .collect();
                            latest_fees.sort_unstable();
                            let mut current_fees = this.latest_fees.write().expect("acquired");
                            *current_fees = latest_fees;
                        }
                        Err(err) => {
                            warn!("failed to fetch priority fee: {err:?}");
                            attempts += 1;
                            if attempts > max_attempts {
                                log::error!("unable to fetch priority fees: reached retry limit");
                                break;
                            }
                        }
                    }

                    if unsub_rx.try_recv().is_ok() {
                        warn!("unsubscribing priority fees");
                        break;
                    }
                }
            }
        });

        arc
    }

    /// Stop the associated network subscription task
    pub fn unsubscribe(&self) {
        let mut guard = self.unsub.lock().expect("acquired");
        if let Some(unsub) = guard.take() {
            if unsub.send(()).is_err() {
                log::error!("couldn't unsubscribe");
            }
        }
    }

    /// Returns true if the subscriber is still active (subscribed).
    pub fn is_subscribed(&self) -> bool {
        self.unsub.lock().expect("acquired").is_some()
    }

    /// Returns the median priority fee in micro-lamports over the look-back window, or None if unsubscribed.
    pub fn priority_fee_safe(&self) -> Option<u64> {
        if self.is_subscribed() {
            Some(self.priority_fee())
        } else {
            None
        }
    }

    /// Returns the median priority fee in micro-lamports over the look-back window.
    ///
    /// # Panics
    ///
    /// Panics if called before the subscriber has populated any fees (i.e., if no data is available yet).
    pub fn priority_fee(&self) -> u64 {
        self.priority_fee_nth(0.5)
    }

    /// Returns the n-th percentile priority fee in micro-lamports over the look-back window.
    /// `percentile` given as decimal 0.0 < n <= 1.0
    ///
    /// # Panics
    ///
    /// Panics if called before the subscriber has populated any fees (i.e., if no data is available yet).
    pub fn priority_fee_nth(&self, percentile: f32) -> u64 {
        let lock = self.latest_fees.read().expect("acquired");
        if lock.is_empty() {
            panic!("PriorityFeeSubscriber is not subscribed");
        }
        let n = lock.len();
        if n == 1 {
            return lock[0];
        }
        let rank = percentile * (n as f32 - 1.0);
        let lower = rank.floor() as usize;
        let upper = rank.ceil() as usize;
        if lower == upper {
            lock[lower]
        } else {
            let weight = rank - lower as f32;
            (lock[lower] as f32 * (1.0 - weight) + lock[upper] as f32 * weight).round() as u64
        }
    }
}

#[cfg(test)]
mod tests {
    use serde_json::json;
    use solana_rpc_client::rpc_client::Mocks;
    use solana_rpc_client_api::{request::RpcRequest, response::RpcPrioritizationFee};

    use super::*;

    #[tokio::test]
    async fn priority_fee_subscribe() {
        let _ = env_logger::try_init();
        let account_one = Pubkey::new_unique();
        let account_two = Pubkey::new_unique();

        let mut response_mocks = Mocks::default();
        let recent_fees: Vec<RpcPrioritizationFee> = [1, 3, 5, 6, 4, 7, 2, 9, 8]
            .into_iter()
            .enumerate()
            .map(|(i, f)| RpcPrioritizationFee {
                slot: i as u64,
                prioritization_fee: f,
            })
            .collect();

        response_mocks.insert(RpcRequest::GetRecentPrioritizationFees, json!(recent_fees));

        let mock_rpc = RpcClient::new_mock_with_mocks(
            "https://api.mainnet-beta.solana.com".into(),
            response_mocks,
        );
        let writeable_accounts = &[account_one, account_two];

        let pf = PriorityFeeSubscriber::with_config(
            mock_rpc,
            writeable_accounts,
            PriorityFeeSubscriberConfig {
                refresh_frequency: Some(Duration::from_secs(5)),
                window: Some(100),
            },
        );

        // test
        let pf = pf.subscribe();
        tokio::time::sleep(Duration::from_millis(100)).await; // wait for subscriber to populate

        let pf_median = pf.priority_fee();
        assert_eq!(pf_median, 5);
        let pf_99 = pf.priority_fee_nth(0.99);
        assert_eq!(pf_99, 9);
        let pf_05 = pf.priority_fee_nth(0.05);
        assert_eq!(pf_05, 1);
    }
}

```

## File: crates/src/slot_subscriber.rs
```
use std::sync::{atomic::AtomicU64, Arc, Mutex};

use drift_pubsub_client::PubsubClient;
use futures_util::StreamExt;
use log::{debug, error, warn};
use solana_sdk::clock::Slot;
use tokio::sync::oneshot;

use crate::types::{SdkError, SdkResult};

const LOG_TARGET: &str = "slotsub";

/// Subscribes to network slot number increases
///
/// ```example
/// let slot_subscriber = SlotSubscriber::new("http://rpc.example.com");
/// slot_subscriber.subscribe(move |slot| {
///     dbg!("new slot", slot);
/// }).expect("subd");
///
/// // get latest slot
/// let latest_slot = slot_subscriber.current_slot();
/// ```
///
pub struct SlotSubscriber {
    pubsub: Arc<PubsubClient>,
    current_slot: Arc<AtomicU64>,
    unsub: Mutex<Option<oneshot::Sender<()>>>,
}

#[derive(Clone, Debug)]
pub struct SlotUpdate {
    pub latest_slot: u64,
}

impl SlotUpdate {
    pub fn new(latest_slot: u64) -> Self {
        Self { latest_slot }
    }
}

impl SlotSubscriber {
    pub const SUBSCRIPTION_ID: &'static str = "slot";

    pub fn is_subscribed(&self) -> bool {
        let guard = self.unsub.lock().expect("acquired");
        guard.is_some()
    }

    /// Create a new `SlotSubscriber`
    ///
    /// * `pubsub` - a `PubsubClient` instance for the subscription to utilize (maybe shared)
    ///
    /// Consumer must call `.subscribe()` to start receiving updates
    pub fn new(pubsub: Arc<PubsubClient>) -> Self {
        Self {
            pubsub,
            current_slot: Arc::default(),
            unsub: Mutex::new(None),
        }
    }

    /// Returns the latest slot
    pub fn current_slot(&self) -> Slot {
        self.current_slot.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Start the slot subscription task
    ///
    /// * `on_slot` - callback invoked on new slot updates
    ///
    pub fn subscribe<F>(&mut self, on_slot: F) -> SdkResult<()>
    where
        F: 'static + Send + Fn(SlotUpdate),
    {
        if self.is_subscribed() {
            debug!(target: LOG_TARGET, "already subscribed");
            return Ok(());
        }
        self.subscribe_ws(on_slot)
    }

    fn subscribe_ws<F>(&mut self, on_slot: F) -> SdkResult<()>
    where
        F: 'static + Send + Fn(SlotUpdate),
    {
        let (unsub_tx, mut unsub_rx) = oneshot::channel::<()>();
        {
            let mut guard = self.unsub.try_lock().expect("uncontested");
            *guard = Some(unsub_tx);
        }

        let current_slot = Arc::clone(&self.current_slot);
        let pubsub = Arc::clone(&self.pubsub);

        tokio::spawn(async move {
            debug!(target: LOG_TARGET, "start slot subscriber");
            loop {
                let (mut slot_updates, unsubscriber) = match pubsub.slot_subscribe().await {
                    Ok(s) => s,
                    Err(err) => {
                        error!(target: LOG_TARGET, "slot subscribe failed: {err:?}");
                        continue;
                    }
                };

                let res = loop {
                    tokio::select! {
                        biased;
                        new_slot = slot_updates.next() => {
                            match new_slot {
                                Some(update) => {
                                    current_slot.store(update.slot, std::sync::atomic::Ordering::Relaxed);
                                    on_slot(SlotUpdate::new(update.slot));
                                }
                                None => {
                                    warn!(target: LOG_TARGET, "slot subscriber finished");
                                    break Err(());
                                }
                            }
                        }
                        _ = &mut unsub_rx => {
                            debug!(target: LOG_TARGET, "unsubscribed");
                            unsubscriber().await;
                            break Ok(());
                        }
                    }
                };

                if res.is_ok() {
                    break;
                }
            }
        });

        Ok(())
    }

    pub async fn unsubscribe(&self) -> SdkResult<()> {
        let mut guard = self.unsub.lock().expect("acquired");
        if let Some(unsub) = guard.take() {
            if unsub.send(()).is_err() {
                error!(target: LOG_TARGET, "Failed to send unsubscribe signal");
                return Err(SdkError::CouldntUnsubscribe);
            }
        }

        Ok(())
    }
}

#[cfg(feature = "rpc_tests")]
mod tests {
    use std::str::FromStr;

    use super::*;
    use crate::utils::test_envs::mainnet_endpoint;

    #[tokio::test]
    async fn test_subscribe() {
        let cluster = Cluster::from_str(&mainnet_endpoint()).unwrap();
        let url = cluster.ws_url().to_string();

        let mut slot_subscriber = SlotSubscriber::new(url);
        let _ = slot_subscriber.subscribe().await;

        slot_subscriber.event_emitter.clone().subscribe(
            SlotSubscriber::SUBSCRIPTION_ID,
            move |event| {
                if let Some(event) = event.as_any().downcast_ref::<SlotUpdate>() {
                    dbg!(event);
                }
            },
        );
        dbg!("sub'd");

        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;
        let _ = slot_subscriber.unsubscribe().await;
        dbg!("unsub'd");
    }
}

```

## File: crates/src/swift_order_subscriber.rs
```
use std::time::{SystemTime, UNIX_EPOCH};

use anchor_lang::{AnchorDeserialize, AnchorSerialize, Space};
use base64::Engine;
use futures_util::{SinkExt, StreamExt};
use serde::Deserialize;
use serde_json::{json, Value};
use solana_sdk::{clock::Slot, pubkey::Pubkey, signature::Signature};
use tokio_stream::wrappers::ReceiverStream;
use tokio_tungstenite::{connect_async, tungstenite::Message};

pub use crate::types::{
    SignedMsgOrderParamsDelegateMessage as SignedDelegateOrder,
    SignedMsgOrderParamsMessage as SignedOrder,
};
use crate::{
    constants::MarketExt,
    types::{Context, MarketId, OrderParams, SdkError, SdkResult},
    DriftClient, Wallet,
};

/// Swift message discriminator (Anchor)
///
/// sha256("global:SignedMsgOrderParamsMessage")[..8]
pub const SWIFT_MSG_PREFIX: [u8; 8] = [0xc8, 0xd5, 0xa6, 0x5e, 0x22, 0x34, 0xf5, 0x5d];
/// Swift delegate message discriminator (Anchor)
///
/// sha256("global:/// sha256("global:SignedMsgOrderParamsDelegatedMessage")[..8]
pub const SWIFT_DELEGATE_MSG_PREFIX: [u8; 8] = [0x42, 0x65, 0x66, 0x38, 0xc7, 0x25, 0x9e, 0x23];

pub const SWIFT_DEVNET_WS_URL: &str = "wss://master.swift.drift.trade";
pub const SWIFT_MAINNET_WS_URL: &str = "wss://swift.drift.trade";

const LOG_TARGET: &str = "swift";

/// Common fields of signed message types
pub struct SignedMessageInfo {
    pub taker_pubkey: Pubkey,
    pub order_params: OrderParams,
    pub uuid: [u8; 8],
    pub slot: Slot,
}

/// It can be either signed by the authority keypair or an authorized delegate
#[derive(Clone, Debug, PartialEq)]
pub enum SignedOrderType {
    /// Swift order signed by authority keypair
    Authority {
        inner: SignedOrder,
        /// hexified payload if received over Ws
        raw: Option<String>,
    },
    /// Swift order signed by a delegated keypair
    Delegated {
        inner: SignedDelegateOrder,
        /// hexified payload if received over Ws
        raw: Option<String>,
    },
}

impl SignedOrderType {
    pub fn delegated(order: SignedDelegateOrder) -> Self {
        Self::Delegated {
            inner: order,
            raw: None,
        }
    }
    pub fn authority(order: SignedOrder) -> Self {
        Self::Authority {
            inner: order,
            raw: None,
        }
    }
    /// Returns true if this is a delegated signed msg order
    pub fn is_delegated(&self) -> bool {
        matches!(self, Self::Delegated { .. })
    }
    /// Serialize as a borsh buffer
    ///
    /// DEV: Swift clients do not encode or decode the enum byte
    pub fn to_borsh(&self) -> Vec<u8> {
        // max variant size +8 (anchor discriminator len)
        let mut buf = Vec::with_capacity(SignedDelegateOrder::INIT_SPACE + 8);
        match self {
            Self::Authority { ref raw, ref inner } => {
                if let Some(raw) = raw {
                    buf.extend_from_slice(raw.as_bytes());
                } else {
                    (SWIFT_MSG_PREFIX).serialize(&mut buf).unwrap();
                    inner.serialize(&mut buf).unwrap();
                }
            }
            Self::Delegated { ref raw, ref inner } => {
                if let Some(raw) = raw {
                    buf.extend_from_slice(raw.as_bytes());
                } else {
                    (SWIFT_DELEGATE_MSG_PREFIX).serialize(&mut buf).unwrap();
                    inner.serialize(&mut buf).unwrap();
                }
            }
        }

        buf
    }

    pub fn info(&self, taker_authority: &Pubkey) -> SignedMessageInfo {
        match self {
            Self::Authority { inner, .. } => SignedMessageInfo {
                taker_pubkey: Wallet::derive_user_account(taker_authority, inner.sub_account_id),
                order_params: inner.signed_msg_order_params,
                uuid: inner.uuid,
                slot: inner.slot,
            },
            Self::Delegated { inner, .. } => SignedMessageInfo {
                taker_pubkey: inner.taker_pubkey,
                order_params: inner.signed_msg_order_params,
                uuid: inner.uuid,
                slot: inner.slot,
            },
        }
    }
}

/// Order notification from Websocket
#[derive(Clone, Deserialize)]
struct OrderNotification<'a> {
    #[allow(dead_code)]
    channel: &'a str,
    order: SignedOrderInfo,
    deposit: Option<&'a str>,
}

#[derive(Deserialize)]
struct Heartbeat {
    #[serde(deserialize_with = "deser_int_str", rename = "message")]
    ts: u64,
}

/// Swift order and metadata fresh from the Websocket
///
/// This is an off-chain authorization for a taker order.
/// It may be placed and filled by any willing counter-party, ensuring the time-price bounds
/// are respected.
#[derive(Clone, Debug, Deserialize)]
pub struct SignedOrderInfo {
    /// Swift order uuid
    uuid: String,
    /// Order creation timestamp (unix ms)
    pub ts: u64,
    /// The taker authority pubkey
    #[serde(deserialize_with = "deser_pubkey")]
    pub taker_authority: Pubkey,
    /// The authority pubkey that verifies `signature`
    /// it is either the taker authority or a sub-account delegate
    #[serde(rename = "signing_authority", deserialize_with = "deser_pubkey")]
    pub signer: Pubkey,
    /// hex-ified, borsh encoded signed order message
    /// this is the signed/verified payload for onchain use
    #[serde(rename = "order_message", deserialize_with = "deser_signed_msg_type")]
    order: SignedOrderType,
    /// Signature over the serialized `order` payload
    #[serde(rename = "order_signature", deserialize_with = "deser_signature")]
    pub signature: Signature,
    /// true if the order params are highly likely to be sanitized (improved) by the program when placed
    ///
    /// MMs wishing to fill a sanitized order should understand the potential time/price bound changes
    #[serde(default)]
    pub will_sanitize: bool,
    /// Taker signed (pre)deposit tx
    ///
    /// taker requires posting collateral before placing the swift order
    pub pre_deposit: Option<String>,
}

impl SignedOrderInfo {
    /// The order's UUID (stringified)
    pub fn order_uuid_str(&self) -> &str {
        self.uuid.as_ref()
    }
    /// The order's UUID (raw)
    pub fn order_uuid(&self) -> [u8; 8] {
        match self.order {
            SignedOrderType::Authority { inner, .. } => inner.uuid,
            SignedOrderType::Delegated { inner, .. } => inner.uuid,
        }
    }
    /// The drift order params of the message
    pub fn order_params(&self) -> OrderParams {
        match self.order {
            SignedOrderType::Authority { inner, .. } => inner.signed_msg_order_params,
            SignedOrderType::Delegated { inner, .. } => inner.signed_msg_order_params,
        }
    }
    /// Get the taker sub-account for the order
    ///
    /// `taker_authority` - the Authority pubkey of the taker's sub-account
    pub fn taker_subaccount(&self) -> Pubkey {
        match self.order {
            SignedOrderType::Authority { inner, .. } => {
                Wallet::derive_user_account(&self.taker_authority, inner.sub_account_id)
            }
            SignedOrderType::Delegated { inner, .. } => inner.taker_pubkey,
        }
    }
    /// serialize the order message for onchain use e.g. signature verification
    pub fn encode_for_signing(&self) -> Vec<u8> {
        // the swift message format can change
        // if the message was received from an external source then we have to preserve the serialization
        // if we are constructing it locally then it can be serialized without issue
        match self.order {
            SignedOrderType::Authority { ref raw, ref inner } => {
                if let Some(raw) = raw {
                    raw.as_bytes().into()
                } else {
                    let mut buf = Vec::with_capacity(SignedOrder::INIT_SPACE + 8);
                    (SWIFT_MSG_PREFIX).serialize(&mut buf).unwrap();
                    inner.serialize(&mut buf).unwrap();
                    hex::encode(buf).into()
                }
            }
            SignedOrderType::Delegated { ref raw, ref inner } => {
                if let Some(raw) = raw {
                    raw.as_bytes().into()
                } else {
                    let mut buf = Vec::with_capacity(SignedDelegateOrder::INIT_SPACE + 8);
                    (SWIFT_DELEGATE_MSG_PREFIX).serialize(&mut buf).unwrap();
                    inner.serialize(&mut buf).unwrap();
                    hex::encode(buf).into()
                }
            }
        }
    }
    /// convert swift order into anchor ix data
    pub fn to_ix_data(&self) -> Vec<u8> {
        let signed_msg = self.encode_for_signing();
        [
            self.signature.as_ref(),
            self.signer.as_ref(),
            &(signed_msg.len() as u16).to_le_bytes(),
            signed_msg.as_ref(),
        ]
        .concat()
    }

    /// Returns true if the order was signed using delegated authority
    pub fn using_delegate_signing(&self) -> bool {
        self.order.is_delegated()
    }

    pub fn new(
        uuid: String,
        taker_authority: Pubkey,
        signer: Pubkey,
        order: SignedOrderType,
        signature: Signature,
        pre_deposit: Option<String>,
    ) -> Self {
        Self {
            uuid,
            ts: unix_now_ms(),
            taker_authority,
            signer,
            order,
            signature,
            will_sanitize: false,
            pre_deposit,
        }
    }

    /// Build authority `SignedOrderInfo`
    pub fn authority(
        taker_authority: Pubkey,
        signed_order: SignedOrder,
        signature: Signature,
    ) -> Self {
        Self {
            uuid: core::str::from_utf8(&signed_order.uuid)
                .unwrap()
                .to_string(),
            ts: unix_now_ms(),
            order: SignedOrderType::authority(signed_order),
            signature,
            signer: taker_authority,
            taker_authority,
            will_sanitize: false,
            pre_deposit: None,
        }
    }

    /// Build delegated `SignedOrderInfo`
    pub fn delegated(
        taker_authority: Pubkey,
        signing_authority: Pubkey,
        delegated_order: SignedDelegateOrder,
        signature: Signature,
    ) -> Self {
        Self {
            uuid: core::str::from_utf8(&delegated_order.uuid)
                .unwrap()
                .to_string(),
            ts: unix_now_ms(),
            order: SignedOrderType::delegated(delegated_order),
            signature,
            signer: signing_authority,
            taker_authority,
            will_sanitize: false,
            pre_deposit: None,
        }
    }

    pub fn has_builder(&self) -> bool {
        match self.order {
            SignedOrderType::Authority { ref inner, .. } => {
                inner.builder_fee_tenth_bps.is_some() && inner.builder_idx.is_some()
            }
            SignedOrderType::Delegated { ref inner, .. } => {
                inner.builder_fee_tenth_bps.is_some() && inner.builder_idx.is_some()
            }
        }
    }
}

/// Emits swift orders from the Ws server
pub type SwiftOrderStream = ReceiverStream<SignedOrderInfo>;

/// Subscribe to the Swift WebSocket server, authenticate, and listen to new orders
///
/// * `client` - Drift client instance
/// * `markets` - markets to listen on for new swift orders
/// * `accept_sanitized` - set to true to receive *sanitized order flow (default: false)
/// * `accept_deposit_trades` - set to true to receive 'deposit+trade' order flow (default: false)
/// * `swift_ws_override` - custom swift Ws server endpoint
///
/// *a sanitized order may have its auction params modified by the program when
/// placed onchain. Makers should understand the time/price implications to accept these.
///
/// * deposit+trade orders require fillers to send an attached, preceding deposit tx
/// before the swift order
///
/// Returns a stream of new Swift order messages
pub async fn subscribe_swift_orders(
    client: &DriftClient,
    markets: &[MarketId],
    accept_sanitized: bool,
    accept_deposit_trades: bool,
    swift_ws_override: Option<String>,
) -> SdkResult<SwiftOrderStream> {
    let base_url = if let Some(custom_base_url) = swift_ws_override {
        custom_base_url
    } else if client.context == Context::MainNet {
        SWIFT_MAINNET_WS_URL.to_string()
    } else {
        SWIFT_DEVNET_WS_URL.to_string()
    };

    let maker_pubkey = client.wallet().authority().to_string();
    let uri = format!("{base_url}/ws?pubkey={maker_pubkey}");
    let (ws_stream, _) = connect_async(uri).await.map_err(|err| {
        log::error!(target: LOG_TARGET, "couldn't connect to server: {err:?}");
        SdkError::WsClient(Box::new(err))
    })?;

    let (mut outgoing, mut incoming) = ws_stream.split();

    // handle authentication and subscription
    while let Some(msg) = incoming.next().await {
        let msg = msg.map_err(|err| {
            log::error!(target: LOG_TARGET, "failed reading swift msg: {err:?}");
            SdkError::WsClient(Box::new(err))
        })?;

        if let Message::Text(text) = msg {
            log::debug!(target: LOG_TARGET, "msg: {text}");
            let message: Value = serde_json::from_str(&text).expect("Failed to parse message");

            if let Some(err) = message.get("error") {
                log::error!(target: LOG_TARGET, "swift server error: {err:?}");
                return Err(SdkError::WebsocketError);
            }

            // authenticate with Ws server
            if message["channel"] == "auth" && message.get("nonce").is_some() {
                let nonce = message["nonce"].as_str().expect("got nonce");
                let signature = client
                    .wallet()
                    .sign_message(nonce.as_bytes())
                    .expect("infallible");
                let signature_b64 =
                    base64::engine::general_purpose::STANDARD.encode(signature.as_ref());

                let auth_message = json!({
                    "pubkey": maker_pubkey,
                    "signature": signature_b64,
                })
                .to_string();
                outgoing.send(Message::Text(auth_message.into())).await?;
                continue;
            }

            // subscribe to markets
            if message["channel"] == "auth" && message["message"] == "Authenticated" {
                let subscribe_msgs: Vec<Result<Message, _>> = markets
                    .iter()
                    .filter_map(|m| {
                        assert!(m.is_perp(), "only perp markets");
                        let market = client
                            .program_data()
                            .perp_market_config_by_index(m.index())
                            .expect("market exists");
                        if !market.symbol().contains("BET") {
                            let subscribe_msg = json!({
                              "action": "subscribe",
                              "market_type": "perp",
                              "market_name": market.symbol(),
                            })
                            .to_string();
                            Some(Ok(Message::Text(subscribe_msg.into())))
                        } else {
                            // skipping bet market
                            log::debug!(target: LOG_TARGET, "skip subscribe for bet market: {}", market.market_index);
                            None
                        }
                    })
                    .collect();

                outgoing
                    .send_all(&mut futures_util::stream::iter(subscribe_msgs))
                    .await?;
                break;
            }
        }
    }

    let (tx, rx) = tokio::sync::mpsc::channel(256);

    // handle swift orders
    tokio::spawn(async move {
        while let Some(msg) = incoming.next().await {
            match msg {
                Ok(Message::Text(ref text)) => {
                    match serde_json::from_str::<OrderNotification>(text) {
                        Ok(OrderNotification {
                            channel: _,
                            mut order,
                            deposit,
                        }) => {
                            log::debug!(
                                target: LOG_TARGET,
                                "uuid: {}, latency: {}ms",
                                order.uuid,
                                unix_now_ms().saturating_sub(order.ts)
                            );

                            if let Some(deposit) = deposit {
                                if !accept_deposit_trades {
                                    log::debug!(
                                        target: LOG_TARGET,
                                        "skipping deposit+trade order: {}",
                                        order.uuid
                                    );
                                    continue;
                                }
                                order.pre_deposit = Some(deposit.to_string());
                            }

                            if !accept_sanitized {
                                log::debug!(
                                    target: LOG_TARGET,
                                    "skipping sanitized order: {}",
                                    order.uuid
                                );
                                continue;
                            }
                            if let Err(err) = tx.try_send(order) {
                                log::error!(target: LOG_TARGET, "order chan failed: {err:?}");
                                break;
                            }
                        }
                        Err(err) => {
                            if text.contains("heartbeat") {
                                if let Ok(heartbeat) = serde_json::from_str::<Heartbeat>(text) {
                                    log::debug!(
                                        target: LOG_TARGET,
                                        "heartbeat latency: {}",
                                        unix_now_ms().saturating_sub(heartbeat.ts)
                                    );
                                    continue;
                                }
                            }
                            log::error!(target: LOG_TARGET, "{text}. invalid json: {err:?}");
                            break;
                        }
                    }
                }
                Ok(Message::Close(_)) => {
                    log::error!(target: LOG_TARGET, "server closed connection");
                    break;
                }
                Ok(_) => continue,
                Err(err) => {
                    log::error!(target: LOG_TARGET, "failed reading swift msg: {err:?}");
                    break;
                }
            }
        }
    });

    Ok(ReceiverStream::new(rx))
}

fn unix_now_ms() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64
}

fn deser_pubkey<'de, D>(deserializer: D) -> Result<Pubkey, D::Error>
where
    D: serde::de::Deserializer<'de>,
{
    let s: &str = serde::de::Deserialize::deserialize(deserializer)?;
    Ok(s.parse().expect("base58 pubkey"))
}

fn deser_signature<'de, D>(deserializer: D) -> Result<Signature, D::Error>
where
    D: serde::de::Deserializer<'de>,
{
    let s: &str = serde::de::Deserialize::deserialize(deserializer)?;
    Ok(Signature::try_from(base64::engine::general_purpose::STANDARD.decode(s).unwrap()).unwrap())
}

fn deser_int_str<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: serde::de::Deserializer<'de>,
{
    let s: &str = serde::de::Deserialize::deserialize(deserializer)?;
    Ok(s.parse().unwrap())
}

/// Deserialize hex-ified, borsh bytes as a `SignedOrderType`
pub fn deser_signed_msg_type<'de, D>(deserializer: D) -> Result<SignedOrderType, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let payload: &str = serde::Deserialize::deserialize(deserializer)?;
    if payload.len() % 2 != 0 {
        return Err(serde::de::Error::custom("Hex string length must be even"));
    }

    // decode expecting the largest possible variant
    if (payload.len() / 2) > SignedDelegateOrder::INIT_SPACE + 8 || payload.is_empty() {
        return Err(serde::de::Error::custom("invalid signed message hex"));
    }

    let mut borsh_buf = [0u8; SignedDelegateOrder::INIT_SPACE + 8];
    hex::decode_to_slice(payload, &mut borsh_buf[..payload.len() / 2])
        .map_err(serde::de::Error::custom)?;

    // this is basically the same as if we derived AnchorDeserialize on `SignedOrderType` _expect_ it does not
    // add a u8 to distinguish the enum
    if borsh_buf[..8] == SWIFT_DELEGATE_MSG_PREFIX {
        AnchorDeserialize::deserialize(&mut &borsh_buf[8..])
            .map(|x| SignedOrderType::Delegated {
                raw: Some(payload.to_string()),
                inner: x,
            })
            .map_err(serde::de::Error::custom)
    } else {
        AnchorDeserialize::deserialize(&mut &borsh_buf[8..])
            .map(|x| SignedOrderType::Authority {
                raw: Some(payload.to_string()),
                inner: x,
            })
            .map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        drift_idl,
        types::{MarketType, OrderTriggerCondition, OrderType, PositionDirection, PostOnlyParam},
    };

    #[test]
    fn test_swift_order_deser_bad_message() {
        let msg = r#"{
            "channel":"signed_orders_perp_1",
            "order":{
                "market_index":1,
                "market_type":"perp",
                "order_message":"b9c165ffdf70594d0001010080841e00000000000000000000000000010000000000000000013201a4e99abc16000000011ab2f982160000000300900f84150000000072753959424c52740000b9c165ffdf70594d0001010080841e00000000000000000000000000010000000000000000013201a4e99abc16000000011ab2f982160000000300900f84150000000072753959424c52740000aabbccaabbccaabbccaabbcc",
                "order_signature":"FIgxWlW+C0abvtE8esSko7At1YGM8h66T0u5lJpwXirW63CuvEllVWZ68NNVFsaqcj4jqgQInXUnLPjIf/PQDA==",
                "signing_authority":"4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE",
                "taker_authority":"DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2",
                "ts":1739518796400,
                "uuid":"ru9YBLRt"
            }
        }"#;
        let result: Result<OrderNotification, _> = serde_json::from_str(&msg);
        assert!(result.is_err());

        let msg = r#"{
            "channel":"signed_orders_perp_1",
            "order":{
                "market_index":1,
                "market_type":"perp",
                "order_message":"",
                "order_signature":"FIgxWlW+C0abvtE8esSko7At1YGM8h66T0u5lJpwXirW63CuvEllVWZ68NNVFsaqcj4jqgQInXUnLPjIf/PQDA==",
                "signing_authority":"4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE",
                "taker_authority":"DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2",
                "ts":1739518796400,
                "uuid":"ru9YBLRt"
            }
        }"#;
        let result: Result<OrderNotification, _> = serde_json::from_str(&msg);
        assert!(result.is_err());
    }

    #[test]
    fn test_swift_order_deser() {
        let msg = r#"{
            "channel":"signed_orders_perp_1",
            "order":{
                "market_index":1,
                "market_type":"perp",
                "order_message":"b9c165ffdf70594d0001010080841e00000000000000000000000000010000000000000000013201a4e99abc16000000011ab2f982160000000300900f84150000000072753959424c52740000",
                "order_signature":"FIgxWlW+C0abvtE8esSko7At1YGM8h66T0u5lJpwXirW63CuvEllVWZ68NNVFsaqcj4jqgQInXUnLPjIf/PQDA==",
                "signing_authority":"4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE",
                "taker_authority":"DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2",
                "ts":1739518796400,
                "uuid":"ru9YBLRt"
            }
        }"#;
        let order_notification: OrderNotification = serde_json::from_str(&msg).unwrap();
        let signed_message = order_notification.order;
        assert_eq!(
            signed_message.signer,
            "4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE"
                .parse()
                .unwrap()
        );
        assert_eq!(
            signed_message.taker_authority,
            "DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2"
                .parse()
                .unwrap()
        );
        assert_eq!(signed_message.ts, 1739518796400);
        assert_eq!(signed_message.uuid, "ru9YBLRt");
        assert_eq!(signed_message.order_params().market_index, 1);
        assert_eq!(signed_message.order_params().market_type, MarketType::Perp);
    }

    #[test]
    fn test_swift_order_encode_for_signing() {
        let msg = "{\"channel\":\"swift_orders_perp_2\",\"order\":{\"market_index\":2,\"market_type\":\"perp\",\"order_message\":\"c8d5a65e2234f55d0001010080841e0000000000000000000000000002000000000000000001320124c6aa950000000001786b2f94000000000000bb64a9150000000074735730364f6d380000\",\"order_signature\":\"SaOaLJ1i0MqZ2cXdp00jGe2EJFa32eOfiQynFU7mclhT86yhIa4/tWXq7r6l7QPN0Jl6frfsZl0nNOvKZxZpAA==\",\"signing_authority\":\"4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE\",\"taker_authority\":\"4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE\",\"ts\":1740456840770,\"uuid\":\"tsW06Om8\"}}";
        let order_notification: OrderNotification = serde_json::from_str(&msg).unwrap();
        let signed_message = order_notification.order;
        assert_eq!(
            signed_message.encode_for_signing().as_slice(),
            b"c8d5a65e2234f55d0001010080841e0000000000000000000000000002000000000000000001320124c6aa950000000001786b2f94000000000000bb64a9150000000074735730364f6d380000"
        );
    }

    #[test]
    fn deser_ix_payload() {
        let data = hex_literal::hex!("204f658b1906620f040100000a09f3447ce77b9aa6374b05c5efb667042ca0cb15ca74af8a8b97b5ad09cd68aef5bda66b38c021c42ff59afad102b7ffa31bc9c52ee85a8752b3142d62b405833d29adc5096b41d5b9d3b2d6fe46deecb286644510a70f85b95853ec628209a20063386435613635653232333466353564303430313030303038306561383232623030303030303030303030303030303030303030303030303030303030303030303030303030303030313437373930303030303131343031623065386663666666666666666666663031343737393030303030303030303030303039303062323436383231343030303030303030363235393733333936393638343133353030303000");
        let ix = drift_idl::instructions::PlaceSignedMsgTakerOrder::deserialize(&mut &data[8..])
            .unwrap();
        // signature, pubkey, len(u16)
        let mut payload = hex::decode(&ix.signed_msg_order_params_message_bytes[98..]).unwrap();
        dbg!(payload[..8] == SWIFT_MSG_PREFIX);

        payload.resize(SignedOrder::INIT_SPACE, 0);
        let res: SignedOrder = AnchorDeserialize::deserialize(&mut &payload[8..]).unwrap();
        dbg!(res);
        dbg!(core::str::from_utf8(&res.uuid).unwrap());
    }

    #[test]
    fn deserialize_incoming_signed_message_delegated() {
        let order_message_raw = "42656638c7259e230001010080841e00000000000000000000000000020000000000000000013201bb60507d000000000117c0127c00000000395311d51c1b87fd56c3b5872d1041111e51f399b12d291d981a0ea383407295272108160000000073386c754a4c5a650000";
        let payload = serde_json::json!({
            "channel": "swift_orders_perp_2",
            "order": {
                "market_index": 2,
                "market_type": "perp",
                "order_message": order_message_raw,
                "order_signature": "9G8luwFfeAc25HwXCgaUjrKv6yJHcMFDq4Z4uPXqom5mhwZ63YU5g7p07Kxe/AKSt5A/9OPDh3nN/c9IHjkCDA==",
                "taker_authority": "4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE",
                "signing_authority": "GiMXQkJXLVjScmQDkoLJShBJpTh9SDPvT2AZQq8NyEBf",
                "ts": 1739518796400_u64,
                "uuid":"s8luJLZe"
            }
        })
        .to_string();
        let actual: OrderNotification<'_> =
            serde_json::from_str(payload.as_str()).expect("deserializes");

        assert_eq!(
            actual.order.signer,
            solana_sdk::pubkey!("GiMXQkJXLVjScmQDkoLJShBJpTh9SDPvT2AZQq8NyEBf")
        );
        assert_eq!(
            actual.order.taker_authority,
            solana_sdk::pubkey!("4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE")
        );
        assert_eq!(actual.order.order_uuid_str(), "s8luJLZe");

        if let SignedOrderType::Delegated {
            inner: signed_msg,
            raw,
        } = actual.order.order
        {
            let expected = SignedDelegateOrder {
                signed_msg_order_params: OrderParams {
                    order_type: OrderType::Market,
                    market_type: MarketType::Perp,
                    direction: PositionDirection::Short,
                    user_order_id: 0,
                    base_asset_amount: 2000000,
                    price: 0,
                    market_index: 2,
                    reduce_only: false,
                    post_only: PostOnlyParam::None,
                    bit_flags: 0,
                    max_ts: None,
                    trigger_price: None,
                    trigger_condition: OrderTriggerCondition::Above,
                    oracle_price_offset: None,
                    auction_duration: Some(50),
                    auction_start_price: Some(2102419643),
                    auction_end_price: Some(2081603607),
                },
                taker_pubkey: solana_sdk::pubkey!("4rmhwytmKH1XsgGAUyUUH7U64HS5FtT6gM8HGKAfwcFE"),
                slot: 369631527,
                uuid: [115, 56, 108, 117, 74, 76, 90, 101],
                take_profit_order_params: None,
                stop_loss_order_params: None,
                max_margin_ratio: None,
                builder_idx: None,
                builder_fee_tenth_bps: None,
                isolated_position_deposit: None,
            };
            assert_eq!(signed_msg, expected);
            assert_eq!(
                raw.unwrap().as_str(),
                order_message_raw,
                "preserved order message from payload"
            );
        } else {
            assert!(false, "unexpected variant");
        }
    }
}

```

## File: crates/src/titan.rs
```
#![cfg(feature = "titan")]
//! Titan SDK helpers
use solana_sdk::{message::AddressLookupTableAccount, pubkey::Pubkey};
pub use titan_swap_api_client::{
    quote::{Provider, QuoteRequest, QuoteResponse, SwapMode},
    swap::SwapResponse,
    TitanClient,
};

use crate::{
    types::{SdkError, SdkResult},
    utils, DriftClient,
};

/// Default Titan API url
const DEFAULT_TITAN_API_URL: &str = "https://api.titan.exchange";

/// Titan swap instructions and metadata
pub struct TitanSwapInfo {
    pub quote: QuoteResponse,
    pub ixs: SwapResponse,
    pub luts: Vec<AddressLookupTableAccount>,
}

pub trait TitanSwapApi {
    fn titan_swap_query(
        &self,
        user_authority: &Pubkey,
        amount: u64,
        max_accounts: Option<usize>,
        swap_mode: SwapMode,
        slippage_bps: u16,
        in_market: u16,
        out_market: u16,
        only_direct_routes: Option<bool>,
        excluded_dexes: Option<String>,
        providers: Option<Provider>,
    ) -> impl std::future::Future<Output = SdkResult<TitanSwapInfo>> + Send;
}

impl TitanSwapApi for DriftClient {
    /// Fetch Titan swap ixs and metadata for a token swap
    ///
    /// This function queries Titan API to get the optimal swap route and corresponding instructions
    /// for swapping between two tokens.
    ///
    /// # Arguments
    ///
    /// * `user_authority` - The public key of the user's wallet that will execute the swap
    /// * `amount` - The amount of input tokens to swap, in native units (smallest denomination)
    /// * `swap_mode` - The type of swap to perform (e.g. ExactIn, ExactOut)
    /// * `slippage_bps` - Maximum allowed slippage in basis points (1 bp = 0.01%)
    /// * `in_market` - The market index of the token to swap from
    /// * `out_market` - The market index of the token to swap to
    /// * `only_direct_routes` - If Some(true), only consider direct swap routes between the tokens
    /// * `excluded_dexes` - Optional comma-separated string of DEX names to exclude from routing
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing `TitanSwapInfo` with the swap instructions and route details
    /// if successful, or a `SdkError` if the operation fails.
    async fn titan_swap_query(
        &self,
        user_authority: &Pubkey,
        amount: u64,
        max_accounts: Option<usize>,
        swap_mode: SwapMode,
        slippage_bps: u16,
        in_market: u16,
        out_market: u16,
        only_direct_routes: Option<bool>,
        excluded_dexes: Option<String>,
        providers: Option<Provider>,
    ) -> SdkResult<TitanSwapInfo> {
        let in_market = self.try_get_spot_market_account(in_market)?;
        let out_market = self.try_get_spot_market_account(out_market)?;

        let titan_url = std::env::var("TITAN_BASE_URL").unwrap_or(DEFAULT_TITAN_API_URL.into());
        let auth_token = std::env::var("TITAN_AUTH_TOKEN").map_err(|err| {
            log::error!("titan auth token missing: {err:?}");
            SdkError::Generic("TITAN_AUTH_TOKEN must be set".into())
        })?;
        let client = TitanClient::new(auth_token, Some(titan_url));

        let quote_request = QuoteRequest {
            input_mint: in_market.mint,
            output_mint: out_market.mint,
            amount,
            user_pubkey: *user_authority,
            max_accounts,
            swap_mode: Some(swap_mode),
            slippage_bps,
            only_direct_routes,
            excluded_dexes,
            providers,
            ..Default::default()
        };

        // GET /quote
        let quote_response = client.quote(&quote_request).await.map_err(|err| {
            log::error!("titan api request: {err:?}");
            SdkError::Generic(err.to_string())
        })?;

        // Build swap instructions
        let swap_response = client.swap(&quote_response).map_err(|err| {
            log::error!("titan swap build error: {err:?}");
            SdkError::Generic(err.to_string())
        })?;

        // Fetch ALTs
        let res = self
            .rpc()
            .get_multiple_accounts(swap_response.address_lookup_table_addresses.as_slice())
            .await?;

        let luts = res
            .iter()
            .zip(swap_response.address_lookup_table_addresses.iter())
            .map(|(acc, key)| {
                utils::deserialize_alt(*key, acc.as_ref().expect("deser LUT")).expect("deser LUT")
            })
            .collect();

        Ok(TitanSwapInfo {
            luts,
            quote: quote_response,
            ixs: swap_response,
        })
    }
}

```

## File: crates/src/types.rs
```
use std::{
    cell::{BorrowError, BorrowMutError},
    cmp::Ordering,
    fmt::Display,
    str::FromStr,
};

use anchor_lang::{AnchorDeserialize, AnchorSerialize};
use dashmap::DashMap;
use pythnet_sdk::wire::v1::MerklePriceUpdate;
pub use solana_rpc_client_api::config::RpcSendTransactionConfig;
pub use solana_sdk::{
    commitment_config::CommitmentConfig, message::VersionedMessage,
    transaction::VersionedTransaction,
};
use solana_sdk::{
    instruction::{AccountMeta, InstructionError},
    pubkey::Pubkey,
    transaction::TransactionError,
};
use thiserror::Error;
use tokio::sync::oneshot;
use tokio_tungstenite::tungstenite;

// re-export types in public API
pub use crate::drift_idl::{
    accounts::{self},
    errors::{self},
    events::{self},
    instructions::{self},
    types::*,
};
use crate::{
    constants::{ids, LUTS_DEVNET, LUTS_MAINNET, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID},
    drift_idl::errors::ErrorCode,
    grpc::grpc_subscriber::GrpcError,
    types::accounts::UserStats,
    Wallet,
};

use self::accounts::SpotMarket;

/// Map from K => V
pub type MapOf<K, V> = DashMap<K, V, ahash::RandomState>;

/// Handle for unsubscribing from network updates
pub type UnsubHandle = oneshot::Sender<()>;

pub type SdkResult<T> = Result<T, SdkError>;

pub fn is_one_of_variant<T: PartialEq>(value: &T, variants: &[T]) -> bool {
    variants.iter().any(|variant| value == variant)
}

impl SpotMarket {
    /// Return the spot market's token program address
    pub fn token_program(&self) -> Pubkey {
        if self.is_token_2022_program() {
            TOKEN_2022_PROGRAM_ID
        } else {
            TOKEN_PROGRAM_ID
        }
    }
    /// Return true if spot market uses 2022 program
    pub fn is_token_2022_program(&self) -> bool {
        self.token_program_flag & TokenProgramFlag::Token2022 as u8 != 0
    }
    /// Return true if spot market has a 2022 transfer hook extension
    pub fn has_transfer_hook(&self) -> bool {
        self.token_program_flag & TokenProgramFlag::TransferHook as u8 != 0
    }
}

/// Drift program context
///
/// Contains network specific variables necessary for interacting with drift program
/// on different networks
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct Context {
    name: &'static str,
    /// market lookup table
    luts: &'static [Pubkey],
    /// pyth program ID
    pyth: Pubkey,
}

impl Context {
    /// Target MainNet context
    #[allow(non_upper_case_globals)]
    pub const MainNet: Context = Self {
        name: "mainnet",
        luts: LUTS_MAINNET,
        pyth: ids::pyth_program::ID,
    };
    /// Target DevNet context
    #[allow(non_upper_case_globals)]
    pub const DevNet: Context = Self {
        name: "devnet",
        luts: LUTS_DEVNET,
        pyth: ids::pyth_program::ID_DEVNET,
    };

    /// Return drift lookup table address(es)
    pub fn luts(&self) -> &[Pubkey] {
        self.luts
    }

    /// Return pyth owner address
    pub fn pyth(&self) -> Pubkey {
        self.pyth
    }

    /// Return name
    pub fn name(&self) -> &'static str {
        self.name
    }
}

/// Some data from chain along with the retreived slot
#[derive(Debug, Clone)]
pub struct DataAndSlot<T> {
    pub slot: u64,
    pub data: T,
}

/// Id of a Drift market
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MarketId {
    index: u16,
    kind: MarketType,
}

impl core::cmp::Eq for MarketType {}
impl core::hash::Hash for MarketType {
    fn hash<H: core::hash::Hasher>(&self, ra_expand_state: &mut H) {
        core::mem::discriminant(self).hash(ra_expand_state);
    }
}

impl MarketId {
    /// Create a new `MarketId` from parts
    pub fn new(index: u16, kind: MarketType) -> Self {
        Self { index, kind }
    }
    /// `MarketId` for the USDC Spot Market
    pub const QUOTE_SPOT: Self = Self {
        index: 0,
        kind: MarketType::Spot,
    };
    /// Id of a perp market
    pub const fn perp(index: u16) -> Self {
        Self {
            index,
            kind: MarketType::Perp,
        }
    }
    /// Id of a spot market
    pub const fn spot(index: u16) -> Self {
        Self {
            index,
            kind: MarketType::Spot,
        }
    }
    /// uint index of the market
    pub fn index(&self) -> u16 {
        self.index
    }
    /// type of the market
    pub fn kind(&self) -> MarketType {
        self.kind
    }
    /// Convert self into its parts
    pub fn to_parts(self) -> (u16, MarketType) {
        (self.index, self.kind)
    }
    pub fn is_perp(self) -> bool {
        self.kind == MarketType::Perp
    }
    pub fn is_spot(self) -> bool {
        self.kind == MarketType::Spot
    }
}

impl std::fmt::Debug for MarketId {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self.kind {
            MarketType::Perp => {
                write!(f, "perp/{}", self.index)
            }
            MarketType::Spot => {
                write!(f, "spot/{}", self.index)
            }
        }
    }
}

impl From<(u16, MarketType)> for MarketId {
    fn from(value: (u16, MarketType)) -> Self {
        Self {
            index: value.0,
            kind: value.1,
        }
    }
}

/// Provides builder API for Orders
#[derive(Default)]
pub struct NewOrder {
    order_type: OrderType,
    direction: PositionDirection,
    reduce_only: bool,
    market_id: MarketId,
    post_only: PostOnlyParam,
    ioc: u8,
    amount: u64,
    price: u64,
    user_order_id: u8,
}

impl NewOrder {
    /// Create a market order
    pub fn market(market_id: MarketId) -> Self {
        Self {
            order_type: OrderType::Market,
            market_id,
            ..Default::default()
        }
    }
    /// Create a limit order
    pub fn limit(market_id: MarketId) -> Self {
        Self {
            order_type: OrderType::Limit,
            market_id,
            ..Default::default()
        }
    }
    /// Set order amount
    ///
    /// A sub-zero amount indicates a short
    pub fn amount(mut self, amount: i64) -> Self {
        self.direction = if amount >= 0 {
            PositionDirection::Long
        } else {
            PositionDirection::Short
        };
        self.amount = amount.unsigned_abs();

        self
    }
    /// Set order price
    pub fn price(mut self, price: u64) -> Self {
        self.price = price;
        self
    }
    /// Set reduce only (default: false)
    pub fn reduce_only(mut self, flag: bool) -> Self {
        self.reduce_only = flag;
        self
    }
    /// Set immediate or cancel and other flags (default: false)
    pub fn bit_flags(mut self, flags: u8) -> Self {
        self.ioc = flags;
        self
    }
    /// Set post-only (default: None)
    pub fn post_only(mut self, value: PostOnlyParam) -> Self {
        self.post_only = value;
        self
    }
    /// Set user order id
    pub fn user_order_id(mut self, user_order_id: u8) -> Self {
        self.user_order_id = user_order_id;
        self
    }
    /// Call to complete building the Order
    pub fn build(self) -> OrderParams {
        OrderParams {
            order_type: self.order_type,
            market_index: self.market_id.index,
            market_type: self.market_id.kind,
            price: self.price,
            base_asset_amount: self.amount,
            reduce_only: self.reduce_only,
            direction: self.direction,
            bit_flags: self.ioc,
            post_only: self.post_only,
            user_order_id: self.user_order_id,
            ..Default::default()
        }
    }
}

#[derive(Debug, Error)]
pub enum SdkError {
    #[error("{0}")]
    Rpc(#[from] Box<solana_rpc_client_api::client_error::Error>),
    #[error("{0}")]
    Ws(#[from] Box<drift_pubsub_client::PubsubClientError>),
    #[error("{0}")]
    Anchor(#[from] Box<anchor_lang::error::Error>),
    #[error("error while deserializing")]
    Deserializing,
    #[error("invalid drift account")]
    InvalidAccount,
    #[error("invalid oracle account")]
    InvalidOracle,
    #[error("invalid keypair seed")]
    InvalidSeed,
    #[error("invalid base58 value")]
    InvalidBase58,
    #[error("user does not have position: {0}")]
    NoPosition(u16),
    #[error("insufficient SOL balance for fees")]
    OutOfSOL,
    #[error("{0}")]
    Signing(#[from] Box<solana_sdk::signer::SignerError>),
    #[error("Received Error from websocket")]
    WebsocketError,
    #[error("Missed DLOB heartbeat")]
    MissedHeartbeat,
    #[error("Unsupported account data format")]
    UnsupportedAccountData,
    #[error("Could not decode data: {0}")]
    CouldntDecode(#[from] base64::DecodeError),
    #[error("Couldn't join task: {0}")]
    CouldntJoin(#[from] tokio::task::JoinError),
    #[error("Couldn't send unsubscribe message")]
    CouldntUnsubscribe,
    #[error("MathError")]
    MathError(&'static str),
    #[error("{0}")]
    BorrowMutError(#[from] BorrowMutError),
    #[error("{0}")]
    BorrowError(#[from] BorrowError),
    #[error("{0}")]
    Generic(String),
    #[error("max connection attempts reached")]
    MaxReconnectionAttemptsReached,
    #[error("jit taker order not found")]
    JitOrderNotFound,
    #[error("market data unavailable. subscribe market: {0:?}")]
    NoMarketData(MarketId),
    #[error("account data unavailable. subscribe account: {0:?}")]
    NoAccountData(Pubkey),
    #[error("component is already subscribed")]
    AlreadySubscribed,
    #[error("invalid URL")]
    InvalidUrl,
    #[error("{0}")]
    WsClient(#[from] Box<tungstenite::Error>),
    #[error("libdrift_ffi_sys out-of-date")]
    LibDriftVersion,
    #[error("wallet signing disabled")]
    WalletSigningDisabled,
    #[error("{0}")]
    Grpc(#[from] Box<GrpcError>),
}

// Manual From implementations for unboxed error types to avoid breaking changes
impl From<solana_rpc_client_api::client_error::Error> for SdkError {
    fn from(e: solana_rpc_client_api::client_error::Error) -> Self {
        SdkError::Rpc(Box::new(e))
    }
}
impl From<drift_pubsub_client::PubsubClientError> for SdkError {
    fn from(e: drift_pubsub_client::PubsubClientError) -> Self {
        SdkError::Ws(Box::new(e))
    }
}
impl From<anchor_lang::error::Error> for SdkError {
    fn from(e: anchor_lang::error::Error) -> Self {
        SdkError::Anchor(Box::new(e))
    }
}
impl From<solana_sdk::signer::SignerError> for SdkError {
    fn from(e: solana_sdk::signer::SignerError) -> Self {
        SdkError::Signing(Box::new(e))
    }
}
impl From<tungstenite::Error> for SdkError {
    fn from(e: tungstenite::Error) -> Self {
        SdkError::WsClient(Box::new(e))
    }
}
impl From<GrpcError> for SdkError {
    fn from(e: GrpcError) -> Self {
        SdkError::Grpc(Box::new(e))
    }
}

#[derive(Debug, PartialEq)]
/// Solana program execution error
pub enum ProgramError {
    /// instruction error from Drift
    Drift(ErrorCode),
    /// instruction error from another program
    Other { ix_idx: u8, code: u32 },
}

impl Display for ProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Drift(code) => f.write_fmt(format_args!("drift: {code}")),
            Self::Other { ix_idx, code } => {
                f.write_fmt(format_args!("ix_idx: {ix_idx}, code: {code}"))
            }
        }
    }
}

impl SdkError {
    /// extract anchor error code from the SdkError if it exists
    pub fn to_anchor_error_code(&self) -> Option<ProgramError> {
        if let SdkError::Rpc(inner) = self {
            if let Some(TransactionError::InstructionError(
                ix_idx,
                InstructionError::Custom(code),
            )) = inner.get_transaction_error()
            {
                // inverse of anchor's 'From<ErrorCode> for u32'
                let err = match code.checked_sub(anchor_lang::error::ERROR_CODE_OFFSET) {
                    Some(code) => {
                        // this will saturate e.g. if u32 > |ErrorCode\ then it always returns the
                        // highest idx variant
                        ProgramError::Drift(unsafe { std::mem::transmute::<u32, ErrorCode>(code) })
                    }
                    None => ProgramError::Other { ix_idx, code },
                };
                return Some(err);
            }
        }
        None
    }
    /// convert to 'out of sol' error is possible
    pub fn to_out_of_sol_error(&self) -> Option<SdkError> {
        if let SdkError::Rpc(inner) = self {
            if let Some(
                TransactionError::InsufficientFundsForFee
                | TransactionError::InsufficientFundsForRent { account_index: _ },
            ) = inner.get_transaction_error()
            {
                return Some(Self::OutOfSOL);
            }
        }
        None
    }
}

/// Helper type for Accounts included in drift instructions
///
/// Provides sorting implementation matching drift program
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u8)]
pub(crate) enum RemainingAccount {
    Oracle { pubkey: Pubkey },
    Spot { pubkey: Pubkey, writable: bool },
    Perp { pubkey: Pubkey, writable: bool },
}

impl RemainingAccount {
    fn pubkey(&self) -> &Pubkey {
        match self {
            Self::Oracle { pubkey } => pubkey,
            Self::Spot { pubkey, .. } => pubkey,
            Self::Perp { pubkey, .. } => pubkey,
        }
    }
    fn parts(self) -> (Pubkey, bool) {
        match self {
            Self::Oracle { pubkey } => (pubkey, false),
            Self::Spot {
                pubkey, writable, ..
            } => (pubkey, writable),
            Self::Perp {
                pubkey, writable, ..
            } => (pubkey, writable),
        }
    }
    fn discriminant(&self) -> u8 {
        // SAFETY: Because `Self` is marked `repr(u8)`, its layout is a `repr(C)` `union`
        // between `repr(C)` structs, each of which has the `u8` discriminant as its first
        // field, so we can read the discriminant without offsetting the pointer.
        let ptr = <*const RemainingAccount>::from(self);
        unsafe { *ptr.cast::<u8>() }
    }
}

impl Ord for RemainingAccount {
    fn cmp(&self, other: &Self) -> Ordering {
        let type_order = self.discriminant().cmp(&other.discriminant());
        if let Ordering::Equal = type_order {
            self.pubkey().cmp(other.pubkey())
        } else {
            type_order
        }
    }
}

impl PartialOrd for RemainingAccount {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl From<RemainingAccount> for AccountMeta {
    fn from(value: RemainingAccount) -> Self {
        let (pubkey, is_writable) = value.parts();
        AccountMeta {
            pubkey,
            is_writable,
            is_signer: false,
        }
    }
}

/// Provide market precision information
pub trait MarketPrecision {
    // prices must be a multiple of this
    fn price_tick(&self) -> u64;
    // order sizes must be a multiple of this
    fn quantity_tick(&self) -> u64;
    /// smallest order size
    fn min_order_size(&self) -> u64;
}

impl MarketPrecision for accounts::SpotMarket {
    fn min_order_size(&self) -> u64 {
        self.min_order_size
    }
    fn price_tick(&self) -> u64 {
        self.order_tick_size
    }
    fn quantity_tick(&self) -> u64 {
        self.order_step_size
    }
}

impl MarketPrecision for accounts::PerpMarket {
    fn min_order_size(&self) -> u64 {
        self.amm.min_order_size
    }
    fn price_tick(&self) -> u64 {
        self.amm.order_tick_size
    }
    fn quantity_tick(&self) -> u64 {
        self.amm.order_step_size
    }
}

#[derive(Copy, Clone)]
pub struct ReferrerInfo {
    referrer: Pubkey,
    referrer_stats: Pubkey,
}

impl ReferrerInfo {
    pub fn new(referrer: Pubkey, referrer_stats: Pubkey) -> Self {
        Self {
            referrer,
            referrer_stats,
        }
    }

    pub fn referrer(&self) -> Pubkey {
        self.referrer
    }

    pub fn referrer_stats(&self) -> Pubkey {
        self.referrer_stats
    }

    pub fn get_referrer_info(taker_stats: accounts::UserStats) -> Option<Self> {
        if taker_stats.referrer == Pubkey::default() {
            return None;
        }

        let user_account_pubkey = Wallet::derive_user_account(&taker_stats.referrer, 0);
        let user_stats_pubkey = Wallet::derive_stats_account(&taker_stats.referrer);

        Some(Self {
            referrer: user_account_pubkey,
            referrer_stats: user_stats_pubkey,
        })
    }
}

impl Order {
    pub const ORACLE_TRIGGER_MARKET_FLAG: u8 = 0b0000_0010;
    pub const SAFE_TRIGGER_ORDER_FLAG: u8 = 0b0000_0100;
    pub const NEW_TRIGGER_REDUCE_ONLY_FLAG: u8 = 0b0000_1000;
    pub const HAS_BUILDER_FLAG: u8 = 0b0001_0000;
    pub fn is_oracle_trigger_market(&self) -> bool {
        (self.bit_flags & Self::ORACLE_TRIGGER_MARKET_FLAG) != 0
    }
    pub fn has_builder(&self) -> bool {
        (self.bit_flags & Self::HAS_BUILDER_FLAG) != 0
    }
}

impl OrderParams {
    pub const IMMEDIATE_OR_CANCEL_FLAG: u8 = 0b0000_0001;
    pub const HIGH_LEVERAGE_MODE_FLAG: u8 = 0b0000_0010;
    /// true if 'immediate or cancel' bit is set
    pub fn immediate_or_cancel(&self) -> bool {
        (self.bit_flags & Self::IMMEDIATE_OR_CANCEL_FLAG) > 0
    }
    /// true if HLM bit is set
    pub fn high_leverage_mode(&self) -> bool {
        (self.bit_flags & Self::HIGH_LEVERAGE_MODE_FLAG) > 0
    }
}

impl OrderType {
    pub fn as_str(&self) -> &str {
        match self {
            OrderType::Limit => "limit",
            OrderType::Market => "market",
            OrderType::Oracle => "oracle",
            OrderType::TriggerLimit => "trigger_limit",
            OrderType::TriggerMarket => "trigger_market",
        }
    }
}

impl MarketType {
    pub fn as_str(&self) -> &str {
        match self {
            MarketType::Perp => "perp",
            MarketType::Spot => "spot",
        }
    }
}

impl FromStr for MarketType {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.eq_ignore_ascii_case("perp") {
            Ok(Self::Perp)
        } else if s.eq_ignore_ascii_case("spot") {
            Ok(Self::Spot)
        } else {
            Err(())
        }
    }
}

#[derive(Clone, Copy, Default)]
pub struct ProtectedMakerParams {
    pub limit_price_divisor: u8,
    pub dynamic_offset: u64,
    pub tick_size: u64,
}

impl UserStats {
    pub fn is_referrer(&self) -> bool {
        self.referrer_status & 0b0000_0001 != 0
    }
    pub fn is_referred(&self) -> bool {
        self.referrer_status & 0b0000_0010 != 0
    }
}

#[derive(Clone, Copy, PartialEq, Debug, Eq)]
pub enum TokenProgramFlag {
    Token2022 = 0b00000001,
    TransferHook = 0b00000010,
}

// copied from pythnet-solana-receiver-sdk
use anchor_lang::prelude::borsh::{self};
#[derive(Debug, AnchorSerialize, AnchorDeserialize, Clone)]
pub struct PostUpdateAtomicParams {
    pub vaa: Vec<u8>,
    pub merkle_price_update: MerklePriceUpdate,
    pub treasury_id: u8,
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use solana_rpc_client_api::{
        client_error::{Error as ClientError, ErrorKind as ClientErrorKind},
        request::{RpcError, RpcRequest, RpcResponseErrorData},
        response::RpcSimulateTransactionResult,
    };
    use solana_sdk::{
        instruction::InstructionError, pubkey::Pubkey, transaction::TransactionError,
    };

    use super::{RemainingAccount, SdkError};
    use crate::{drift_idl::errors::ErrorCode, types::ProgramError, MarketType};

    #[test]
    fn market_type_str() {
        assert_eq!(MarketType::from_str("PERP").unwrap(), MarketType::Perp,);
        assert_eq!(MarketType::from_str("spot").unwrap(), MarketType::Spot,);
        assert_eq!("perp", MarketType::Perp.as_str());
        assert_eq!("spot", MarketType::Spot.as_str());
    }

    #[test]
    fn extract_anchor_error() {
        let err = SdkError::Rpc(
            Box::new(ClientError {
                request: Some(RpcRequest::SendTransaction),
                kind: ClientErrorKind::RpcError(
                    RpcError::RpcResponseError {
                        code: -32002,
                        message: "Transaction simulation failed: Error processing Instruction 0: custom program error: 0x17b7".to_string(),
                        data: RpcResponseErrorData::SendTransactionPreflightFailure(
                            RpcSimulateTransactionResult {
                                err: Some(TransactionError::InstructionError(0, InstructionError::Custom(6071))),
                                logs: None,
                                accounts: None,
                                units_consumed: None,
                                return_data: None,
                                inner_instructions: None,
                                replacement_blockhash: None,
                                loaded_accounts_data_size: None,
                            }
                        )
                    }
                )
            })
        );

        assert_eq!(
            err.to_anchor_error_code().unwrap(),
            ProgramError::Drift(ErrorCode::UserOrderIdAlreadyInUse),
        );
    }

    #[test]
    fn account_type_sorting() {
        let mut accounts = vec![
            RemainingAccount::Perp {
                pubkey: Pubkey::new_from_array([4_u8; 32]),
                writable: false,
            },
            RemainingAccount::Oracle {
                pubkey: Pubkey::new_from_array([2_u8; 32]),
            },
            RemainingAccount::Oracle {
                pubkey: Pubkey::new_from_array([1_u8; 32]),
            },
            RemainingAccount::Spot {
                pubkey: Pubkey::new_from_array([3_u8; 32]),
                writable: true,
            },
        ];
        accounts.sort();

        assert_eq!(
            accounts,
            vec![
                RemainingAccount::Oracle {
                    pubkey: Pubkey::new_from_array([1_u8; 32])
                },
                RemainingAccount::Oracle {
                    pubkey: Pubkey::new_from_array([2_u8; 32])
                },
                RemainingAccount::Spot {
                    pubkey: Pubkey::new_from_array([3_u8; 32]),
                    writable: true
                },
                RemainingAccount::Perp {
                    pubkey: Pubkey::new_from_array([4_u8; 32]),
                    writable: false
                },
            ]
        )
    }
}

#[derive(Clone, Debug)]
pub struct AccountUpdate {
    /// Address of the account
    pub pubkey: Pubkey,
    /// Owner of the account
    pub owner: Pubkey,
    pub lamports: u64,
    /// Serialized account data (e.g. Anchor/Borsh)
    pub data: Vec<u8>,
    /// Slot retrieved
    pub slot: u64,
}

pub type OnAccountFn = dyn Fn(&AccountUpdate) + Send + Sync + 'static;

/// Empty callback function pointer that does nothing - useful as a no-op callback
pub const EMPTY_ACCOUNT_CALLBACK: fn(&AccountUpdate) = |_: &AccountUpdate| {};

impl accounts::State {
    pub const MM_ORACLE_UPDATE_FLAG: u8 = 0b00000001;
    pub const MEDIAN_TRIGGER_PRICE_FLAG: u8 = 0b00000010;
    pub const BUILDER_CODES_FLAG: u8 = 0b00000100;
    pub const BUILDER_REFERRAL_FLAG: u8 = 0b00001000;

    pub fn has_mm_oracle_update_feature(&self) -> bool {
        (self.feature_bit_flags & Self::MM_ORACLE_UPDATE_FLAG) != 0
    }
    pub fn has_median_trigger_price_feature(&self) -> bool {
        (self.feature_bit_flags & Self::MEDIAN_TRIGGER_PRICE_FLAG) != 0
    }
    pub fn has_builder_codes_feature(&self) -> bool {
        (self.feature_bit_flags & Self::BUILDER_CODES_FLAG) != 0
    }
    pub fn has_builder_referral_feature(&self) -> bool {
        (self.feature_bit_flags & Self::BUILDER_REFERRAL_FLAG) != 0
    }
}

```

## File: crates/src/usermap.rs
```
use std::{
    str::FromStr,
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc, Mutex,
    },
};

use anchor_lang::{AccountDeserialize, AnchorDeserialize};
use dashmap::DashMap;
use serde_json::json;
use solana_account_decoder_client_types::UiAccountEncoding;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_rpc_client_api::{
    config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},
    filter::RpcFilterType,
    request::RpcRequest,
    response::{OptionalContext, RpcKeyedAccount},
};
use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey};

use crate::{
    constants,
    drift_idl::accounts::User,
    memcmp::{get_non_idle_user_filter, get_user_filter},
    utils::get_ws_url,
    websocket_program_account_subscriber::{
        WebsocketProgramAccountOptions, WebsocketProgramAccountSubscriber,
    },
    SdkResult, UnsubHandle,
};

/// Subscribes to the _all_ Drift users' account updates via Ws program subscribe
pub struct GlobalUserMap {
    subscribed: bool,
    subscription: WebsocketProgramAccountSubscriber,
    pub usermap: Arc<DashMap<String, User>>,
    sync_lock: Option<Mutex<()>>,
    latest_slot: Arc<AtomicU64>,
    commitment: CommitmentConfig,
    rpc: RpcClient,
}

impl GlobalUserMap {
    pub const SUBSCRIPTION_ID: &'static str = "usermap";

    pub fn new(
        commitment: CommitmentConfig,
        endpoint: String,
        sync: bool,
        additional_filters: Option<Vec<RpcFilterType>>,
    ) -> Self {
        let mut filters = vec![get_user_filter(), get_non_idle_user_filter()];
        filters.extend(additional_filters.unwrap_or_default());
        let options = WebsocketProgramAccountOptions {
            filters,
            commitment,
            encoding: UiAccountEncoding::Base64Zstd,
        };
        let url = get_ws_url(&endpoint).unwrap();

        let subscription = WebsocketProgramAccountSubscriber::new(url, options);

        let usermap = Arc::new(DashMap::new());
        let rpc = RpcClient::new_with_commitment(endpoint.clone(), commitment);
        let sync_lock = if sync { Some(Mutex::new(())) } else { None };

        Self {
            subscribed: false,
            subscription,
            usermap,
            sync_lock,
            latest_slot: Arc::new(AtomicU64::new(0)),
            commitment,
            rpc,
        }
    }

    pub async fn subscribe(&self) -> SdkResult<UnsubHandle> {
        if self.sync_lock.is_some() {
            self.sync().await?;
        }

        let unsub = self
            .subscription
            .subscribe::<User, _>(Self::SUBSCRIPTION_ID, {
                let latest_slot = self.latest_slot.clone();
                let user_map = self.usermap.clone();
                move |update| {
                    if update.data_and_slot.slot > latest_slot.load(Ordering::Relaxed) {
                        latest_slot.store(update.data_and_slot.slot, Ordering::Relaxed);
                    }
                    user_map.insert(update.pubkey.clone(), update.data_and_slot.data);
                }
            });

        Ok(unsub)
    }

    pub fn unsubscribe(self) -> SdkResult<()> {
        if self.subscribed {
            self.usermap.clear();
            self.latest_slot.store(0, Ordering::Relaxed);
        }
        Ok(())
    }

    pub fn size(&self) -> usize {
        self.usermap.len()
    }

    pub fn contains(&self, pubkey: &str) -> bool {
        self.usermap.contains_key(pubkey)
    }

    pub fn get(&self, pubkey: &str) -> Option<User> {
        self.usermap.get(pubkey).map(|user| *user.value())
    }

    pub async fn must_get(&self, pubkey: &str) -> SdkResult<User> {
        if let Some(user) = self.get(pubkey) {
            Ok(user)
        } else {
            let user_data = self
                .rpc
                .get_account_data(&Pubkey::from_str(pubkey).unwrap())
                .await?;
            let user = User::deserialize(&mut user_data.as_slice()).unwrap();
            self.usermap.insert(pubkey.to_string(), user);
            Ok(self.get(pubkey).unwrap())
        }
    }

    #[allow(clippy::await_holding_lock)]
    pub async fn sync(&self) -> SdkResult<()> {
        let sync_lock = self.sync_lock.as_ref().expect("expected sync lock");

        let _lock = match sync_lock.try_lock() {
            Ok(lock) => lock,
            Err(_) => return Ok(()),
        };

        let account_config = RpcAccountInfoConfig {
            commitment: Some(self.commitment),
            encoding: Some(self.subscription.options.encoding),
            ..RpcAccountInfoConfig::default()
        };

        let gpa_config = RpcProgramAccountsConfig {
            filters: Some(self.subscription.options.filters.clone()),
            account_config,
            with_context: Some(true),
            sort_results: None,
        };

        let response = self
            .rpc
            .send::<OptionalContext<Vec<RpcKeyedAccount>>>(
                RpcRequest::GetProgramAccounts,
                json!([constants::PROGRAM_ID.to_string(), gpa_config]),
            )
            .await?;

        if let OptionalContext::Context(accounts) = response {
            for account in accounts.value {
                let pubkey = account.pubkey;
                let user_data = account.account.data.decode().expect("User data");
                let data = User::try_deserialize_unchecked(&mut user_data.as_slice())
                    .expect("User deserializes");
                self.usermap.insert(pubkey, data);
            }

            self.latest_slot
                .store(accounts.context.slot, Ordering::Relaxed);
        }

        Ok(())
    }

    pub fn get_latest_slot(&self) -> u64 {
        self.latest_slot.load(Ordering::Relaxed)
    }
}

#[cfg(feature = "rpc_tests")]
mod tests {
    use crate::utils::test_envs::mainnet_endpoint;

    #[tokio::test]
    async fn test_usermap() {
        use solana_sdk::commitment_config::{CommitmentConfig, CommitmentLevel};

        use crate::usermap::GlobalUserMap;

        let commitment = CommitmentConfig {
            commitment: CommitmentLevel::Processed,
        };

        let mut usermap = GlobalUserMap::new(commitment, mainnet_endpoint(), true);
        usermap.subscribe().await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;

        dbg!(usermap.size());
        assert!(usermap.size() > 50000);

        dbg!(usermap.get_latest_slot());

        usermap.unsubscribe().await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;

        assert_eq!(usermap.size(), 0);
        assert_eq!(usermap.subscribed, false);
    }
}

```

## File: crates/src/utils.rs
```
//! SDK utility functions

use anchor_lang::Discriminator;
use base64::Engine;
use bytemuck::{bytes_of, Pod, Zeroable};
use serde_json::json;
use solana_sdk::{
    account::Account, address_lookup_table::AddressLookupTableAccount, bs58,
    instruction::Instruction, pubkey::Pubkey, signature::Keypair,
};

use crate::{
    constants::PROGRAM_ID,
    types::{SdkError, SdkResult},
};

// kudos @wphan
/// Try to parse secret `key` string
///
/// Returns error if the key cannot be parsed
pub fn read_keypair_str_multi_format(key: &str) -> SdkResult<Keypair> {
    // strip out any white spaces and new line/carriage return characters
    let key = key.replace([' ', '\n', '\r', '[', ']'], "");

    // first try to decode as a byte array
    if key.contains(',') {
        // decode the numbers array into json string
        let bytes: Result<Vec<u8>, _> = key.split(',').map(|x| x.parse::<u8>()).collect();
        if let Ok(bytes) = bytes {
            return Keypair::from_bytes(bytes.as_ref()).map_err(|_| SdkError::InvalidSeed);
        } else {
            return Err(SdkError::InvalidSeed);
        }
    }

    // try to decode as base58 string
    if let Ok(bytes) = bs58::decode(key.as_bytes()).into_vec() {
        return Keypair::from_bytes(bytes.as_ref()).map_err(|_| SdkError::InvalidSeed);
    }

    // try to decode as base64 string
    if let Ok(bytes) = base64::engine::general_purpose::STANDARD.decode(key.as_bytes()) {
        return Keypair::from_bytes(bytes.as_ref()).map_err(|_| SdkError::InvalidSeed);
    }

    Err(SdkError::InvalidSeed)
}

/// Try load a `Keypair` from a file path or given string, supports json format and base58 format.
pub fn load_keypair_multi_format(path_or_key: &str) -> SdkResult<Keypair> {
    if let Ok(data) = std::fs::read_to_string(path_or_key) {
        read_keypair_str_multi_format(data.as_str())
    } else {
        read_keypair_str_multi_format(path_or_key)
    }
}

const LOOKUP_TABLE_META_SIZE: usize = 56;

/// modified from sdk.1.17.x
/// https://docs.rs/solana-program/latest/src/solana_program/address_lookup_table/state.rs.html#192
pub fn deserialize_alt(address: Pubkey, account: &Account) -> SdkResult<AddressLookupTableAccount> {
    let raw_addresses_data: &[u8] = account.data.get(LOOKUP_TABLE_META_SIZE..).ok_or({
        // Should be impossible because table accounts must
        // always be LOOKUP_TABLE_META_SIZE in length
        SdkError::InvalidAccount
    })?;
    let addresses = bytemuck::try_cast_slice(raw_addresses_data).map_err(|_| {
        // Should be impossible because raw address data
        // should be aligned and sized in multiples of 32 bytes
        SdkError::InvalidAccount
    })?;

    Ok(AddressLookupTableAccount {
        key: address,
        addresses: addresses.to_vec(),
    })
}

pub fn http_to_ws(url: &str) -> Result<String, &'static str> {
    let base_url = if url.starts_with("http://") {
        url.replacen("http://", "ws://", 1)
    } else if url.starts_with("https://") {
        url.replacen("https://", "wss://", 1)
    } else {
        return Err("Invalid URL scheme");
    };

    Ok(format!("{}/ws", base_url.trim_end_matches('/')))
}

/// Convert a url string into a Ws equivalent
pub fn get_ws_url(url: &str) -> SdkResult<String> {
    if url.starts_with("http://") || url.starts_with("https://") {
        Ok(url.replacen("http", "ws", 1))
    } else if url.starts_with("wss://") || url.starts_with("ws://") {
        Ok(url.to_string())
    } else {
        #[cfg(test)]
        {
            if url.starts_with("MockSender") {
                return Ok("ws://mock.sender.com".into());
            }
        }
        Err(SdkError::InvalidUrl)
    }
}

/// Convert a url string into an Http equivalent
pub fn get_http_url(url: &str) -> SdkResult<String> {
    if url.starts_with("http://") || url.starts_with("https://") {
        Ok(url.to_string())
    } else if url.starts_with("ws://") || url.starts_with("wss://") {
        Ok(url.replacen("ws", "http", 1))
    } else {
        Err(SdkError::InvalidUrl)
    }
}

pub fn dlob_subscribe_ws_json(market: &str) -> String {
    json!({
        "type": "subscribe",
        "marketType": if market.ends_with("perp") {
            "perp"
        } else {
            "spot"
        },
        "channel": "orderbook",
        "market": market,
    })
    .to_string()
}

pub fn zero_account_to_bytes<T: bytemuck::Pod + anchor_lang::Discriminator>(account: T) -> Vec<u8> {
    let mut account_data = vec![0; 8 + std::mem::size_of::<T>()];
    account_data[0..8].copy_from_slice(T::DISCRIMINATOR);
    account_data[8..].copy_from_slice(bytemuck::bytes_of(&account));
    account_data
}

/// zero-copy deserialize anchor account `data` as T
///
/// ## Params
/// - * `data` - Anchor borsh encoded buffer (including discriminator)
///
#[inline]
pub fn deser_zero_copy<T: Discriminator + Pod>(data: &[u8]) -> &T {
    bytemuck::from_bytes::<T>(&data[8..])
}

/// Derive pyth lazer oracle pubkey for DriftV2 program
pub fn derive_pyth_lazer_oracle_public_key(feed_id: u32) -> Pubkey {
    let seed_prefix = b"pyth_lazer";
    let feed_id_bytes = feed_id.to_le_bytes();

    let (pubkey, _bump) = Pubkey::find_program_address(&[seed_prefix, &feed_id_bytes], &PROGRAM_ID);
    pubkey
}

pub mod test_envs {
    //! test env vars
    use solana_sdk::signature::Keypair;

    /// solana mainnet endpoint
    pub fn mainnet_endpoint() -> String {
        std::env::var("TEST_MAINNET_RPC_ENDPOINT").expect("TEST_MAINNET_RPC_ENDPOINT set")
    }
    /// solana devnet endpoint
    pub fn devnet_endpoint() -> String {
        std::env::var("TEST_DEVNET_RPC_ENDPOINT")
            .unwrap_or_else(|_| "https://api.devnet.solana.com".to_string())
    }
    /// keypair for integration tests
    pub fn test_keypair() -> Keypair {
        let private_key = std::env::var("TEST_PRIVATE_KEY").expect("TEST_PRIVATE_KEY set");
        Keypair::from_base58_string(private_key.as_str())
    }
    /// keypair for mainnet integration tests
    pub fn mainnet_test_keypair() -> Keypair {
        let private_key =
            std::env::var("TEST_MAINNET_PRIVATE_KEY").expect("TEST_MAINNET_PRIVATE_KEY set");
        Keypair::from_base58_string(private_key.as_str())
    }
}

/// copy of `solana_sdk::ed25519_instruction::Ed25519SignatureOffsets`
/// it is missing useful constructors and public fields
#[derive(Default, Debug, Copy, Clone, Zeroable, Pod, Eq, PartialEq)]
#[repr(C)]
struct Ed25519SignatureOffsets {
    pub signature_offset: u16, // offset to ed25519 signature of 64 bytes
    pub signature_instruction_index: u16, // instruction index to find signature
    pub public_key_offset: u16, // offset to public key of 32 bytes
    pub public_key_instruction_index: u16, // instruction index to find public key
    pub message_data_offset: u16, // offset to start of message data
    pub message_data_size: u16, // size of message data
    pub message_instruction_index: u16, // index of instruction data to get message data
}

/// Build a new ed25519 verify ix pointing to another ix for data
///
/// ## Params
/// - `magic_len` additional message offset from the start of `message` e.g. pyth lazer has a u32 prefix
///   DEV: this constructor should exist in `solana_sdk::ed25519_instruction` but does not.
pub fn new_ed25519_ix_ptr(
    message: &[u8],
    instruction_index: u16,
    magic_len: Option<usize>,
) -> Instruction {
    let mut instruction_data = Vec::with_capacity(solana_sdk::ed25519_instruction::DATA_START);
    let message_offset = 12_usize;
    let signature_offset = message_offset + magic_len.unwrap_or_default();
    let public_key_offset =
        signature_offset.saturating_add(solana_sdk::ed25519_instruction::SIGNATURE_SERIALIZED_SIZE);
    let message_data_size_offset =
        public_key_offset.saturating_add(solana_sdk::ed25519_instruction::PUBKEY_SERIALIZED_SIZE);
    let message_data_size = u16::from_le_bytes([
        message[message_data_size_offset - message_offset],
        message[message_data_size_offset - message_offset + 1],
    ]);
    let message_data_offset = message_data_size_offset + 2;

    // add padding byte so that offset structure is aligned
    let num_signatures: u8 = 1;
    instruction_data.extend_from_slice(&[num_signatures, 0]);
    instruction_data.extend_from_slice(bytes_of(&Ed25519SignatureOffsets {
        signature_offset: signature_offset as u16,
        signature_instruction_index: instruction_index,
        public_key_offset: public_key_offset as u16,
        public_key_instruction_index: instruction_index,
        message_data_offset: message_data_offset as u16,
        message_data_size,
        message_instruction_index: instruction_index,
    }));

    Instruction {
        program_id: solana_sdk::ed25519_program::id(),
        accounts: vec![],
        data: instruction_data,
    }
}

pub fn get_anchor_account_bytes<T: bytemuck::Pod + Discriminator>(account: &mut T) -> &[u8] {
    bytemuck::bytes_of(account)
}

#[cfg(test)]
pub mod test_utils {
    //! test utilities

    use anchor_lang::Discriminator;
    use bytes::BytesMut;
    // helpers from drift-program test_utils.
    pub fn get_pyth_price(price: i64, expo: i32) -> pyth_test::Price {
        let mut pyth_price = pyth_test::Price::default();
        let price = price * 10_i64.pow(expo as u32);
        pyth_price.agg.price = price;
        pyth_price.twap = price;
        pyth_price.expo = expo;
        pyth_price
    }

    mod pyth_test {
        //! helper structs for pyth oracle prices
        use bytemuck::{Pod, Zeroable};
        use serde::Serialize;

        #[derive(Default, Copy, Clone, Serialize)]
        #[repr(C)]
        pub struct AccKey {
            pub val: [u8; 32],
        }

        #[derive(Copy, Clone, Default, Serialize)]
        #[repr(C)]
        #[allow(dead_code)]
        pub enum PriceStatus {
            Unknown,
            #[default]
            Trading,
            Halted,
            Auction,
        }

        #[derive(Copy, Clone, Default, Serialize)]
        #[repr(C)]
        pub enum CorpAction {
            #[default]
            NoCorpAct,
        }

        #[derive(Default, Copy, Clone, Serialize)]
        #[repr(C)]
        pub struct PriceInfo {
            pub price: i64,
            pub conf: u64,
            pub status: PriceStatus,
            pub corp_act: CorpAction,
            pub pub_slot: u64,
        }
        #[derive(Default, Copy, Clone, Serialize)]
        #[repr(C)]
        pub struct PriceComp {
            publisher: AccKey,
            agg: PriceInfo,
            latest: PriceInfo,
        }

        #[derive(Copy, Clone, Default, Serialize)]
        #[repr(C)]
        #[allow(dead_code, clippy::upper_case_acronyms)]
        pub enum PriceType {
            Unknown,
            #[default]
            Price,
            TWAP,
            Volatility,
        }

        #[derive(Default, Copy, Clone, Serialize)]
        #[repr(C)]
        pub struct Price {
            pub magic: u32,       // Pyth magic number.
            pub ver: u32,         // Program version.
            pub atype: u32,       // Account type.
            pub size: u32,        // Price account size.
            pub ptype: PriceType, // Price or calculation type.
            pub expo: i32,        // Price exponent.
            pub num: u32,         // Number of component prices.
            pub unused: u32,
            pub curr_slot: u64,        // Currently accumulating price slot.
            pub valid_slot: u64,       // Valid slot-time of agg. price.
            pub twap: i64,             // Time-weighted average price.
            pub avol: u64,             // Annualized price volatility.
            pub drv0: i64,             // Space for future derived values.
            pub drv1: i64,             // Space for future derived values.
            pub drv2: i64,             // Space for future derived values.
            pub drv3: i64,             // Space for future derived values.
            pub drv4: i64,             // Space for future derived values.
            pub drv5: i64,             // Space for future derived values.
            pub prod: AccKey,          // Product account key.
            pub next: AccKey,          // Next Price account in linked list.
            pub agg_pub: AccKey,       // Quoter who computed last aggregate price.
            pub agg: PriceInfo,        // Aggregate price info.
            pub comp: [PriceComp; 32], // Price components one per quoter.
        }

        #[cfg(target_endian = "little")]
        unsafe impl Zeroable for Price {}

        #[cfg(target_endian = "little")]
        unsafe impl Pod for Price {}
    }

    pub fn get_account_bytes<T: bytemuck::Pod>(account: &mut T) -> BytesMut {
        let mut bytes = BytesMut::new();
        let data = bytemuck::bytes_of_mut(account);
        bytes.extend_from_slice(data);
        bytes
    }

    pub fn get_anchor_account_bytes<T: bytemuck::Pod + Discriminator>(account: &mut T) -> BytesMut {
        let mut bytes = BytesMut::new();
        bytes.extend_from_slice(T::DISCRIMINATOR);
        let data = bytemuck::bytes_of_mut(account);
        bytes.extend_from_slice(data);
        bytes
    }

    #[macro_export]
    macro_rules! create_account_info {
        ($account:expr, $pubkey:expr, $owner:expr, $name: ident) => {
            let acc = Account {
                data: crate::utils::test_utils::get_account_bytes(&mut $account).to_vec(),
                owner: $owner,
                ..Default::default()
            };
            let $name: crate::ffi::AccountWithKey = (*$pubkey, acc).into();
        };
    }

    #[macro_export]
    macro_rules! create_anchor_account_info {
        ($account:expr, $pubkey:expr, $type:ident, $name: ident) => {
            let owner = constants::PROGRAM_ID;
            let acc = Account {
                data: crate::utils::test_utils::get_anchor_account_bytes(&mut $account).to_vec(),
                owner,
                ..Default::default()
            };
            let $name: crate::ffi::AccountWithKey = ($pubkey, acc).into();
        };
    }
}

#[cfg(test)]
mod tests {
    use solana_sdk::signer::Signer;

    use super::*;

    #[test]
    fn test_keypair_from_json_numbers_array() {
        let keypair_data = "[17,188,105,73,182,3,56,125,157,20,12,82,88,197,181,202,251,248,97,103,215,165,233,145,114,254,20,89,100,79,207,168,206,103,77,58,215,94,196,155,224,116,73,74,62,200,30,248,101,102,164,126,6,170,77,190,186,142,107,222,3,242,143,155]";

        let keypair = read_keypair_str_multi_format(keypair_data).unwrap();
        assert!(keypair.pubkey().to_string() == "EtiM5qwcrrawQP9FfRErBatNvDgEU656tk5aA8iTgqri");
    }

    #[test]
    fn test_keypair_from_json_comma_separated_numbers() {
        let keypair_data = "17,188,105,73,182,3,56,125,157,20,12,82,88,197,181,202,251,248,97,103,215,165,233,145,114,254,20,89,100,79,207,168,206,103,77,58,215,94,196,155,224,116,73,74,62,200,30,248,101,102,164,126,6,170,77,190,186,142,107,222,3,242,143,155";

        let keypair = read_keypair_str_multi_format(keypair_data).unwrap();
        assert!(keypair.pubkey().to_string() == "EtiM5qwcrrawQP9FfRErBatNvDgEU656tk5aA8iTgqri");
    }

    #[test]
    fn test_keypair_from_base58_string() {
        let keypair_data = "MZsY4Vme2Xa417rhh1MUGCru9oYNDxCjH1TZRWJPNSzRmZmodjczVaGuWKgzBsoKxx2ZLQZjUWTkLu44jE5DhSJ";

        let keypair = read_keypair_str_multi_format(keypair_data).unwrap();
        assert!(keypair.pubkey().to_string() == "EtiM5qwcrrawQP9FfRErBatNvDgEU656tk5aA8iTgqri");
    }

    #[test]
    fn test_keypair_from_base64_string() {
        let keypair_data = "EbxpSbYDOH2dFAxSWMW1yvv4YWfXpemRcv4UWWRPz6jOZ006117Em+B0SUo+yB74ZWakfgaqTb66jmveA/KPmw==";

        let keypair = read_keypair_str_multi_format(keypair_data).unwrap();
        assert!(keypair.pubkey().to_string() == "EtiM5qwcrrawQP9FfRErBatNvDgEU656tk5aA8iTgqri");
    }

    #[test]
    fn test_https_to_ws() {
        let https_url = "https://dlob.drift.trade";
        assert!(http_to_ws(https_url).unwrap() == "wss://dlob.drift.trade/ws");
        let http_url = "http://dlob.drift.trade";
        assert!(http_to_ws(http_url).unwrap() == "ws://dlob.drift.trade/ws")
    }
}

```

## File: crates/src/wallet.rs
```
use std::sync::Arc;

use solana_sdk::{
    hash::Hash,
    message::VersionedMessage,
    pubkey::Pubkey,
    signature::{keypair_from_seed, Keypair, Signature},
    signer::Signer,
    transaction::VersionedTransaction,
};

use crate::{
    constants::{self},
    types::{accounts::SpotMarket, SdkError, SdkResult},
    utils,
};

/// Wallet operation mode
#[derive(Clone, Debug)]
pub enum Mode {
    /// Normal tx signing
    Normal,
    /// Tx signing will fail
    ReadOnly,
    /// Tx signed by delegate
    Delegated,
}

/// Drift wallet
/// ```example(no_run)
/// // load wallet from base58 private key or path to wallet.json
/// let wallet = Wallet::try_from_str("PRIVATE_KEY").unwrap();
///
/// // construct wallet for delegated signing
/// let delegated_keypair = solana_sdk::signature::Keypair::new();
/// let delegated_wallet = Wallet::delegated(delegated_keypair, drift_account_key);
///
/// // place holder wallet for readonly apps
/// let ro_wallet = Wallet::read_only(drift_authority);
/// ```
#[derive(Clone, Debug)]
pub struct Wallet {
    /// The signing keypair, it could be authority or delegate
    signer: Arc<Keypair>,
    /// The drift 'authority' account
    /// user (sub)accounts are derived from this
    authority: Pubkey,
    /// The drift 'stats' account
    stats: Pubkey,
    /// Wallet operation mode
    mode: Mode,
}

impl Wallet {
    /// Returns true if the wallet is configured for delegated signing
    pub fn is_delegated(&self) -> bool {
        matches!(self.mode, Mode::Delegated)
    }
    /// Returns true if the wallet is configured for read-only/emulation mode
    pub fn is_read_only(&self) -> bool {
        matches!(self.mode, Mode::ReadOnly)
    }
    /// Init wallet from a string of either file path or the encoded private key
    /// ```example(no_run)
    /// // from private key str
    /// let wallet = Wallet::try_from_str("PRIVATE_KEY").unwrap();
    ///
    /// // from file path
    /// let wallet = Wallet::try_from_str("/path/to/wallet.json").unwrap();
    /// ```
    pub fn try_from_str(path_or_key: &str) -> SdkResult<Self> {
        let authority = utils::load_keypair_multi_format(path_or_key)?;
        Ok(Self::new(authority))
    }
    /// Construct a read-only wallet
    pub fn read_only(authority: Pubkey) -> Self {
        Self {
            signer: Arc::new(Keypair::new()),
            authority,
            stats: Wallet::derive_stats_account(&authority),
            mode: Mode::ReadOnly,
        }
    }
    /// Init wallet from base58 encoded seed, uses default sub-account
    ///
    /// * `seed` - base58 encoded private key
    ///
    /// # panics
    /// if the key is invalid
    pub fn from_seed_bs58(seed: &str) -> Self {
        let authority = Keypair::from_base58_string(seed);
        Self::new(authority)
    }
    /// Init wallet from seed bytes, uses default sub-account
    pub fn from_seed(seed: &[u8]) -> SdkResult<Self> {
        let authority = keypair_from_seed(seed).map_err(|_| SdkError::InvalidSeed)?;
        Ok(Self::new(authority))
    }
    /// Init wallet with keypair
    ///
    /// * `authority` - keypair for tx signing
    pub fn new(authority: Keypair) -> Self {
        Self {
            stats: Wallet::derive_stats_account(&authority.pubkey()),
            authority: authority.pubkey(),
            signer: Arc::new(authority),
            mode: Mode::Normal,
        }
    }
    /// Convert the wallet into a delegated one by providing the `authority` public key
    ///
    /// * `authority` - keypair for tx signing
    #[deprecated = "use Wallet::delegated"]
    pub fn to_delegated(&mut self, authority: Pubkey) {
        self.stats = Wallet::derive_stats_account(&authority);
        self.authority = authority;
        self.mode = Mode::Delegated;
    }
    /// Create a delegated wallet
    ///
    /// * `signer` - the delegated keypair for tx signing
    /// * `authority` - drift account to sign for (the delegator)
    pub fn delegated(signer: Keypair, authority: Pubkey) -> Self {
        Self {
            signer: Arc::new(signer),
            stats: Wallet::derive_stats_account(&authority),
            authority,
            mode: Mode::Delegated,
        }
    }
    /// Calculate the address of a drift user account/sub-account
    pub fn derive_user_account(authority: &Pubkey, sub_account_id: u16) -> Pubkey {
        let (account_drift_pda, _seed) = Pubkey::find_program_address(
            &[
                &b"user"[..],
                authority.as_ref(),
                &sub_account_id.to_le_bytes(),
            ],
            &constants::PROGRAM_ID,
        );
        account_drift_pda
    }

    /// Calculate the address of a drift stats account
    pub fn derive_stats_account(account: &Pubkey) -> Pubkey {
        let (account_drift_pda, _seed) = Pubkey::find_program_address(
            &[&b"user_stats"[..], account.as_ref()],
            &constants::PROGRAM_ID,
        );
        account_drift_pda
    }

    /// Calculate the address of `authority`s swift (taker) order account
    pub fn derive_swift_order_account(authority: &Pubkey) -> Pubkey {
        let (account_drift_pda, _seed) = Pubkey::find_program_address(
            &[&b"SIGNED_MSG"[..], authority.as_ref()],
            &constants::PROGRAM_ID,
        );
        account_drift_pda
    }

    /// Calculate the wallet's ATA for drift spot market
    pub fn derive_associated_token_address(authority: &Pubkey, market: &SpotMarket) -> Pubkey {
        spl_associated_token_account::get_associated_token_address_with_program_id(
            authority,
            &market.mint,
            &market.token_program(),
        )
    }

    /// Signs a solana message (ixs, accounts) and builds a signed tx
    /// ready for sending over RPC
    ///
    /// * `message` - solana VersionedMessage
    /// * `recent_block_hash` blockhash for  tx longevity
    ///
    /// Returns `VersionedTransaction` on success
    pub fn sign_tx(
        &self,
        mut message: VersionedMessage,
        recent_block_hash: Hash,
    ) -> SdkResult<VersionedTransaction> {
        message.set_recent_blockhash(recent_block_hash);
        let signer: &dyn Signer = self.signer.as_ref();
        match self.mode {
            Mode::ReadOnly => Err(SdkError::WalletSigningDisabled),
            _ => VersionedTransaction::try_new(message, &[signer]).map_err(Into::into),
        }
    }

    /// Sign message with the wallet's signer
    pub fn sign_message(&self, message: &[u8]) -> SdkResult<Signature> {
        let signer: &dyn Signer = self.signer.as_ref();
        match self.mode {
            Mode::ReadOnly => Err(SdkError::WalletSigningDisabled),
            _ => Ok(signer.sign_message(message)),
        }
    }
    /// Return the wallet authority address
    pub fn authority(&self) -> &Pubkey {
        &self.authority
    }
    /// Return the wallet signing address
    pub fn signer(&self) -> Pubkey {
        self.signer.pubkey()
    }
    /// Return the drift user stats address
    pub fn stats(&self) -> &Pubkey {
        &self.stats
    }
    /// Return the address of the default sub-account (0)
    pub fn default_sub_account(&self) -> Pubkey {
        self.sub_account(0)
    }
    /// Calculate the drift user address given a `sub_account_id`
    pub fn sub_account(&self, sub_account_id: u16) -> Pubkey {
        Self::derive_user_account(self.authority(), sub_account_id)
    }
}

impl From<Keypair> for Wallet {
    fn from(value: Keypair) -> Self {
        Self::new(value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn wallet_read_only() {
        let keypair = Keypair::new();
        let ro = Wallet::read_only(keypair.pubkey());

        let rw = Wallet::new(keypair);
        assert_eq!(rw.authority, ro.authority);
        assert_eq!(rw.stats, ro.stats);
        assert_eq!(rw.default_sub_account(), ro.default_sub_account());
    }
}

```

## File: crates/src/websocket_account_subscriber.rs
```
use std::{str::FromStr, sync::Arc};

use drift_pubsub_client::PubsubClient;
use futures_util::StreamExt;
use log::warn;
use solana_account_decoder_client_types::UiAccountEncoding;
use solana_rpc_client::nonblocking::rpc_client::RpcClient;
use solana_rpc_client_api::config::RpcAccountInfoConfig;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey};
use tokio::sync::oneshot;

use crate::{utils::get_http_url, AccountUpdate, SdkError, SdkResult, UnsubHandle};

const LOG_TARGET: &str = "wsaccsub";

#[derive(Clone)]
pub struct WebsocketAccountSubscriber {
    pubsub: Arc<PubsubClient>,
    pub pubkey: Pubkey,
    pub commitment: CommitmentConfig,
}

impl WebsocketAccountSubscriber {
    pub fn new(pubsub: Arc<PubsubClient>, pubkey: Pubkey, commitment: CommitmentConfig) -> Self {
        WebsocketAccountSubscriber {
            pubsub,
            pubkey,
            commitment,
        }
    }

    /// Start a Ws account subscription task
    ///
    /// * `subscription_name` - some user defined identifier for the subscription
    /// * `sync` - true if subscription should fetch account data on start
    /// * `on_update` - function to call on updates from the subscription
    ///
    /// Fetches the account to set the initial value, then uses event based updates
    pub async fn subscribe<F>(
        &self,
        subscription_name: &'static str,
        sync: bool,
        on_update: F,
    ) -> SdkResult<UnsubHandle>
    where
        F: 'static + Send + Fn(&AccountUpdate),
    {
        if sync {
            // seed initial account state
            log::debug!(
                target: LOG_TARGET,
                "seeding account: {subscription_name}-{:?}",
                self.pubkey
            );
            let owner: Pubkey;
            let rpc = RpcClient::new(get_http_url(self.pubsub.url().as_str())?);
            match rpc
                .get_account_with_commitment(&self.pubkey, self.commitment)
                .await
            {
                Ok(response) => {
                    if let Some(account) = response.value {
                        owner = account.owner;
                        on_update(&AccountUpdate {
                            owner,
                            lamports: account.lamports,
                            pubkey: self.pubkey,
                            data: account.data,
                            slot: response.context.slot,
                        });
                    } else {
                        warn!("seeding account failed: {response:?}");
                        return Err(SdkError::InvalidAccount);
                    }
                }
                Err(err) => {
                    warn!("seeding account failed: {err:?}");
                    return Err(err.into());
                }
            }
            drop(rpc);
        }

        let (unsub_tx, mut unsub_rx) = oneshot::channel::<()>();
        let account_config = RpcAccountInfoConfig {
            commitment: Some(self.commitment),
            encoding: Some(UiAccountEncoding::Base64Zstd),
            ..RpcAccountInfoConfig::default()
        };
        let pubkey = self.pubkey;
        let pubsub = Arc::clone(&self.pubsub);

        tokio::spawn(async move {
            loop {
                log::debug!(
                    target: LOG_TARGET,
                    "spawn account subscriber: {subscription_name}-{:?}",
                    pubkey
                );
                let (mut account_updates, account_unsubscribe) = match pubsub
                    .account_subscribe(&pubkey, Some(account_config.clone()))
                    .await
                {
                    Ok(res) => res,
                    Err(err) => {
                        log::error!(
                            target: LOG_TARGET,
                            "account subscribe {pubkey} failed: {err:?}"
                        );
                        continue;
                    }
                };
                log::debug!(
                    target: LOG_TARGET,
                    "account subscribed: {subscription_name}-{pubkey:?}"
                );
                let mut latest_slot = 0;
                let res = loop {
                    tokio::select! {
                        biased;
                        message = account_updates.next() => {
                            match message {
                                Some(message) => {
                                    let slot = message.context.slot;
                                    if slot >= latest_slot {
                                        latest_slot = slot;
                                        let data = message.value.data.decode().expect("decoded");
                                        let account_update = AccountUpdate {
                                            owner: Pubkey::from_str(&message.value.owner).unwrap(),
                                            lamports: message.value.lamports,
                                            pubkey,
                                            data,
                                            slot,
                                        };
                                        on_update(&account_update);
                                    }
                                }
                                None => {
                                    log::warn!(target: LOG_TARGET, "{subscription_name}: Ws ended unexpectedly: {pubkey:?}");
                                    break Err(());
                                }
                            }
                        }
                        _ = &mut unsub_rx => {
                            log::debug!(target: LOG_TARGET, "{subscription_name}: Unsubscribing from account stream: {pubkey:?}");
                            account_unsubscribe().await;
                            break Ok(());
                        }
                    }
                };

                if res.is_ok() {
                    break;
                }
            }
        });

        Ok(unsub_tx)
    }
}

```

## File: crates/src/websocket_program_account_subscriber.rs
```
use std::time::Instant;

use anchor_lang::AnchorDeserialize;
use drift_pubsub_client::PubsubClient;
use futures_util::StreamExt;
use log::warn;
use solana_account_decoder_client_types::UiAccountEncoding;
use solana_rpc_client_api::{
    config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},
    filter::RpcFilterType,
};
use solana_sdk::commitment_config::CommitmentConfig;
use tokio::sync::oneshot;

use crate::{constants, types::DataAndSlot, UnsubHandle};

#[derive(Clone, Debug)]
pub struct ProgramAccountUpdate<T: AnchorDeserialize + Send> {
    pub pubkey: String,
    pub data_and_slot: DataAndSlot<T>,
    pub now: Instant,
}

impl<T: AnchorDeserialize + Send> ProgramAccountUpdate<T> {
    pub fn new(pubkey: String, data_and_slot: DataAndSlot<T>, now: Instant) -> Self {
        Self {
            pubkey,
            data_and_slot,
            now,
        }
    }
}

#[derive(Clone)]
pub struct WebsocketProgramAccountOptions {
    pub filters: Vec<RpcFilterType>,
    pub commitment: CommitmentConfig,
    pub encoding: UiAccountEncoding,
}

pub struct WebsocketProgramAccountSubscriber {
    url: String,
    pub options: WebsocketProgramAccountOptions,
}

impl WebsocketProgramAccountSubscriber {
    pub fn new(url: String, options: WebsocketProgramAccountOptions) -> Self {
        WebsocketProgramAccountSubscriber { url, options }
    }

    /// Start a GPA subscription task
    ///
    /// `subscription_name` some user defined identifier for the subscription
    /// `on_update` handles updates from the subscription task
    pub fn subscribe<T, F>(&self, subscription_name: &'static str, on_update: F) -> UnsubHandle
    where
        T: AnchorDeserialize + Clone + Send + 'static,
        F: 'static + Send + Fn(&ProgramAccountUpdate<T>),
    {
        let account_config = RpcAccountInfoConfig {
            commitment: Some(self.options.commitment),
            encoding: Some(self.options.encoding),
            ..Default::default()
        };
        let config = RpcProgramAccountsConfig {
            filters: Some(self.options.filters.clone()),
            account_config,
            ..Default::default()
        };

        let (unsub_tx, mut unsub_rx) = oneshot::channel::<()>();
        let url = self.url.clone();

        tokio::spawn(async move {
            let mut latest_slot = 0;
            loop {
                let pubsub = match PubsubClient::new(&url).await {
                    Ok(pubsub) => pubsub,
                    Err(err) => {
                        log::error!("GPA stream connect failed: {err:?}");
                        continue;
                    }
                };
                let (mut accounts, unsub) = match pubsub
                    .program_subscribe(&constants::PROGRAM_ID, Some(config.clone()))
                    .await
                {
                    Ok(res) => res,
                    Err(err) => {
                        log::error!("GPA stream subscribe failed: {err:?}");
                        continue;
                    }
                };

                let res = loop {
                    tokio::select! {
                        biased;
                        message = accounts.next() => {
                            match message {
                                Some(message) => {
                                    let slot = message.context.slot;
                                    if slot >= latest_slot {
                                        latest_slot = slot;
                                        let pubkey = message.value.pubkey;
                                        let data = &message.value.account.data.decode().expect("account has data");
                                        let data = T::deserialize(&mut &data[8..]).expect("deserializes T");
                                        on_update(&ProgramAccountUpdate::new(pubkey, DataAndSlot::<T> { slot, data }, Instant::now()));
                                    }
                                },
                                None => {
                                    log::warn!("{subscription_name}: Ws GPA stream ended unexpectedly");
                                    break Err(());
                                }
                            }
                        }
                        _ = &mut unsub_rx => {
                            warn!("unsubscribing: {subscription_name}");
                            unsub().await;
                            break Ok(());
                        }
                    }
                };
                if res.is_ok() {
                    break;
                }
            }
        });

        unsub_tx
    }
}

#[cfg(feature = "rpc_tests")]
mod tests {
    use super::*;
    use crate::{
        drift_idl::accounts::User,
        memcmp::{get_non_idle_user_filter, get_user_filter},
        utils::test_envs::mainnet_endpoint,
    };

    #[tokio::test]
    async fn test_subscribe() {
        let filters = vec![get_user_filter(), get_non_idle_user_filter()];
        let commitment = CommitmentConfig::confirmed();
        let options = WebsocketProgramAccountOptions {
            filters,
            commitment,
            encoding: UiAccountEncoding::Base64,
        };
        let subscription_name = "Test";

        let mut ws_subscriber = WebsocketProgramAccountSubscriber::<User>::new(
            subscription_name,
            mainnet_endpoint(),
            options,
            EventEmitter::new(),
        );

        let _ = ws_subscriber.subscribe().await;
        dbg!("sub'd");

        ws_subscriber.event_emitter.clone().subscribe(move |event| {
            dbg!(event);
        });

        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;
        let _ = ws_subscriber.unsubscribe().await;
        dbg!("unsub'd");
    }
}

```

## File: examples/dlob-builder/src/clob.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drift CLOB - Order Book</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #0a0a0a;
            color: #ffffff;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #00ff88;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .view-toggle {
            display: flex;
            background: #1a1a1a;
            border-radius: 6px;
            padding: 4px;
            margin-bottom: 20px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        .view-toggle button {
            flex: 1;
            background: transparent;
            border: none;
            color: #888;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .view-toggle button.active {
            background: #00ff88;
            color: #000;
        }

        .view-toggle button:hover:not(.active) {
            background: #2a2a2a;
            color: #fff;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            color: #888;
            font-size: 14px;
        }

        .control-group input,
        .control-group select {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: inherit;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #00ff88;
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 4px;
            border-left: 4px solid #00ff88;
        }

        .status.error {
            border-left-color: #ff4444;
        }

        .orderbook-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .l2-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .l2-side {
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }

        .l2-header {
            background: #2a2a2a;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
        }

        .l2-asks-header {
            color: #ff4444;
        }

        .l2-bids-header {
            color: #00ff88;
        }

        .l2-table {
            width: 100%;
            border-collapse: collapse;
        }

        .l2-table th {
            background: #333;
            padding: 12px 8px;
            text-align: center;
            font-size: 12px;
            color: #888;
            border-bottom: 1px solid #444;
        }

        .l2-table td {
            padding: 8px;
            text-align: center;
            font-size: 13px;
            border-bottom: 1px solid #222;
            position: relative;
        }

        .l2-table tr:hover {
            background: #2a2a2a;
        }

        .l2-price {
            font-weight: bold;
            font-size: 14px;
        }

        .l2-price.ask {
            color: #ff4444;
        }

        .l2-price.bid {
            color: #00ff88;
        }

        .l2-size {
            color: #ccc;
        }

        .depth-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            opacity: 0.2;
            z-index: 0;
        }

        .depth-bar.ask {
            background: linear-gradient(to right, #ff4444, transparent);
        }

        .depth-bar.bid {
            background: linear-gradient(to right, #00ff88, transparent);
        }

        .l2-table td {
            position: relative;
            z-index: 1;
        }


        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 14px;
            cursor: pointer;
        }

        .control-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }


        .orderbook-side {
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }

        .orderbook-header {
            background: #2a2a2a;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
        }

        .asks-header {
            color: #ff4444;
        }

        .bids-header {
            color: #00ff88;
        }

        .orderbook-table {
            width: 100%;
            border-collapse: collapse;
        }

        .orderbook-table th {
            background: #333;
            padding: 12px 8px;
            text-align: center;
            font-size: 12px;
            color: #888;
            border-bottom: 1px solid #444;
        }

        .orderbook-table td {
            padding: 8px;
            text-align: center;
            font-size: 13px;
            border-bottom: 1px solid #222;
        }

        .orderbook-table tr:hover {
            background: #2a2a2a;
        }

        .orderbook-table tr.clickable {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .orderbook-table tr.clickable:hover {
            background: #2a2a2a;
        }

        .price {
            font-weight: bold;
            font-size: 14px;
        }

        .price.ask {
            color: #ff4444;
        }

        .price.bid {
            color: #00ff88;
        }

        .size {
            color: #ccc;
        }

        .order-id {
            color: #888;
            font-size: 11px;
        }

        .user {
            color: #666;
            font-size: 11px;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .kind {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }

        .kind.Market {
            background: #ff6b6b;
            color: #fff;
        }

        .kind.Limit {
            background: #4ecdc4;
            color: #fff;
        }

        .kind.Oracle {
            background: #45b7d1;
            color: #fff;
        }

        .kind.FloatingLimit {
            background: #96ceb4;
            color: #fff;
        }

        .kind.TriggerMarket {
            background: #feca57;
            color: #000;
        }

        .kind.TriggerLimit {
            background: #ff9ff3;
            color: #000;
        }

        .trigger-order {
            border-left: 3px solid #ff6b35;
            background: rgba(255, 107, 53, 0.1);
        }

        .trigger-order .price {
            color: #ff6b35;
            font-weight: bold;
        }

        .trigger-order .size {
            color: #ff6b35;
        }

        .market-order {
            border-left: 3px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .market-order .price {
            color: #ff6b6b;
            font-weight: bold;
        }

        .market-order .size {
            color: #ff6b6b;
        }

        .oracle-order {
            border-left: 3px solid #45b7d1;
            background: rgba(69, 183, 209, 0.1);
        }

        .oracle-order .price {
            color: #45b7d1;
            font-weight: bold;
        }

        .oracle-order .size {
            color: #45b7d1;
        }

        .floating-limit-order {
            border-left: 3px solid #96ceb4;
            background: rgba(150, 206, 180, 0.1);
        }

        .floating-limit-order .price {
            color: #96ceb4;
            font-weight: bold;
        }

        .floating-limit-order .size {
            color: #96ceb4;
        }

        .reduce-only {
            color: #ff6b6b;
            font-size: 11px;
        }

        .spread {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .spread-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
        }

        .spread-label {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .refresh-btn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease-in-out;
            min-width: 120px;
            text-align: center;
            opacity: 1;
        }

        .refresh-btn:hover {
            background: #00cc6a;
            transform: translateY(-1px);
        }

        .refresh-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        .refresh-btn.loading {
            background: #666;
            color: #999;
            opacity: 0.7;
            filter: grayscale(100%);
        }

        .pause-btn {
            background: #ff6b6b;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease-in-out;
            min-width: 80px;
            text-align: center;
        }

        .pause-btn:hover {
            background: #ff4444;
            transform: translateY(-1px);
        }

        .pause-btn.paused {
            background: #00ff88;
            color: #000;
        }

        .pause-btn.paused:hover {
            background: #00cc6a;
        }

        .pause-btn:active {
            transform: translateY(0);
        }

        @media (max-width: 768px) {
            .orderbook-container {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Drift CLOB</h1>
        <p>Real-time Central Limit Order Book</p>
    </div>

    <div class="view-toggle">
        <button id="l2ViewBtn" class="active">L2 Aggregated</button>
        <button id="l3ViewBtn">L3 Individual</button>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="marketIndex">Market Index:</label>
            <input type="number" id="marketIndex" value="0" min="0" max="100">
        </div>
        <div class="control-group">
            <label for="refreshInterval">Refresh (ms):</label>
            <input type="number" id="refreshInterval" value="1000" min="100" max="10000">
        </div>
        <div class="control-group">
            <label for="maxOrders">Max Orders:</label>
            <input type="number" id="maxOrders" value="20" min="5" max="100">
        </div>
        <div class="control-group" id="priceGroupingGroup" style="display: none;">
            <label for="priceGrouping">Price Grouping:</label>
            <select id="priceGrouping">
                <option value="0.01">0.01</option>
                <option value="0.1" selected>0.1</option>
                <option value="1">1</option>
                <option value="10">10</option>
            </select>
        </div>
        <div class="control-group">
            <button id="refreshBtn" class="refresh-btn">Refresh</button>
        </div>
        <div class="control-group">
            <button id="pauseBtn" class="pause-btn">Pause</button>
        </div>
    </div>

    <div id="status" class="status">
        <div>Loading orderbook data...</div>
    </div>

    <div id="spread" class="spread" style="display: none;">
        <div class="spread-value" id="spreadValue">-</div>
        <div class="spread-label">Spread</div>
    </div>

    <!-- L2 Aggregated View -->
    <div id="l2Container" class="l2-container">
        <div class="l2-side">
            <div class="l2-header l2-asks-header">ASKS (Sell Orders)</div>
            <table class="l2-table">
                <thead>
                    <tr>
                        <th>Price</th>
                        <th>Size</th>
                    </tr>
                </thead>
                <tbody id="l2AsksTable">
                    <tr>
                        <td colspan="2" class="loading">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="l2-side">
            <div class="l2-header l2-bids-header">BIDS (Buy Orders)</div>
            <table class="l2-table">
                <thead>
                    <tr>
                        <th>Price</th>
                        <th>Size</th>
                    </tr>
                </thead>
                <tbody id="l2BidsTable">
                    <tr>
                        <td colspan="2" class="loading">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- L3 Individual Orders View -->
    <div id="l3Container" class="orderbook-container" style="display: none;">
        <div class="orderbook-side">
            <div class="orderbook-header asks-header">ASKS (Sell Orders)</div>
            <table class="orderbook-table">
                <thead>
                    <tr>
                        <th>Price</th>
                        <th>Size</th>
                        <th>Order ID</th>
                        <th>User</th>
                        <th>Kind</th>
                        <th>RO</th>
                    </tr>
                </thead>
                <tbody id="asksTable">
                    <tr>
                        <td colspan="6" class="loading">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="orderbook-side">
            <div class="orderbook-header bids-header">BIDS (Buy Orders)</div>
            <table class="orderbook-table">
                <thead>
                    <tr>
                        <th>Price</th>
                        <th>Size</th>
                        <th>Order ID</th>
                        <th>User</th>
                        <th>Kind</th>
                        <th>RO</th>
                    </tr>
                </thead>
                <tbody id="bidsTable">
                    <tr>
                        <td colspan="6" class="loading">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let refreshInterval = null;
        let isRefreshing = false;
        let isPaused = false;

        const statusEl = document.getElementById('status');
        const spreadEl = document.getElementById('spread');
        const spreadValueEl = document.getElementById('spreadValue');
        const asksTableEl = document.getElementById('asksTable');
        const bidsTableEl = document.getElementById('bidsTable');
        const l2AsksTableEl = document.getElementById('l2AsksTable');
        const l2BidsTableEl = document.getElementById('l2BidsTable');
        const l2ContainerEl = document.getElementById('l2Container');
        const l3ContainerEl = document.getElementById('l3Container');
        const l2ViewBtn = document.getElementById('l2ViewBtn');
        const l3ViewBtn = document.getElementById('l3ViewBtn');
        const marketIndexInput = document.getElementById('marketIndex');
        const refreshIntervalInput = document.getElementById('refreshInterval');
        const maxOrdersInput = document.getElementById('maxOrders');
        const refreshBtn = document.getElementById('refreshBtn');
        const pauseBtn = document.getElementById('pauseBtn');

        let currentView = 'l2';

        function updateStatus(message, isError = false) {
            statusEl.textContent = message;
            statusEl.className = isError ? 'status error' : 'status';
        }

        function formatPrice(price) {
            return (price / 1e6).toFixed(2);
        }

        function formatSize(size) {
            return (size / 1e9).toFixed(2);
        }

        function formatUser(user) {
            return user.substring(0, 8) + '...';
        }

        function getKindClass(kind) {
            return kind.replace(/([A-Z])/g, ' $1').trim();
        }

        function getOrderRowClass(kind) {
            const kindToClass = {
                'TriggerMarket': 'trigger-order',
                'TriggerLimit': 'trigger-order',
                'Market': 'market-order',
                'Limit': 'limit-order',
                'Oracle': 'oracle-order',
                'FloatingLimit': 'floating-limit-order'
            };
            return kindToClass[kind] || '';
        }

        function groupOrdersByPriceLevel(orders, priceGrouping = 0.1) {
            const grouped = new Map();
            
            orders.forEach(order => {
                // Round price to nearest grouping level
                const groupedPrice = Math.round(order.price / (priceGrouping * 1e6)) * (priceGrouping * 1e6);
                
                if (grouped.has(groupedPrice)) {
                    grouped.get(groupedPrice).size += order.size;
                } else {
                    grouped.set(groupedPrice, {
                        price: groupedPrice,
                        size: order.size
                    });
                }
            });
            
            return Array.from(grouped.values());
        }


        function renderL2Orderbook(data) {
            const maxOrders = parseInt(maxOrdersInput.value);
            const priceGrouping = parseFloat(document.getElementById('priceGrouping').value);

            // Clear existing data
            l2AsksTableEl.innerHTML = '';
            l2BidsTableEl.innerHTML = '';

            // Sort asks by price ascending (lowest first)
            const sortedAsks = [...data.asks].sort((a, b) => a.price - b.price);
            const sortedBids = [...data.bids].sort((a, b) => b.price - a.price);

            // Group orders by price level
            const groupedAsks = groupOrdersByPriceLevel(sortedAsks, priceGrouping);
            const groupedBids = groupOrdersByPriceLevel(sortedBids, priceGrouping);

            // Calculate max size for depth visualization
            const allSizes = [...groupedAsks, ...groupedBids].map(level => level.size);
            const maxSize = Math.max(...allSizes);

            // Get orders to show
            const asksToShow = groupedAsks.slice(0, maxOrders);
            const bidsToShow = groupedBids.slice(0, maxOrders);

            // Render asks
            asksToShow.forEach(level => {
                const row = document.createElement('tr');
                const depthPercent = (level.size / maxSize) * 100;

                row.innerHTML = `
                    <td class="l2-price ask">${formatPrice(level.price)}</td>
                    <td class="l2-size">${formatSize(level.size)}</td>
                `;

                // Add depth bar
                const depthBar = document.createElement('div');
                depthBar.className = 'depth-bar ask';
                depthBar.style.width = `${depthPercent}%`;
                row.querySelector('td').appendChild(depthBar);

                l2AsksTableEl.appendChild(row);
            });

            // Render bids
            bidsToShow.forEach(level => {
                const row = document.createElement('tr');
                const depthPercent = (level.size / maxSize) * 100;

                row.innerHTML = `
                    <td class="l2-price bid">${formatPrice(level.price)}</td>
                    <td class="l2-size">${formatSize(level.size)}</td>
                `;

                // Add depth bar
                const depthBar = document.createElement('div');
                depthBar.className = 'depth-bar bid';
                depthBar.style.width = `${depthPercent}%`;
                row.querySelector('td').appendChild(depthBar);

                l2BidsTableEl.appendChild(row);
            });

            // Calculate and display spread
            if (groupedAsks.length > 0 && groupedBids.length > 0) {
                const bestAsk = groupedAsks[0].price;
                const bestBid = groupedBids[0].price;
                const spread = bestAsk - bestBid;
                const spreadPercent = (spread / bestBid) * 100;

                spreadValueEl.textContent = `${formatPrice(spread)} (${spreadPercent.toFixed(2)}%)`;
                spreadEl.style.display = 'block';
            } else {
                spreadEl.style.display = 'none';
            }

            updateStatus(`L2 Orderbook updated - Slot: ${data.slot}, Oracle: ${formatPrice(data.oracle_price)}, Market: ${data.market_index}`);
        }

        function renderL3Orderbook(data) {
            const maxOrders = parseInt(maxOrdersInput.value);

            // Clear existing data
            asksTableEl.innerHTML = '';
            bidsTableEl.innerHTML = '';

            // Sort asks by price ascending (lowest first)
            const sortedAsks = [...data.asks].sort((a, b) => a.price - b.price);
            const sortedBids = [...data.bids].sort((a, b) => b.price - a.price);

            // Render asks
            const asksToShow = sortedAsks.slice(0, maxOrders);
            asksToShow.forEach(order => {
                const row = document.createElement('tr');
                row.className = 'clickable';
                
                // Add order type specific styling
                const orderClass = getOrderRowClass(order.kind);
                if (orderClass) {
                    row.classList.add(orderClass);
                }
                
                row.innerHTML = `
                    <td class="price ask">${formatPrice(order.price)}</td>
                    <td class="size">${formatSize(order.size)}</td>
                    <td class="order-id">${order.order_id}</td>
                    <td class="user" title="${order.user}">${formatUser(order.user)}</td>
                    <td><span class="kind ${getKindClass(order.kind)}">${order.kind}</span></td>
                    <td>${order.reduce_only ? '<span class="reduce-only">RO</span>' : ''}</td>
                `;

                // Add click handler to navigate to Drift app
                row.addEventListener('click', () => {
                    window.open(`https://app.drift.trade?userAccount=${order.user}`, '_blank');
                });

                asksTableEl.appendChild(row);
            });

            // Render bids
            const bidsToShow = sortedBids.slice(0, maxOrders);
            bidsToShow.forEach(order => {
                const row = document.createElement('tr');
                row.className = 'clickable';
                
                // Add order type specific styling
                const orderClass = getOrderRowClass(order.kind);
                if (orderClass) {
                    row.classList.add(orderClass);
                }
                
                row.innerHTML = `
                    <td class="price bid">${formatPrice(order.price)}</td>
                    <td class="size">${formatSize(order.size)}</td>
                    <td class="order-id">${order.order_id}</td>
                    <td class="user" title="${order.user}">${formatUser(order.user)}</td>
                    <td><span class="kind ${getKindClass(order.kind)}">${order.kind}</span></td>
                    <td>${order.reduce_only ? '<span class="reduce-only">RO</span>' : ''}</td>
                `;
                
                // Add click handler to navigate to Drift app
                row.addEventListener('click', () => {
                    window.open(`https://app.drift.trade?userAccount=${order.user}`, '_blank');
                });
                
                bidsTableEl.appendChild(row);
            });

            // Calculate and display spread
            if (sortedAsks.length > 0 && sortedBids.length > 0) {
                const bestAsk = sortedAsks[0].price;
                const bestBid = sortedBids[0].price;
                const spread = bestAsk - bestBid;
                const spreadPercent = (spread / bestBid) * 100;

                spreadValueEl.textContent = `${formatPrice(spread)} (${spreadPercent.toFixed(2)}%)`;
                spreadEl.style.display = 'block';
            } else {
                spreadEl.style.display = 'none';
            }

            updateStatus(`L3 Orderbook updated - Slot: ${data.slot}, Oracle: ${formatPrice(data.oracle_price)}`);
        }

        async function fetchOrderbook() {
            if (isRefreshing) return;

            isRefreshing = true;
            refreshBtn.disabled = true;
            refreshBtn.classList.add('loading');

            try {
                const marketIndex = marketIndexInput.value;
                const endpoint = currentView === 'l2' ? '/l2' : '/l3';
                const response = await fetch(`${endpoint}?market_index=${marketIndex}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (currentView === 'l2') {
                    renderL2Orderbook(data);
                } else {
                    renderL3Orderbook(data);
                }
            } catch (error) {
                console.error('Error fetching orderbook:', error);
                updateStatus(`Error: ${error.message}`, true);
            } finally {
                isRefreshing = false;
                refreshBtn.disabled = false;
                refreshBtn.classList.remove('loading');
            }
        }

        function startAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }

            if (!isPaused) {
                const interval = parseInt(refreshIntervalInput.value);
                refreshInterval = setInterval(fetchOrderbook, interval);
            }
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            
            if (isPaused) {
                pauseBtn.textContent = 'Resume';
                pauseBtn.classList.add('paused');
                stopAutoRefresh();
                updateStatus('Auto-refresh paused');
            } else {
                pauseBtn.textContent = 'Pause';
                pauseBtn.classList.remove('paused');
                startAutoRefresh();
                updateStatus('Auto-refresh resumed');
            }
        }

        function switchView(view) {
            currentView = view;

            if (view === 'l2') {
                l2ViewBtn.classList.add('active');
                l3ViewBtn.classList.remove('active');
                l2ContainerEl.style.display = 'grid';
                l3ContainerEl.style.display = 'none';
                document.getElementById('priceGroupingGroup').style.display = 'flex';
            } else {
                l2ViewBtn.classList.remove('active');
                l3ViewBtn.classList.add('active');
                l2ContainerEl.style.display = 'none';
                l3ContainerEl.style.display = 'grid';
                document.getElementById('priceGroupingGroup').style.display = 'none';
            }

            // Refresh data for the new view
            stopAutoRefresh();
            fetchOrderbook();
            startAutoRefresh();
        }

        // Event listeners
        refreshBtn.addEventListener('click', fetchOrderbook);
        pauseBtn.addEventListener('click', togglePause);

        l2ViewBtn.addEventListener('click', () => switchView('l2'));
        l3ViewBtn.addEventListener('click', () => switchView('l3'));


        document.getElementById('priceGrouping').addEventListener('change', () => {
            if (currentView === 'l2') {
                stopAutoRefresh();
                fetchOrderbook();
                startAutoRefresh();
            }
        });

        marketIndexInput.addEventListener('change', () => {
            stopAutoRefresh();
            fetchOrderbook();
            startAutoRefresh();
        });

        refreshIntervalInput.addEventListener('change', () => {
            stopAutoRefresh();
            startAutoRefresh();
        });

        // Initial load
        fetchOrderbook();
        startAutoRefresh();

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopAutoRefresh);
    </script>
</body>

</html>
```

## File: examples/dlob-builder/src/main.rs
```
//! Example DLOB subscription/builder with web server
use std::sync::Arc;

use axum::{
    extract::{Query, State},
    http::StatusCode,
    response::{Html, Json},
    routing::get,
    Router,
};
use drift_rs::{
    dlob::{builder::DLOBBuilder, DLOB},
    types::{MarketId, MarketType},
    Context, DriftClient, GrpcSubscribeOpts, RpcClient,
};
use serde::{Deserialize, Serialize};
use solana_commitment_config::CommitmentLevel;
use solana_keypair::Keypair;
use tower::ServiceBuilder;
use tower_http::cors::CorsLayer;

#[derive(Serialize, Deserialize)]
struct OrderbookLevel {
    price: u64,
    size: u64,
}

#[derive(Serialize, Deserialize)]
struct L2Response {
    slot: u64,
    oracle_price: u64,
    asks: Vec<OrderbookLevel>,
    bids: Vec<OrderbookLevel>,
    market_index: u16,
}

#[derive(Deserialize)]
struct L2Query {
    market_index: u16,
}

#[derive(Serialize, Deserialize)]
struct L3OrderResponse {
    price: u64,
    size: u64,
    max_ts: u64,
    order_id: u32,
    reduce_only: bool,
    kind: String,
    user: String,
}

#[derive(Serialize, Deserialize)]
struct L3Response {
    slot: u64,
    oracle_price: u64,
    bids: Vec<L3OrderResponse>,
    asks: Vec<L3OrderResponse>,
    market_index: u16,
}

#[derive(Deserialize)]
struct L3Query {
    market_index: u16,
    #[serde(default)]
    max_orders: Option<usize>,
}

async fn get_l2_orderbook(
    Query(params): Query<L2Query>,
    State(state): State<Arc<AppState>>,
) -> Result<Json<L2Response>, StatusCode> {
    let l2_book = state
        .dlob
        .get_l2_snapshot(params.market_index, MarketType::Perp);

    // Convert BTreeMap to Vec<OrderbookLevel> for JSON serialization
    let asks: Vec<OrderbookLevel> = l2_book
        .asks
        .iter()
        .map(|(price, size)| OrderbookLevel {
            price: *price,
            size: *size,
        })
        .collect();

    let bids: Vec<OrderbookLevel> = l2_book
        .bids
        .iter()
        .map(|(price, size)| OrderbookLevel {
            price: *price,
            size: *size,
        })
        .collect();

    Ok(Json(L2Response {
        slot: l2_book.slot,
        oracle_price: l2_book.oracle_price,
        asks,
        bids,
        market_index: params.market_index,
    }))
}

async fn get_l3_orderbook(
    Query(params): Query<L3Query>,
    State(state): State<Arc<AppState>>,
) -> Result<Json<L3Response>, StatusCode> {
    // Get the L3 snapshot from the DLOB
    let oracle_price = state
        .drift
        .try_get_oracle_price_data_and_slot(MarketId::perp(params.market_index))
        .unwrap()
        .data
        .price as u64;

    let l3_book = state
        .dlob
        .get_l3_snapshot(params.market_index, MarketType::Perp);

    // Convert L3Order to L3OrderResponse for JSON serialization
    let convert_order = |order: &drift_rs::dlob::L3Order| L3OrderResponse {
        price: order.price,
        size: order.size,
        max_ts: order.max_ts,
        order_id: order.order_id,
        reduce_only: order.is_reduce_only(),
        kind: format!("{:?}", order.kind),
        user: order.user.to_string(),
    };

    let perp_market = state
        .drift
        .try_get_perp_market_account(params.market_index)
        .unwrap();
    let max_orders = params.max_orders.unwrap_or(usize::MAX);
    let bids: Vec<L3OrderResponse> = l3_book
        .top_bids(max_orders, Some(oracle_price), Some(&perp_market))
        .map(convert_order)
        .collect();
    let asks: Vec<L3OrderResponse> = l3_book
        .top_asks(max_orders, Some(oracle_price), Some(&perp_market))
        .map(convert_order)
        .collect();

    Ok(Json(L3Response {
        slot: l3_book.slot,
        oracle_price,
        bids,
        asks,
        market_index: params.market_index,
    }))
}

async fn clob_ui() -> Html<&'static str> {
    Html(include_str!("clob.html"))
}

struct AppState {
    drift: DriftClient,
    dlob: &'static DLOB,
}

#[tokio::main]
async fn main() {
    let _ = dotenv::dotenv();
    env_logger::init();

    let rpc_url = std::env::var("RPC_URL")
        .unwrap_or_else(|_| "https://api.mainnet-beta.solana.com".to_string());
    let drift = DriftClient::new(
        Context::MainNet,
        RpcClient::new(rpc_url),
        Keypair::new().into(),
    )
    .await
    .expect("initialized client");

    let account_map = drift.backend().account_map();
    println!("syncing initial User accounts/orders");
    account_map
        .sync_user_accounts(vec![drift_rs::memcmp::get_user_with_order_filter()])
        .await
        .expect("synced user accounts");

    let dlob_builder = DLOBBuilder::new(account_map);

    println!("starting gRPC subscription to live order changes");
    let grpc_url = std::env::var("GRPC_URL").expect("GRPC_URL set");
    let grpc_x_token = std::env::var("GRPC_X_TOKEN").expect("GRPC_X_TOKEN set");

    // let all_perp_markets = drift.get_all_perp_market_ids();
    let perp_markets = vec![
        MarketId::perp(0),
        MarketId::perp(1),
        MarketId::perp(2),
        MarketId::perp(59),
        MarketId::perp(79),
    ];

    let res = drift
        .grpc_subscribe(
            grpc_url,
            grpc_x_token,
            GrpcSubscribeOpts::default()
                .commitment(CommitmentLevel::Confirmed)
                .usermap_on()
                .on_user_account(dlob_builder.account_update_handler(account_map))
                .on_slot(dlob_builder.slot_update_handler(drift.clone(), perp_markets)),
            true,
        )
        .await;

    if let Err(err) = res {
        eprintln!("{err}");
        std::process::exit(1);
    }

    let dlob = dlob_builder.dlob();
    dlob.enable_l2_snapshot(); // disabled by default
    let state = Arc::new(AppState { dlob, drift });

    // Build the web server
    let app = Router::new()
        .route("/", get(clob_ui))
        .route("/l2", get(get_l2_orderbook))
        .route("/l3", get(get_l3_orderbook))
        .layer(ServiceBuilder::new().layer(CorsLayer::permissive()))
        .with_state(state);

    println!("Starting web server on http://localhost:8080");
    println!("CLOB UI: http://localhost:8080/");
    println!("L2 API: curl 'http://localhost:8080/l2?market_index=0'");
    println!("L3 API: curl 'http://localhost:8080/l3?market_index=0'");

    // Start the web server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

```

## File: examples/dlob-matching/src/main.rs
```
//! Example demonstrating DLOB L3 methods and the importance of oracle price
//!
//! This example demonstrates how to use the 4 main L3 order retrieval methods:
//! - get_taker_bids_l3
//! - get_maker_bids_l3
//! - get_taker_asks_l3
//! - get_maker_asks_l3
//!
//! **Key Concept: Oracle Price Importance**
//!
//! The oracle price is essential for rendering DLOB orders because:
//! 1. Floating limit orders have prices defined as offsets from the oracle price
//! 2. Oracle orders dynamically adjust based on the current oracle price
//! 3. Trigger orders evaluate whether they should trigger based on oracle price
//!
//! Example:
//! - A floating limit order with oracle_offset = -100 will be priced at (oracle_price - 100)
//! - If the oracle is $50,000, the order appears at $49,900
//! - If you provide the wrong oracle price (e.g., $51,000), the order will appear at $50,900 (wrong!)

use drift_rs::{
    dlob::builder::DLOBBuilder,
    types::{MarketId, MarketType},
    Context, DriftClient, GrpcSubscribeOpts, RpcClient,
};
use solana_commitment_config::CommitmentLevel;
use solana_keypair::Keypair;

#[tokio::main]
async fn main() {
    let _ = dotenv::dotenv();
    let _ = env_logger::init();

    // Initialize drift client
    let rpc_url = std::env::var("RPC_URL")
        .unwrap_or_else(|_| "https://api.mainnet-beta.solana.com".to_string());
    let drift = DriftClient::new(
        Context::MainNet,
        RpcClient::new(rpc_url),
        Keypair::new().into(),
    )
    .await
    .expect("initialized client");

    // Sync initial user accounts to populate DLOB
    let account_map = drift.backend().account_map();
    account_map
        .sync_user_accounts(vec![drift_rs::memcmp::get_user_with_order_filter()])
        .await
        .expect("synced user accounts");

    // Build DLOB with initial state
    let dlob_builder = DLOBBuilder::new(account_map);
    let dlob = dlob_builder.dlob();

    // Start gRPC subscription for live updates
    let grpc_url = std::env::var("GRPC_URL").expect("GRPC_URL must be set in .env");
    let grpc_x_token = std::env::var("GRPC_X_TOKEN").expect("GRPC_X_TOKEN must be set in .env");

    let grpc_handle = tokio::spawn(async move {
        drift
            .grpc_subscribe(
                grpc_url,
                grpc_x_token,
                GrpcSubscribeOpts::default()
                    .commitment(CommitmentLevel::Processed)
                    .usermap_on()
                    .on_user_account(dlob_builder.account_update_handler(account_map))
                    .on_slot(dlob_builder.slot_update_handler()),
                true,
            )
            .await
    });

    // Wait for initial sync
    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;

    // Fetch fresh oracle price - critical for accurate order pricing
    // Fresh oracle prices are essential because:
    // - Floating limit orders price = oracle_price + offset
    // - Oracle orders dynamically adjust with oracle price
    // - Trigger orders evaluate based on oracle price
    // Without fresh prices, you'll see stale/incorrect order prices and miss opportunities
    let market_index = 0u16;
    let market_type = MarketType::Perp;
    
    // this is the most update to date oracle price from gRPC
    // however more advanced setups may query from pyth price feeds directly
    let oracle_data = drift
        .try_get_oracle_price_data_and_slot(MarketId::perp(market_index))
        .expect("oracle data exists");
    let oracle_price = oracle_data.data.price as u64;

    println!("Oracle Price: ${}.{:08}", oracle_price / 100_000_000, oracle_price % 100_000_000);
    println!("Slot: {}", oracle_data.slot);
    println!();

    let perp_market = drift
        .backend()
        .perp_market(market_index)
        .map(|m| m.clone());
    // this is typically the oracle_price but can also be a median price based on funding
    let trigger_price = oracle_price;

    // Demonstrate the 4 L3 methods
    
    // 1. Maker bids - resting limit buy orders
    let maker_bids = dlob.get_maker_bids_l3(market_index, market_type, oracle_price);
    println!("Maker Bids (top 5):");
    for (i, order) in maker_bids.iter().take(5).enumerate() {
        let price_usd = (order.price as f64) / 100_000_000.0;
        println!(
            "  {}. ${:.2} @ {} (user: {}, kind: {:?})",
            i + 1, price_usd, order.size, &order.user.to_string()[..8], order.kind
        );
    }

    // 2. Maker asks - resting limit sell orders
    let maker_asks = dlob.get_maker_asks_l3(market_index, market_type, oracle_price);
    println!("\nMaker Asks (top 5):");
    for (i, order) in maker_asks.iter().take(5).enumerate() {
        let price_usd = (order.price as f64) / 100_000_000.0;
        println!(
            "  {}. ${:.2} @ {} (user: {}, kind: {:?})",
            i + 1, price_usd, order.size, &order.user.to_string()[..8], order.kind
        );
    }

    // 3. Taker bids - aggressive market buy orders
    let taker_bids = dlob.get_taker_bids_l3(
        market_index,
        market_type,
        oracle_price,
        trigger_price,
        perp_market.as_ref(),
    );
    println!("\nTaker Bids (top 5):");
    for (i, order) in taker_bids.iter().take(5).enumerate() {
        let price_usd = (order.price as f64) / 100_000_000.0;
        println!(
            "  {}. ${:.2} @ {} (user: {}, kind: {:?})",
            i + 1, price_usd, order.size, &order.user.to_string()[..8], order.kind
        );
    }

    // 4. Taker asks - aggressive market sell orders
    let taker_asks = dlob.get_taker_asks_l3(
        market_index,
        market_type,
        oracle_price,
        trigger_price,
        perp_market.as_ref(),
    );
    println!("\nTaker Asks (top 5):");
    for (i, order) in taker_asks.iter().take(5).enumerate() {
        let price_usd = (order.price as f64) / 100_000_000.0;
        println!(
            "  {}. ${:.2} @ {} (user: {}, kind: {:?})",
            i + 1, price_usd, order.size, &order.user.to_string()[..8], order.kind
        );
    }

    println!("\nTotal: {} maker bids, {} maker asks, {} taker bids, {} taker asks",
        maker_bids.len(), maker_asks.len(), taker_bids.len(), taker_asks.len());

    println!("\nKeeping gRPC subscription running. Press Ctrl+C to exit...");
    let _ = grpc_handle.await;
}

```

## File: examples/drift-client-callbacks/src/main.rs
```
use anchor_lang::AccountDeserialize;
use clap::Parser;
use dotenv;
use drift_rs::math::constants::BASE_PRECISION_I128;
use drift_rs::types::{accounts::PerpMarket, AccountUpdate, Context};
use drift_rs::{DriftClient, RpcClient, Wallet};
use env_logger;
use futures_util::future::FutureExt;
use rust_decimal::Decimal;
use std::env;
use std::time::{Duration, Instant};
use tokio::time::timeout;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(
        long,
        default_value = "https://api.mainnet-beta.solana.com",
        help = "RPC endpoint URL (auto-converts to WebSocket for subscriptions)"
    )]
    rpc_url: String,

    #[clap(long, action, help = "Use devnet instead of mainnet")]
    devnet: bool,

    #[clap(long, default_value = "30", help = "Duration to run in seconds")]
    duration: u64,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _ = env_logger::init();
    let _ = dotenv::dotenv().ok();
    let args = Args::parse();

    println!("🚀 Drift Market Update Monitor");
    println!("===============================\n");

    // Allow RPC_URL override from environment
    let rpc_url = env::var("RPC_URL").unwrap_or(args.rpc_url);
    let context = if args.devnet {
        Context::DevNet
    } else {
        Context::MainNet
    };

    println!("📡 Connecting to {} ({})", rpc_url, context.name());

    // Create RPC client and wallet (dummy wallet for read-only operations)
    let rpc_client = RpcClient::new(rpc_url);
    // Create a read-only wallet for client creation (we don't need signing for subscriptions)
    let dummy_wallet = Wallet::read_only(solana_sdk::pubkey!("11111111111111111111111111111111")); // System program as dummy

    // Initialize Drift client
    let client = DriftClient::new(context, rpc_client, dummy_wallet).await?;
    println!("✅ Connected to Drift protocol\n");

    monitor_markets(&client, args.duration).await?;

    println!("\n✅ Market monitoring complete!");

    Ok(())
}

/// Deserialize PerpMarket from account data
fn deserialize_perp_market(data: &[u8]) -> Result<PerpMarket, Box<dyn std::error::Error>> {
    let market = PerpMarket::try_deserialize(&mut &data[..])?;
    Ok(market)
}

/// Monitor markets and print market_index and base_asset_amount_with_amm
async fn monitor_markets(
    client: &DriftClient,
    duration_secs: u64,
) -> Result<(), Box<dyn std::error::Error>> {
    // Get available markets
    let perp_markets = client.get_all_perp_market_ids();

    println!("📈 Available markets:");
    println!("  • Perp markets: {} active", perp_markets.len());

    let start_time = Instant::now();

    let market_callback = move |update: &AccountUpdate| {
        // Deserialize market data
        match deserialize_perp_market(&update.data) {
            Ok(market) => {
                let elapsed = start_time.elapsed().as_secs();
                println!(
                    "[{}s] Market {}: base_asset_amount_with_amm = {}",
                    elapsed,
                    market.market_index,
                    (market.amm.base_asset_amount_with_amm.as_i128() * -1) as f64
                        / BASE_PRECISION_I128 as f64
                );
            }
            Err(e) => {
                eprintln!("Failed to deserialize market: {}", e);
            }
        }
    };

    // Subscribe to markets
    client
        .subscribe_markets_with_callback(&perp_markets, market_callback)
        .await?;

    // client.subscribe_all_oracles_with_callback(on_account)

    println!(
        "⏰ Running for {} seconds... (Press Ctrl+C to stop early)\n",
        duration_secs
    );

    // Run for specified duration
    match timeout(
        Duration::from_secs(duration_secs),
        tokio::signal::ctrl_c().fuse(),
    )
    .await
    {
        Ok(_) => println!("\n🛑 Interrupted by user"),
        Err(_) => println!("\n⏰ Time limit reached"),
    }

    // Unsubscribe (cleanup)
    client.unsubscribe().await?;
    println!("\n✅ Unsubscribed from all market data");

    Ok(())
}

```

## File: examples/event-subscriber/src/main.rs
```
use clap::Parser;
use dotenv;
use drift_rs::event_subscriber::{DriftEvent, EventSubscriber};
use drift_rs::{PubsubClient, constants::PROGRAM_ID};
use env_logger;
use futures_util::StreamExt;
use std::env;
use std::sync::Arc;
use tokio;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(long, action, help = "Use gRPC for event subscription")]
    grpc: bool,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _ = env_logger::init();
    let _ = dotenv::dotenv().ok();
    let args = Args::parse();

    let mut event_subscriber = if args.grpc {
        let grpc_endpoint = env::var("GRPC_ENDPOINT").expect("GRPC_ENDPOINT must be set");
        let grpc_x_token = env::var("GRPC_X_TOKEN").expect("GRPC_X_TOKEN must be set");
        EventSubscriber::subscribe_grpc(grpc_endpoint, grpc_x_token, PROGRAM_ID)
            .await
            .expect("error subscribing to grpc events")
    } else {
        let ws_rpc_endpoint = env::var("WS_RPC_ENDPOINT").expect("WS_RPC_ENDPOINT must be set");
        let client = PubsubClient::new(&ws_rpc_endpoint).await.unwrap();
        EventSubscriber::subscribe(Arc::new(client), PROGRAM_ID)
            .await
            .expect("error subscribing to ws events")
    };

    println!("subscribed to events");
    let mut count = 0;
    while let Some(event) = event_subscriber.next().await {
        match event {
            DriftEvent::OrderFill {
                maker,
                // maker_fee,
                maker_order_id,
                maker_side,
                taker,
                // taker_fee,
                taker_order_id,
                taker_side,
                // base_asset_amount_filled,
                // quote_asset_amount_filled,
                market_index,
                market_type,
                // oracle_price,
                signature,
                // tx_idx,
                // ts,
                bit_flags,
                ..
            } => {
                println!(
                    "order fill: market: {}-{} maker: {}-{}-{} taker: {}-{}-{} signature: {} bit_flags: {}",
                    market_type.as_str(),
                    market_index,
                    maker.unwrap_or_default().to_string().as_str(),
                    maker_order_id,
                    format!("{:?}", maker_side.unwrap_or_default()),
                    taker.unwrap_or_default().to_string().as_str(),
                    taker_order_id,
                    format!("{:?}", taker_side.unwrap_or_default()),
                    signature,
                    bit_flags
                );
                count += 1;
                if count > 100 {
                    break;
                }
            }
            _ => {}
        }
    }

    event_subscriber.unsubscribe();
    Ok(())
}

```

## File: examples/market-maker/src/grpc_marker.rs
```
//! Example Market Making bot with gRPC/geyser based subscriptions
//!
//! Resubmits quotes on a fixed interval
use std::time::Duration;

use drift_rs::{
    event_subscriber::{DriftEvent, EventSubscriber},
    math::constants::{BASE_PRECISION_U64, PRICE_PRECISION_U64},
    types::{
        accounts::{PerpMarket, User},
        MarketPrecision, MarketType, OrderParams, OrderType, PositionDirection, PostOnlyParam,
    },
    Context, DriftClient, GrpcSubscribeOpts, Pubkey, RpcClient, TransactionBuilder, Wallet,
};
use futures_util::StreamExt;
use solana_commitment_config::CommitmentLevel;
use solana_keypair::Keypair;

pub async fn grpc_marker(context: Context, wallet: Wallet) {
    let rpc_url = std::env::var("RPC_URL")
        .unwrap_or_else(|_| "https://api.mainnet-beta.solana.com".to_string());
    let drift = DriftClient::new(context, RpcClient::new(rpc_url), Keypair::new().into())
        .await
        .expect("initialized client");
    let _ = drift.subscribe_blockhashes().await; // subscribe blockhases for fast tx building

    let market_id = drift.market_lookup("sol-perp").unwrap();
    let market_info = drift
        .try_get_perp_market_account(market_id.index())
        .unwrap();

    let grpc_url = std::env::var("GRPC_URL").expect("GRPC_URL set");
    let grpc_x_token = std::env::var("GRPC_X_TOKEN").expect("GRPC_X_TOKEN set");

    // gRPC subscribes to all oracle,market,and user account updates
    if let Err(err) = drift
        .grpc_subscribe(
            grpc_url.clone(),
            grpc_x_token.clone(),
            GrpcSubscribeOpts::default()
                .commitment(CommitmentLevel::Processed)
                .usermap_on(),
            true,
        )
        .await
    {
        eprintln!("grpc subscribe failed: {err:?}");
        return;
    }

    let sub_account_address = drift.wallet().sub_account(0); // trade on the default sub-account index

    let mut account_events =
        EventSubscriber::subscribe_grpc(grpc_url, grpc_x_token, sub_account_address)
            .await
            .unwrap();

    loop {
        let mut requote_interval = tokio::time::interval(Duration::from_millis(400));
        tokio::select! {
            biased;
            _ = requote_interval.tick() => {
                let sub_account_data: User = drift.try_get_account(&sub_account_address).unwrap();
                let oracle_account = drift.try_get_oracle_price_data_and_slot(market_id).unwrap();

                if let Ok(position) = sub_account_data.get_perp_position(market_info.market_index) {
                    let upnl = position.get_unrealized_pnl(oracle_account.data.price).unwrap();
                    println!("current position value: ${}, upnl: ${upnl}", position.quote_asset_amount);
                }

                let quote_price = 123 * PRICE_PRECISION_U64; // $123.000_000
                let quote_size = 5_u64 * BASE_PRECISION_U64; // 5.000_000_000

                place_txs(
                    &drift,
                    &market_info,
                    sub_account_address,
                    &sub_account_data,
                    vec![
                        // fixed price limit order
                        OrderParams {
                            order_type: OrderType::Limit,
                            price: standardize_amount(quote_price, market_info.price_tick()),
                            base_asset_amount: standardize_amount(quote_size, market_info.quantity_tick()).max(market_info.min_order_size()),
                            direction: PositionDirection::Long,
                            market_type: MarketType::Perp,
                            market_index: market_info.market_index,
                            post_only: PostOnlyParam::MustPostOnly,
                            reduce_only: false,
                            user_order_id: 1, // self-assigned order ID from 0-255
                            ..Default::default()
                        },
                        // floating limit order, priced dynamically as offset from oracle price
                        OrderParams {
                            order_type: OrderType::Limit,
                            oracle_price_offset: Some((1 * PRICE_PRECISION_U64) as i32), // short 1$ above oracle
                            base_asset_amount: standardize_amount(quote_size, market_info.quantity_tick()).max(market_info.min_order_size()),
                            direction: PositionDirection::Short,
                            market_type: MarketType::Perp,
                            market_index: market_info.market_index,
                            post_only: PostOnlyParam::MustPostOnly,
                            reduce_only: false,
                            // max_ts: Some(unix_s) // auto-expire by timestamp. default: expire at now + 30s
                            ..Default::default()
                        }
                    ],
                ).await;
            },
            event = account_events.next() => {
                if event.is_none() {
                    eprintln!("event stream finished");
                    break;
                }
                match event.unwrap() {
                    DriftEvent::OrderFill {
                        maker,
                        maker_fee,
                        maker_order_id,
                        maker_side,
                        taker,
                        taker_fee,
                        taker_order_id,
                        taker_side,
                        base_asset_amount_filled,
                        quote_asset_amount_filled,
                        market_index,
                        market_type,
                        oracle_price,
                        signature,
                        tx_idx,
                        ts,
                        bit_flags,
                    } => {
                        println!("order filled. id:{maker_order_id},market={market_index}/{market_type:?},fill_size={quote_asset_amount_filled}");
                    }
                    DriftEvent::OrderCancel { maker_order_id, .. } => {
                        println!("order cancelled. id:{maker_order_id}");
                    }
                    DriftEvent::OrderCreate {
                        order,
                        user,
                        ts,
                        signature,
                        tx_idx,
                    } => {
                        println!("order created. id:{},tx:{signature}", order.order_id);
                    }
                    DriftEvent::FundingPayment {
                        amount,
                        market_index,
                        user,
                        ts,
                        signature,
                        tx_idx,
                    } => {
                        println!("funding paid. market={market_index},amount={amount}");
                    }
                    _other => {}
                }
            }
        }
    }
}

/// quantize `amount` to `tick_size` rounding down
fn standardize_amount(amount: u64, tick_size: u64) -> u64 {
    amount.saturating_sub(amount % tick_size)
}

async fn place_txs(
    drift: &DriftClient,
    market: &PerpMarket,
    sub_account: Pubkey,
    sub_account_data: &User,
    orders: Vec<OrderParams>,
) {
    let builder = TransactionBuilder::new(
        drift.program_data(),
        sub_account,
        std::borrow::Cow::Borrowed(sub_account_data),
        false,
    );
    let tx = builder
        .with_priority_fee(1_000, Some(100_000))
        .cancel_orders((market.market_index, MarketType::Perp), None) // cancel all orders by market
        // .cancel_orders_by_user_id(user_order_ids) // cancel orders by list of userids
        // .cancel_orders_by_id(user_ids) // cancel orders by program assigned order id
        .place_orders(orders) // place new orders
        .build();

    match drift.sign_and_send(tx).await {
        Ok(sig) => {
            println!("sent tx: {sig:?}");
        }
        Err(err) => {
            println!("send tx err: {err:?}");
        }
    }
}

```

## File: examples/market-maker/src/main.rs
```
use drift_rs::{Context, Wallet};

mod grpc_marker;
mod ws_maker;

/// Market maker example
#[derive(argh::FromArgs)]
struct Args {
    /// run gRPC example
    #[argh(switch)]
    grpc: bool,
}

#[tokio::main]
async fn main() {
    let _ = dotenv::dotenv();
    let args: Args = argh::from_env();

    let wallet: Wallet = (drift_rs::utils::load_keypair_multi_format(
        &std::env::var("PRIVATE_KEY").expect("base58 PRIVATE_KEY set"),
    )
    .unwrap())
    .into();

    let context = if std::env::var("MAINNET").is_ok() {
        Context::MainNet
    } else {
        Context::DevNet
    };

    if args.grpc {
        println!("running gRPC maker example");
        grpc_marker::grpc_marker(context, wallet).await;
    } else {
        println!("running Ws maker example");
        ws_maker::ws_maker(context, wallet).await;
    }
}

```

## File: examples/market-maker/src/ws_maker.rs
```
//! Example Market Making bot with Ws based subscriptions
//!
//! Resubmits quotes on a fixed interval
use std::time::Duration;

use drift_rs::{
    event_subscriber::{DriftEvent, EventSubscriber},
    math::constants::{BASE_PRECISION_U64, PRICE_PRECISION_U64},
    types::{
        accounts::{PerpMarket, User},
        MarketPrecision, MarketType, OrderParams, OrderType, PositionDirection, PostOnlyParam,
    },
    Context, DriftClient, Pubkey, RpcClient, TransactionBuilder, Wallet,
};
use futures_util::StreamExt;
use solana_keypair::Keypair;

pub async fn ws_maker(context: Context, wallet: Wallet) {
    let rpc_url = std::env::var("RPC_URL")
        .unwrap_or_else(|_| "https://api.mainnet-beta.solana.com".to_string());
    let drift = DriftClient::new(context, RpcClient::new(rpc_url), Keypair::new().into())
        .await
        .expect("initialized client");
    let _ = drift.subscribe_blockhashes().await; // subscribe blockhases for fast tx building

    let market_id = drift.market_lookup("sol-perp").unwrap();
    let market_info = drift
        .try_get_perp_market_account(market_id.index())
        .unwrap();

    let sub_account_address = drift.wallet().sub_account(0); // trade on the default sub-account index
    let _ = drift
        .subscribe_account(&sub_account_address)
        .await
        .expect("subscribed account");
    let _ = drift
        .subscribe_oracles(&[market_id])
        .await
        .expect("subscribed oracle");

    let mut account_events = EventSubscriber::subscribe(drift.ws(), sub_account_address)
        .await
        .unwrap();

    loop {
        let mut requote_interval = tokio::time::interval(Duration::from_millis(400));
        tokio::select! {
            biased;
            _ = requote_interval.tick() => {
                let sub_account_data: User = drift.try_get_account(&sub_account_address).expect("has account");
                let oracle_account = drift.try_get_oracle_price_data_and_slot(market_id).expect("has oracle");

                if let Ok(position) = sub_account_data.get_perp_position(market_info.market_index) {
                    let upnl = position.get_unrealized_pnl(oracle_account.data.price).unwrap();
                    println!("current position value: ${}, upnl: ${upnl}", position.quote_asset_amount);
                }

                let quote_price = 123 * PRICE_PRECISION_U64; // $123.000_000
                let quote_size = 5_u64 * BASE_PRECISION_U64; // 5.000_000_000

                place_txs(
                    &drift,
                    &market_info,
                    sub_account_address,
                    &sub_account_data,
                    vec![
                        // fixed price limit order
                        OrderParams {
                            order_type: OrderType::Limit,
                            price: standardize_amount(quote_price, market_info.price_tick()),
                            base_asset_amount: standardize_amount(quote_size, market_info.quantity_tick()).max(market_info.min_order_size()),
                            direction: PositionDirection::Long,
                            market_type: MarketType::Perp,
                            market_index: market_info.market_index,
                            post_only: PostOnlyParam::MustPostOnly,
                            reduce_only: false,
                            user_order_id: 1, // self-assigned order ID from 0-255
                            ..Default::default()
                        },
                        // floating limit order, priced dynamically as offset from oracle price
                        OrderParams {
                            order_type: OrderType::Limit,
                            oracle_price_offset: Some((1 * PRICE_PRECISION_U64) as i32), // short 1$ above oracle
                            base_asset_amount: standardize_amount(quote_size, market_info.quantity_tick()).max(market_info.min_order_size()),
                            direction: PositionDirection::Short,
                            market_type: MarketType::Perp,
                            market_index: market_info.market_index,
                            post_only: PostOnlyParam::MustPostOnly,
                            reduce_only: false,
                            // max_ts: Some(unix_s) // auto-expire by timestamp. default: expire at now + 30s
                            ..Default::default()
                        }
                    ],
                ).await;
            },
            event = account_events.next() => {
                if event.is_none() {
                    eprintln!("event stream finished");
                    break;
                }
                match event.unwrap() {
                    DriftEvent::OrderFill {
                        maker,
                        maker_fee,
                        maker_order_id,
                        maker_side,
                        taker,
                        taker_fee,
                        taker_order_id,
                        taker_side,
                        base_asset_amount_filled,
                        quote_asset_amount_filled,
                        market_index,
                        market_type,
                        oracle_price,
                        signature,
                        tx_idx,
                        ts,
                        bit_flags,
                    } => {
                        println!("order filled. id:{maker_order_id},market={market_index}/{market_type:?},fill_size={quote_asset_amount_filled}");
                    }
                    DriftEvent::OrderCancel { maker_order_id, .. } => {
                        println!("order cancelled. id:{maker_order_id}");
                    }
                    DriftEvent::OrderCreate {
                        order,
                        user,
                        ts,
                        signature,
                        tx_idx,
                    } => {
                        println!("order created. id:{},tx:{signature}", order.order_id);
                    }
                    DriftEvent::FundingPayment {
                        amount,
                        market_index,
                        user,
                        ts,
                        signature,
                        tx_idx,
                    } => {
                        println!("funding paid. market={market_index},amount={amount}");
                    }
                    _other => {}
                }
            }
        }
    }
}

/// quantize `amount` to `tick_size` rounding down
fn standardize_amount(amount: u64, tick_size: u64) -> u64 {
    amount.saturating_sub(amount % tick_size)
}

async fn place_txs(
    drift: &DriftClient,
    market: &PerpMarket,
    sub_account: Pubkey,
    sub_account_data: &User,
    orders: Vec<OrderParams>,
) {
    let builder = TransactionBuilder::new(
        drift.program_data(),
        sub_account,
        std::borrow::Cow::Borrowed(sub_account_data),
        false,
    );
    let tx = builder
        .with_priority_fee(1_000, Some(100_000))
        .cancel_orders((market.market_index, MarketType::Perp), None) // cancel all orders by market
        // .cancel_orders_by_user_id(user_order_ids) // cancel orders by list of userids
        // .cancel_orders_by_id(user_ids) // cancel orders by program assigned order id
        .place_orders(orders) // place new orders
        .build();

    match drift.sign_and_send(tx).await {
        Ok(sig) => {
            println!("sent tx: {sig:?}");
        }
        Err(err) => {
            println!("send tx err: {err:?}");
        }
    }
}

```

## File: examples/place-and-take/src/main.rs
```
use anchor_lang::AccountDeserialize;
use drift_rs::{
    Context, DriftClient, RpcClient, TransactionBuilder, Wallet,
    types::{MarketType, OrderParams, OrderType, PositionDirection, PostOnlyParam, accounts::User},
};
use serde::Deserialize;
use solana_pubkey::Pubkey;
use std::str::FromStr;

#[derive(Debug, Deserialize)]
struct TopMakerResponse {
    #[serde(rename = "userAccountPubKey")]
    user_account_pubkey: String,
    #[serde(rename = "accountBase64")]
    account_base64: String,
}

async fn get_top_makers(
    context: Context,
    market_index: u16,
    market_type: MarketType,
    side: &str,
    limit: Option<usize>,
) -> Result<Vec<(Pubkey, User)>, Box<dyn std::error::Error>> {
    let dlob_server_url = if context == Context::MainNet {
        "https://dlob.drift.trade"
    } else {
        "https://master.dlob.drift.trade"
    };
    // NOTE: This parameter controls the number of top makers that will be returned.
    // It is suggested not to use more than 4, in our current testing the size of the transaction will larger than the current limits if you pass more than 4 makers in.
    let limit = limit.unwrap_or(4);

    let query_params = format!(
        "marketIndex={}&marketType={}&side={}&limit={}&includeAccounts=true",
        market_index,
        market_type.as_str(),
        side,
        limit
    );

    let url = format!("{dlob_server_url}/topMakers?{query_params}");
    println!("{url}");

    let response = reqwest::get(&url).await?;

    if !response.status().is_success() {
        return Err(format!("Failed to fetch top makers: HTTP {}", response.status()).into());
    }

    let makers: Vec<TopMakerResponse> = response.json().await?;

    if makers.is_empty() {
        return Ok(Vec::new());
    }

    let mut maker_infos = Vec::new();

    for maker in makers {
        // Decode the user account from base64
        let account_bytes = base64::Engine::decode(
            &base64::engine::general_purpose::STANDARD,
            &maker.account_base64,
        )?;
        let user_account = User::try_deserialize(&mut account_bytes.as_slice())
            .expect("User deserializes");
        let maker_pubkey = Pubkey::from_str(&maker.user_account_pubkey)?;

        maker_infos.push((maker_pubkey, user_account));
    }

    Ok(maker_infos)
}

#[tokio::main]
async fn main() {
    let _ = env_logger::init();
    let _ = dotenv::dotenv();
    let wallet: Wallet = (drift_rs::utils::load_keypair_multi_format(
        &std::env::var("PRIVATE_KEY").expect("base58 PRIVATE_KEY set"),
    )
    .unwrap())
    .into();

    let context = if std::env::var("MAINNET").is_ok() {
        Context::MainNet
    } else {
        Context::DevNet
    };
    let rpc_url = std::env::var("RPC_URL")
        .unwrap_or_else(|_| "https://api.mainnet-beta.solana.com".to_string());
    let drift = DriftClient::new(context, RpcClient::new(rpc_url), wallet.clone())
        .await
        .expect("initialized client");

    // choose a sub-account for order placement
    let maker_subaccount = wallet.default_sub_account();

    let maker_subaccount_data = drift
        .get_account_value(&maker_subaccount)
        .await
        .expect("drift account exists");

    // Example order parameters - you can modify these as needed
    let market_index = 0; // SOL-PERP market
    let market_type = MarketType::Perp;
    let order_direction = PositionDirection::Long;
    let side = if order_direction == PositionDirection::Long {
        "ask"
    } else {
        "bid"
    };

    // Create a sample order
    let order = OrderParams {
        market_index,
        market_type,
        base_asset_amount: 10_000_000,
        order_type: OrderType::Market,
        direction: PositionDirection::Long,
        post_only: PostOnlyParam::None,
        ..Default::default()
    };

    // Get top makers
    let makers = match get_top_makers(context, market_index, market_type, side, Some(4)).await {
        Ok(makers) if !makers.is_empty() => {
            println!(
                "Found {} makers for market {} on {} side",
                makers.len(),
                market_index,
                side
            );
            makers
        }
        Ok(_) => {
            eprintln!(
                "No makers found for market {} on {} side",
                market_index, side
            );
            return;
        }
        Err(e) => {
            eprintln!("Error fetching makers: {}", e);
            return;
        }
    };

    // Display information about all makers
    for (i, (maker, account)) in makers.iter().enumerate() {
        println!(
            "Maker {}: {} (authority: {})",
            i + 1,
            maker,
            account.authority
        );
    }

    let referrer = None; // Optional referrer

    let tx = TransactionBuilder::new(
        drift.program_data(),
        maker_subaccount,
        std::borrow::Cow::Borrowed(&maker_subaccount_data),
        false,
    )
    .with_priority_fee(1_000, Some(200_000))
    .place_and_take(order, &makers, referrer, None, None)
    .build();

    match drift.sign_and_send(tx).await {
        Ok(sig) => {
            println!("sent tx: {sig:?}");
        }
        Err(err) => {
            println!("send tx err: {err:?}");
        }
    }
}

```

## File: examples/simple-margin-calculation/src/main.rs
```
//! Example demonstrating the simplified margin calculation API
//! 
//! This example shows how to use the MarketState struct
//! to calculate simplified margin requirements.

use drift_rs::MarketState;
use drift_rs::drift_idl::{
    accounts::{SpotMarket, PerpMarket, User},
    types::MarginRequirementType,
};
use drift_rs::ffi::OraclePriceData;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Drift Simplified Margin Calculation Example");

    // Create a new market state
    let market_state = MarketState::new();

    // Example: Add a spot market (you would populate this with real data)
    let spot_market = SpotMarket {
        market_index: 0,
        // ... other fields would be populated with real data
        ..Default::default()
    };

    // Example: Add a perp market
    let perp_market = PerpMarket {
        market_index: 0,
        // ... other fields would be populated with real data
        ..Default::default()
    };

    // Example: Add oracle price data
    let oracle_price = OraclePriceData {
        price: 100_000_000, // $100 in price precision
        // ... other fields would be populated with real data
        ..Default::default()
    };

    // Add markets and oracle data to the state
    market_state.set_spot_market(spot_market);
    market_state.set_perp_market(perp_market);
    market_state.set_spot_oracle_price(0, oracle_price);

    // Example: Create a user (you would populate this with real data)
    let user = User {
        // ... fields would be populated with real user data
        ..Default::default()
    };

    // Calculate simplified margin requirement
    let margin_calc = market_state.calculate_simplified_margin_requirement(
        &user,
        MarginRequirementType::Initial,
        None, // margin_buffer: Option<u32>
    )?;

    println!("Margin Calculation Results:");
    println!("  Total Collateral: {}", margin_calc.total_collateral);
    println!("  Margin Requirement: {}", margin_calc.margin_requirement);
    
    Ok(())
}

```

## File: examples/swift-maker/src/main.rs
```
//! Example swift maker bot
//!
//! The `TODO:` comments should be altered depending on individual maker strategy
//!
use drift_rs::{
    swift_order_subscriber::SignedOrderInfo,
    types::{MarketId, OrderParams, OrderType, PositionDirection, PostOnlyParam},
    DriftClient, RpcClient, Wallet,
};
use futures_util::StreamExt;
use solana_pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let _ = env_logger::init();
    let _ = dotenv::dotenv();
    let wallet: Wallet = (drift_rs::utils::load_keypair_multi_format(
        &std::env::var("PRIVATE_KEY").expect("base58 PRIVATE_KEY set"),
    )
    .unwrap())
    .into();

    // choose a sub-account for order placement
    let filler_subaccount = wallet.default_sub_account();

    let use_mainnet = std::env::var("MAINNET").is_ok();
    let context = if use_mainnet {
        drift_rs::types::Context::MainNet
    } else {
        drift_rs::types::Context::DevNet
    };
    let rpc_url =
        std::env::var("RPC_URL").unwrap_or_else(|_| "https://api.devnet.solana.com".to_string());
    let drift = DriftClient::new(context, RpcClient::new(rpc_url), wallet)
        .await
        .expect("initialized client");
    let _ = drift
        .subscribe_blockhashes()
        .await
        .expect("subscribed blockhashes");

    // subscribe to filler account (used when building Txs)
    let _ = drift
        .subscribe_account(&filler_subaccount)
        .await
        .expect("subscribed");

    // choose some markets by symbol
    let market_ids: Vec<MarketId> = ["sol-perp"]
        .iter()
        .map(|m| drift.market_lookup(m).expect("market found"))
        .collect();

    let mut swift_order_stream = drift
        .subscribe_swift_orders(&market_ids, Some(true), None)
        .await
        .expect("subscribed swift orders");

    // watch orders
    loop {
        tokio::select! {
            biased;
            _ = tokio::signal::ctrl_c() => {
                println!("swift maker shutting down...");
                break;
            }
            swift_order = swift_order_stream.next() => {
                match swift_order {
                    Some(order) => {
                        let _handle = tokio::spawn(try_fill(drift.clone(), filler_subaccount, order));
                    }
                    None => {
                        println!("swift order stream finished");
                        break;
                    }
                }
            }
        }
    }
}

/// Try to fill a swift order
async fn try_fill(drift: DriftClient, filler_subaccount: Pubkey, swift_order: SignedOrderInfo) {
    // TODO: filter `swift_order.order_params()` depending on strategy params
    println!("new swift order: {swift_order:?}");
    let taker_order = swift_order.order_params();
    let taker_subaccount = swift_order.taker_subaccount();

    // fetching taker accounts inline
    // TODO: for better fills maintain a gRPC map of user accounts
    let (taker_account_data, taker_stats, tx_builder) = tokio::try_join!(
        drift.get_user_account(&taker_subaccount), // always hits RPC
        drift.get_user_stats(&swift_order.taker_authority), // always hits RPC
        drift.init_tx(&filler_subaccount, false)
    )
    .unwrap();

    // built the taker tx
    // It places the swift order for the taker and fills it
    let tx = tx_builder
        .place_and_make_swift_order(
            OrderParams {
                order_type: OrderType::Limit,
                market_index: taker_order.market_index,
                market_type: taker_order.market_type,
                direction: match taker_order.direction {
                    PositionDirection::Long => PositionDirection::Short,
                    PositionDirection::Short => PositionDirection::Long,
                },
                // TODO: fill at price depending on strategy params
                // this always attempts to fill at the best price for the _taker_
                price: taker_order
                    .auction_start_price
                    .expect("start price set")
                    .unsigned_abs(),
                // try fill the whole order amount
                base_asset_amount: taker_order.base_asset_amount,
                post_only: PostOnlyParam::MustPostOnly,
                bit_flags: 0,
                ..Default::default()
            },
            &swift_order,
            &taker_account_data,
            &taker_stats.referrer,
        )
        .build();

    match drift.sign_and_send(tx).await {
        Ok(sig) => {
            println!("sent fill: {sig}");
        }
        Err(err) => {
            println!("fill failed: {err}");
        }
    }
}

```

## File: examples/swift-taker/src/main.rs
```
//! Example place swift taker order
use argh::FromArgs;
use base64::Engine;
use drift_rs::{
    swift_order_subscriber::{SignedOrderInfo, SignedOrderType},
    types::{MarketType, OrderParams, OrderType, PositionDirection, SignedMsgOrderParamsMessage},
    Context, DriftClient, RpcClient, TransactionBuilder, Wallet,
};
use nanoid::nanoid;
use reqwest::header;

/// Swift taker client example
#[derive(FromArgs)]
struct SwiftTakerArgs {
    /// make a depositTrade request
    #[argh(switch)]
    deposit_trade: bool,
}

#[tokio::main]
async fn main() {
    let _ = env_logger::init();
    let _ = dotenv::dotenv();
    let wallet: Wallet = drift_rs::utils::load_keypair_multi_format(
        &std::env::var("PRIVATE_KEY").expect("base58 PRIVATE_KEY set"),
    )
    .unwrap()
    .into();
    let args: SwiftTakerArgs = argh::from_env();

    let use_mainnet = std::env::var("MAINNET").is_ok();
    let context = if use_mainnet {
        drift_rs::types::Context::MainNet
    } else {
        drift_rs::types::Context::DevNet
    };
    let rpc_url =
        std::env::var("RPC_URL").unwrap_or_else(|_| "https://api.devnet.solana.com".to_string());
    let drift = DriftClient::new(context, RpcClient::new(rpc_url), wallet.clone())
        .await
        .expect("initialized client");

    let latest_slot = drift.rpc().get_slot().await.expect("get slot") + 200;

    let order_params = OrderParams {
        market_index: 0,
        market_type: MarketType::Perp,
        order_type: OrderType::Oracle,
        base_asset_amount: 100_000_000,
        direction: PositionDirection::Long,
        auction_start_price: Some(1_00),
        auction_end_price: Some(1_000),
        auction_duration: Some(20),
        ..Default::default()
    };
    let signed_order_params = SignedMsgOrderParamsMessage {
        sub_account_id: 0,
        signed_msg_order_params: order_params,
        slot: latest_slot,
        uuid: nanoid!(8).as_bytes().try_into().unwrap(),
        take_profit_order_params: None,
        stop_loss_order_params: None,
        max_margin_ratio: None,
        builder_idx: None,
        builder_fee_tenth_bps: None,
        isolated_position_deposit: None,
    };
    let swift_order_type = SignedOrderType::authority(signed_order_params);
    let signed_msg = hex::encode(swift_order_type.to_borsh());
    let signature = drift.wallet.sign_message(signed_msg.as_bytes()).unwrap();

    let swift_order_request = serde_json::json!({
        "message": signed_msg,
        "taker_authority": wallet.authority().to_string(),
        "taker_pubkey": wallet.default_sub_account().to_string(),
        "signature": base64::prelude::BASE64_STANDARD.encode(signature.as_ref()),
    });
    dbg!(&swift_order_request.to_string());

    if args.deposit_trade {
        let signed_order_info =
            SignedOrderInfo::authority(*drift.wallet.authority(), signed_order_params, signature);
        // SOL deposit, 0 = usdc, 1 = sol
        swift_deposit_trade(
            &drift,
            100_000_000,
            0,
            swift_order_request,
            signed_order_info,
        )
        .await;
    } else {
        swift_place_order(&drift, swift_order_request).await;
    }
}

async fn swift_place_order(drift: &DriftClient, swift_order_request: serde_json::Value) {
    println!("sending swift order: {swift_order_request:?}");
    let swift_url = if drift.context == Context::MainNet {
        "https://swift.drift.trade/orders"
    } else {
        "https://master.swift.drift.trade/orders"
    };
    let swift_cli = reqwest::Client::new();
    let req = swift_cli
        .post(swift_url)
        .header(header::CONTENT_TYPE, "application/json")
        .json(&swift_order_request)
        .build();
    dbg!(&req);
    let res = swift_cli.execute(req.unwrap()).await;
    dbg!(&res);
    let response = res.unwrap().text().await.unwrap();
    dbg!(response);
}

async fn swift_deposit_trade(
    drift: &DriftClient,
    deposit_amount: u64,
    deposit_market_index: u16,
    swift_order_request: serde_json::Value,
    signed_order_info: SignedOrderInfo,
) {
    println!("sending swift depositTrade order: {swift_order_request:?}, deposit amount: {deposit_amount}, market: {deposit_market_index}");
    let taker_subaccount = drift.wallet().default_sub_account();
    let taker_account_data = drift
        .get_user_account(&taker_subaccount)
        .await
        .expect("user account exists");

    let spot_market_config = drift
        .program_data()
        .spot_market_config_by_index(deposit_market_index)
        .unwrap();
    let create_ata_ix =
        spl_associated_token_account::instruction::create_associated_token_account_idempotent(
            drift.wallet().authority(),
            drift.wallet().authority(),
            &spot_market_config.mint,
            &spot_market_config.token_program(),
        );

    let unsigned_tx = TransactionBuilder::new(
        drift.program_data(),
        taker_subaccount,
        std::borrow::Cow::Borrowed(&taker_account_data),
        false,
    )
    // .add_ix(additional_setup_ixs)
    .add_ix(create_ata_ix)
    .deposit(deposit_amount, deposit_market_index, None, None)
    .place_swift_order(&signed_order_info, &taker_account_data)
    // .add_ix(additional_clean_up_ixs)
    .build();
    let signed_tx = drift
        .wallet()
        .sign_tx(
            unsigned_tx.clone(),
            drift.get_latest_blockhash().await.unwrap(),
        )
        .unwrap();
    dbg!(&signed_tx.verify_with_results());
    dbg!(&signed_tx);

    let sim_res = drift.simulate_tx(unsigned_tx).await;
    dbg!(sim_res);

    let req = serde_json::json!({
        "deposit_tx": base64::prelude::BASE64_STANDARD.encode(
            bincode::serialize(&signed_tx).unwrap()
        ),
        "swift_order": swift_order_request,
    });

    let swift_url = if drift.context == Context::MainNet {
        "https://swift.drift.trade/depositTrade"
    } else {
        "https://master.swift.drift.trade/depositTrade"
    };
    let swift_cli = reqwest::Client::new();
    let req = swift_cli
        .post(swift_url)
        .header(header::CONTENT_TYPE, "application/json")
        .json(&req)
        .build();
    dbg!(&req);
    let res = swift_cli.execute(req.unwrap()).await;
    dbg!(&res);
    let response = res.unwrap().text().await.unwrap();
    dbg!(response);
}

```

## File: .github/workflows/build.yml
```
name: Build

on:
  push:
    branches:
      - master
      - main
    paths:
      - "**.rs"
      - "**.toml"
      - "**.lock"
      - ".github/workflows/*.yml"
  pull_request:
    branches:
      - master
      - main
    paths:
      - "**.rs"
      - "**.toml"
      - "**.lock"
      - ".github/workflows/*.yml"

jobs:
  format-build-test:
    env:
      CARGO_DRIFT_FFI_PATH: /usr/lib
    runs-on: ubicloud
    timeout-minutes: 15
    steps:
      - name: Check out
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: Cache Rust toolchain
        id: cache-rust-target-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-rust-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-${{ hashFiles('**/Cargo.lock') }}
      - name: Config rust toolchain
        run: |
          rustup show active-toolchain
          rustup component add clippy rustfmt
      - name: install latest libdrift_ffi_sys
        run: |
          # NB: this will break historic CI jobs (if breaking program changes happen)
          # better to ensure latest version works
          SO_URL=$(curl -s https://api.github.com/repos/drift-labs/drift-ffi-sys/releases/latest | jq -r '.assets[] | select(.name=="libdrift_ffi_sys.so") | .browser_download_url')
          echo "downloading libdrift: $SO_URL"
          curl -L -o libdrift_ffi_sys.so "$SO_URL"
          sudo cp libdrift_ffi_sys.so $CARGO_DRIFT_FFI_PATH
      - name: Format
        run: cargo fmt --all -- --check
      - name: Build
        run: cargo check
      - name: Test
        run: |
          cargo test --no-fail-fast --lib -- --nocapture
          cargo test --no-fail-fast --test integration -- --nocapture --test-threads 2
          cargo test --no-fail-fast --test jupiter -- --nocapture --test-threads 2
        env:
          TEST_DEVNET_RPC_ENDPOINT: ${{ secrets.DEVNET_RPC_ENDPOINT }}
          TEST_MAINNET_RPC_ENDPOINT: ${{ secrets.MAINNET_RPC_ENDPOINT }}
          TEST_PRIVATE_KEY: ${{ secrets.TEST_PRIVATE_KEY }}
          TEST_MAINNET_PRIVATE_KEY: ${{ secrets.TEST_MAINNET_PRIVATE_KEY }}
          TEST_GRPC_X_TOKEN: ${{ secrets.TEST_GRPC_X_TOKEN }}
      - name: Cache Rust toolchain (save)
        uses: actions/cache/save@v4
        if: success() || failure()
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ steps.cache-rust-target-restore.outputs.cache-primary-key }}

```

## File: .github/workflows/manual-idl-update.yml
```
# Workflow to trigger manual update e.g incase of failed/missed workflow
name: "Trigger IDL update"
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'IDL version (e.g. 2.111.0)'
        required: true
        type: string

jobs:
  trigger-dispatch:
    runs-on: ubicloud
    steps:
    - name: trigger dispatch event
      run: |
        curl -X POST \
        -H "Accept: application/vnd.github+json" \
        -H "Authorization: token ${{ secrets.GH_PAT }}" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        https://api.github.com/repos/drift-labs/drift-rs/dispatches \
        -d '{"event_type":"sdk-update","client_payload":{"version":"${{ github.event.inputs.version }}"}}'

```

## File: .github/workflows/on-libdrift-update.yml
```
name: "Bump libdrift"
on:
  repository_dispatch:
    types: ['libdrift-update']

jobs:
  update-libdrift-submodule:
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubicloud
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions@github.com"
      
      - name: Update submodule
        run: |
          cd crates/drift-ffi-sys
          git checkout master
          git pull origin master
          cd ../..
          git add -u

      - name: Check for changes
        id: check_changes
        run: |
          if git diff --staged --quiet; then
            echo "No changes to submodule, skipping PR creation"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Create branch
        if: steps.check_changes.outputs.has_changes == 'true'
        id: create_branch
        run: |
          BRANCH_NAME="bump-libdrift-$(date +%Y%m%d-%H%M%S)"
          git checkout -b $BRANCH_NAME
          git commit -m "chore: bump drift-ffi-sys to latest version 🤖"
          git push origin $BRANCH_NAME
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { repo, owner } = context.repo;
            const result = await github.rest.pulls.create({
              owner,
              repo,
              title: 'chore: bump drift-ffi-sys to latest version 🤖',
              body: 'This PR was automatically created by the GitHub Action workflow to update the libdrift submodule.',
              head: '${{ steps.create_branch.outputs.branch_name }}',
              base: 'main'
            });
            console.log(`Pull Request created: ${result.data.html_url}`);

```

## File: .github/workflows/on-program-update.yml
```
name: Bump program IDL
on:
  repository_dispatch:
    types: ['sdk-update']

jobs:
  check-version:
    runs-on: ubicloud
    outputs:
      idl_version: ${{ steps.version-check.outputs.idl_version }}
      proceed: ${{ steps.version-check.outputs.proceed }}
    steps:
      - name: Check update version
        id: version-check
        run: |
          VERSION=$(curl -s "https://api.github.com/repos/drift-labs/protocol-v2/tags" | grep -m 1 "name" | cut -d '"' -f 4)
          echo "idl_version=$VERSION" >> $GITHUB_OUTPUT

          # Check if version contains beta, alpha, or rc tags
          if echo "$VERSION" | grep -qE "beta|alpha|rc"; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "Skipping PR creation for pre-release version: $VERSION"
          else
            echo "proceed=true" >> $GITHUB_OUTPUT
          fi

  update-idl:
    needs: check-version
    if: needs.check-version.outputs.proceed == 'true'
    runs-on: ubicloud
    permissions:
      contents: write
      pull-requests: write
    env:
      CARGO_DRIFT_FFI_PATH: /usr/lib
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update IDL
        run: |
          curl -H 'Accept: application/vnd.github.v3.raw' 'https://api.github.com/repos/drift-labs/protocol-v2/contents/sdk/src/idl/drift.json?ref=tags/${{ needs.check-version.outputs.idl_version }}' > res/drift.json

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Generate Rust types
        run: |
          # libdrift install
          SO_URL=$(curl -s https://api.github.com/repos/drift-labs/drift-ffi-sys/releases/latest | jq -r '.assets[] | select(.name=="libdrift_ffi_sys.so") | .browser_download_url')
          echo "downloading libdrift: $SO_URL"
          curl -L -o libdrift_ffi_sys.so "$SO_URL"
          sudo cp libdrift_ffi_sys.so $CARGO_DRIFT_FFI_PATH && rm libdrift_ffi_sys.so

          cargo check

      - name: Git config
        run: |
          git config user.name "GitHub Actions"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Commit changes
        run: |
          # Create branch and commit changes (don't fail if it exists)
          git checkout -b bump/idl-${{ needs.check-version.outputs.idl_version }} || true
          git add -u
          git commit -m "chore: bump IDL to ${{ needs.check-version.outputs.idl_version }}"
          git push origin bump/idl-${{ needs.check-version.outputs.idl_version }} -f

      - name: Create PR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_EXISTS=$(gh pr list --head "bump/idl-${{ needs.check-version.outputs.idl_version }}" --json number | jq 'length')
          if [ "$PR_EXISTS" -gt 0 ]; then
            echo "PR for version ${{ needs.check-version.outputs.idl_version }} already exists, skipping PR creation"
          else
            gh pr create \
            --title "Bump IDL to ${{ needs.check-version.outputs.idl_version }}" \
            --body "Automatic IDL update for program ${{ needs.check-version.outputs.idl_version }}" \
            --label "idl" \
            --base main \
            --head bump/idl-${{ needs.check-version.outputs.idl_version }}
          fi

```

## File: .github/workflows/release.yml
```
name: Release

permissions:
  pull-requests: write
  contents: write

on:
  push:
    tags:
      - 'v[12].[0-9]+.[0-9]+'
      - 'v[12].[0-9]+.[0-9]+-alpha.[0-9]+'

jobs:
  crates-io:
    name: Publish to crates.io
    runs-on: ubicloud
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: true
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: install 1.76.0 toolchain
        run: |
          rustup install 1.76.0-x86_64-unknown-linux-gnu
      - name: Cargo login
        run: |
          cargo login ${{ secrets.CARGO_REGISTRY_TOKEN }}
      - name: Publish drift-idl-gen
        run: |
          cd crates/drift-idl-gen
          cargo publish || true
      - name: Publish drift-pubsub-client
        run: |
          cd crates/pubsub-client
          cargo publish || true
      - name: Publish drift-rs
        run: |
          # add libdrift_ffi_sys
          FFI_VERSION=$(grep '^version = ' crates/drift-ffi-sys/Cargo.toml | sed 's/version = "\(.*\)"/\1/')
          curl -L https://github.com/drift-labs/drift-ffi-sys/releases/download/v$FFI_VERSION/libdrift_ffi_sys.so > libdrift_ffi_sys.so
          sudo mv libdrift_ffi_sys.so $CARGO_DRIFT_FFI_PATH
          # publish to crates.io
          cargo -V
          cargo publish
        env:
          CARGO_DRIFT_FFI_PATH: "/usr/lib"

  notify-downstream-repos:
    needs: crates-io
    runs-on: ubicloud
    strategy:
      matrix:
        repo: ['gateway', 'swift']
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: true
      - name: Notify repository
        run: |
          # Extract libdrift-ffi-sys version
          FFI_VERSION=$(grep '^version = ' crates/drift-ffi-sys/Cargo.toml | sed 's/version = "\(.*\)"/\1/')
          # Extract release tag (removes 'refs/tags/' prefix)
          TAG=${GITHUB_REF#refs/tags/}
 
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.REPO_DISPATCH_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/drift-labs/${{ matrix.repo }}/dispatches \
            -d "{\"event_type\":\"drift_rs_release\",\"client_payload\":{\"tag\":\"$TAG\",\"ffi_version\":\"$FFI_VERSION\"}}"

```

## File: .rustfmt.toml
```
imports_granularity = "Crate"
use_field_init_shorthand = true
```

## File: build.rs
```
use std::{collections::HashMap, path::Path};

const LIB: &str = "libdrift_ffi_sys";
const SUPPORTED_PLATFORMS: &[(&str, &str, &str)] = &[
    ("apple", "x86_64-apple-darwin", "dylib"),
    ("linux", "x86_64-unknown-linux-gnu", "so"),
];
const FFI_TOOLCHAIN_VERSION: &str = "1.76.0";

fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("DOCS_RS").is_ok() {
        println!("cargo:warning=docs.rs build detected. skipping idl-gen and libdrift build");
        return Ok(());
    }
    let current_dir = std::env::current_dir()?.canonicalize()?;

    // Generate IDL types from 'res/drift.json'
    let idl_source_path = current_dir.join("res/drift.json");
    let idl_mod_path = current_dir.join("crates/src/drift_idl.rs");
    generate_idl_types(&idl_source_path, idl_mod_path.as_path())?;

    // Only build FFI lib if static or no lib path provided
    if should_build_from_source() {
        build_ffi_lib(&current_dir)?;
    }

    link_library()?;
    Ok(())
}

fn generate_idl_types(
    idl_source_path: &Path,
    idl_mod_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let idl_mod_rs = drift_idl_gen::generate_rust_types(idl_source_path)
        .map_err(|err| format!("generating IDL failed: {err:?}"))?;

    std::fs::write(idl_mod_path, idl_mod_rs)?;
    Ok(())
}

fn should_build_from_source() -> bool {
    if std::env::var("CARGO_DRIFT_FFI_STATIC").is_ok() {
        println!("cargo:warning=CARGO_DRIFT_FFI_STATIC on");
        return true;
    }

    match std::env::var("CARGO_DRIFT_FFI_PATH") {
        Err(_) => {
            println!("cargo:warning=CARGO_DRIFT_FFI_PATH not set");
            true
        }
        Ok(ref path) => {
            println!("cargo:warning=CARGO_DRIFT_FFI_PATH set: {path}");
            false
            // check version
            // if let Some(soname) = extract_soname(&format!("{path}/{LIB}")) {
            //     if soname.contains(LIB_VERSION.as_str()) {
            //         println!("cargo:warning=compatible {LIB} version detected ✅");
            //         return false;
            //     } else {
            //         println!("cargo:warning=incompatible {LIB} version detected ❌: {soname}");
            //         println!(
            //             "cargo:warning=update {LIB} to latest release: {}",
            //             LIB_VERSION.as_str()
            //         );
            //         return true;
            //     }
            // }
            // println!("cargo:warning=no compatible {LIB} detected");
            // true
        }
    }
}

fn build_ffi_lib(current_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:warning={LIB}: building from source...");

    let host_target = std::env::var("TARGET")?;
    let (lib_target, lib_ext) = get_platform_details(&host_target)?;

    verify_toolchain(lib_target)?;

    // Build the library
    let profile = std::env::var("PROFILE")?;
    let drift_ffi_sys_crate = current_dir.join("crates/drift-ffi-sys");
    // Check if submodule was cloned/exists
    check_submodule_exists(&drift_ffi_sys_crate)?;
    build_with_toolchain(&drift_ffi_sys_crate, lib_target, &profile)?;
    install_library(&drift_ffi_sys_crate, &profile, lib_ext)?;

    Ok(())
}

fn check_submodule_exists(crate_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    // Check if the Cargo.toml file exists in the submodule directory
    let cargo_toml_path = crate_path.join("Cargo.toml");

    if !cargo_toml_path.exists() {
        println!("cargo:warning=drift-ffi-sys submodule not found");
        return Err(format!(
            "drift-ffi-sys submodule not initialized: {} not found. Run 'git submodule update --init --recursive'",
            cargo_toml_path.display()
        ).into());
    }

    Ok(())
}

fn get_platform_details(
    host_target: &str,
) -> Result<(&'static str, &'static str), Box<dyn std::error::Error>> {
    for (platform, target, ext) in SUPPORTED_PLATFORMS {
        if host_target.contains(platform) {
            return Ok((target, ext));
        }
    }

    println!("cargo:warning=Unsupported host platform: {host_target}");
    println!(
        "cargo:warning=Please open an issue at: https://github.com/drift-labs/drift-rs/issues"
    );
    Err("Unsupported platform".into())
}

fn verify_toolchain(lib_target: &str) -> Result<(), Box<dyn std::error::Error>> {
    let ffi_toolchain = format!("{FFI_TOOLCHAIN_VERSION}-{lib_target}");
    let output = std::process::Command::new("rustup")
        .args(["toolchain", "list"])
        .output()?;

    if !output.status.success() {
        return Err("Failed to query rustup toolchains".into());
    }

    let installed_toolchains = String::from_utf8_lossy(&output.stdout);
    if !installed_toolchains.contains(&ffi_toolchain) {
        println!("cargo:warning=Required toolchain {ffi_toolchain} is missing");
        println!("cargo:warning=Run: 'rustup install {ffi_toolchain}' to install");
        return Err("Missing required toolchain".into());
    }

    Ok(())
}

fn build_with_toolchain(
    drift_ffi_sys_crate: &Path,
    lib_target: &str,
    profile: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // Filter out cargo and rustc environment variables
    let ffi_build_envs: HashMap<String, String> = std::env::vars()
        .filter(|(k, _v)| !k.starts_with("CARGO") && !k.starts_with("RUSTC"))
        .collect();

    let ffi_toolchain = format!("{FFI_TOOLCHAIN_VERSION}-{lib_target}");
    let mut ffi_build = std::process::Command::new("rustup");
    ffi_build
        .env_clear()
        .envs(ffi_build_envs)
        .current_dir(drift_ffi_sys_crate)
        .args(["run", &ffi_toolchain, "cargo", "build"]);

    match profile {
        "debug" => (),
        "release" => {
            ffi_build.arg("--release");
        }
        custom => {
            ffi_build.arg(format!("--profile={custom}"));
        }
    }

    let output = ffi_build.output()?;
    if !output.status.success() {
        println!("cargo:warning={}", String::from_utf8_lossy(&output.stderr));
        return Err("FFI build failed".into());
    }

    Ok(())
}

fn install_library(
    drift_ffi_sys_crate: &Path,
    profile: &str,
    lib_ext: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let libffi_out_path = drift_ffi_sys_crate.join(format!("target/{profile}/{LIB}.{lib_ext}"));

    if let Ok(out_dir) = std::env::var("OUT_DIR") {
        std::process::Command::new("cp")
            .args([
                libffi_out_path.to_str().ok_or("Invalid path")?,
                out_dir.as_str(),
            ])
            .output()?;
        println!("cargo:warning={LIB}: searching for lib at: {out_dir}");
        println!("cargo:rustc-link-search=native={out_dir}");
    } else {
        // Install to system library path
        std::process::Command::new("ln")
            .args([
                "-sf",
                libffi_out_path.to_str().ok_or("Invalid path")?,
                "/usr/local/lib/",
            ])
            .output()?;

        println!("cargo:warning={LIB}: searching for lib at: /usr/local/lib");
        println!("cargo:rustc-link-search=native=/usr/local/lib");
    }

    Ok(())
}

fn link_library() -> Result<(), Box<dyn std::error::Error>> {
    if let Ok(lib_path) = std::env::var("CARGO_DRIFT_FFI_PATH") {
        println!("cargo:rustc-link-search=native={lib_path}");
    } else {
        // On linux need to refresh the linker cache
        let host_target = std::env::var("TARGET")?;
        let (lib_target, _lib_ext) = get_platform_details(&host_target)?;
        if lib_target.contains("linux") {
            if let Err(err) = std::process::Command::new("ldconfig").output() {
                println!("cargo:warning={LIB}: ldconfig failed: {err:?}");
            }
        }
    }

    println!("cargo:rustc-link-lib=dylib=drift_ffi_sys");
    Ok(())
}

// try to pull the SONAME from drift_ffi_sys lib
// fn extract_soname(path: &str) -> Option<String> {
//     use std::{fs::File, io::Read};
//     use goblin::{elf::Elf, mach::MachO};
//     let mut buffer = Vec::new();

//     // try linux
//     let _ = File::open(format!("{path}.so")).and_then(|mut f| f.read_to_end(&mut buffer));
//     if let Ok(elf) = Elf::parse(&buffer) {
//         return elf.soname.map(|s| s.to_string());
//     }

//     // try mac OS
//     buffer.clear();
//     let _ = File::open(format!("{path}.dylib")).and_then(|mut f| f.read_to_end(&mut buffer));
//     // Parse the macho file
//     if let Ok(macho) = MachO::parse(&buffer, 0) {
//         return macho.name.map(|n| n.to_string());
//     }

//     None
// }

```

## File: crates/drift-idl-gen/Cargo.toml
```
[package]
name = "drift-idl-gen"
version = "0.2.0"
edition = "2021"
license = "Apache-2.0"
repository = "https://github.com/drift-labs/drift-rs"
description = "Generates Drift v2 structs/types from anchor IDL"

[lib]

[dependencies]
proc-macro2 = "1"
quote = "1"
syn = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
sha2 = "0.10"
```

## File: crates/pubsub-client/Cargo.toml
```
[package]
name = "drift-pubsub-client"
version = "0.1.1"
edition = "2021"
license = "Apache-2.0"
readme = "README.md"
repository = "https://github.com/drift-labs/drift-rs"
description = "Solana Pubsub Client patched with proper connection handling"

[dependencies]
futures-util = "0.3"
gjson = "0.8.1"
log = "0.4"
serde = { version = "1", features = ["derive"] }
serde_json = { version = "1", features = ["raw_value"] }
solana-account-decoder-client-types = "2"
solana-sdk = "2"
solana-rpc-client-api = "2"
thiserror = "1"
tokio = { version = "1.48", features = ["full"] }
tokio-stream = "0.1"
tokio-tungstenite = { version = "0.28.0", features = ["native-tls"] }
url = "2.5"
```

## File: examples/dlob-builder/Cargo.toml
```
[package]
name = "dlob-builder"
version = "0.1.0"
edition = "2021"

[dependencies]
dotenv = "0.15.0"
drift-rs = { path = "../../../drift-rs", features = ["unsafe_pub"] }
env_logger = "*"
solana-commitment-config = "2"
solana-keypair= "2"
tokio = "*"
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }
serde = { version = "1.0", features = ["derive"] }

```

## File: examples/dlob-matching/Cargo.toml
```
[package]
name = "demonstrate-l3-methods"
version = "0.1.0"
edition = "2021"

[dependencies]
dotenv = "0.15.0"
drift-rs = { path = "../../" }
env_logger = "*"
solana-commitment-config = "2"
solana-keypair = "2"
tokio = { version = "1.42", features = ["full"] }

```

## File: examples/drift-client-callbacks/Cargo.toml
```
[package]
name = "drift-client-callbacks"
version = "0.1.0"
edition = "2021"

[dependencies]
drift-rs = { path = "../.." }
solana-sdk = "2.0"
tokio = { version = "1.0", features = ["full"] }
env_logger = "0.11"
dotenv = "0.15"
clap = { version = "4.0", features = ["derive"] }
futures-util = "0.3"
anchor-lang = { version = "0.31", features = ["derive"] }
rust_decimal = "*"

```

## File: examples/event-subscriber/Cargo.toml
```
[package]
name = "event-subscriber"
version = "0.1.0"
edition = "2024"

[dependencies]
dotenv = "0.15.0"
drift-rs = { path = "../../../drift-rs" }
env_logger = "0.11"
futures-util = "0.3.31"
tokio = "*"
clap = { version = "4.4.8", features = ["derive"] }

```

## File: examples/market-maker/Cargo.toml
```
[package]
name = "market-maker-example"
version = "0.1.0"
edition = "2021"

[dependencies]
argh = "0.1.13"
dotenv = "0.15.0"
drift-rs = { path = "../../../drift-rs", features = ["unsafe_pub"] }
futures-util = "0.3"
solana-commitment-config = "2"
solana-keypair= "2"
tokio = "*"

```

## File: examples/place-and-take/Cargo.toml
```
[package]
name = "place-and-take"
version = "0.1.0"
edition = "2024"

[dependencies]
base64 = "0.21"
borsh = "0.10"
dotenv = "0.15.0"
drift-rs = { path = "../../../drift-rs" }
env_logger = "0.11"
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
solana-pubkey = "2"
tokio = "*"
anchor-lang = "0.31"

```

## File: examples/simple-margin-calculation/Cargo.toml
```
[package]
name = "simple-margin-calculation"
version = "0.1.0"
edition = "2021"

[dependencies]
drift-rs = { path = "../.." }

```

## File: examples/swift-maker/Cargo.toml
```
[package]
name = "swift-maker-example"
version = "0.1.0"
edition = "2021"

[dependencies]
dotenv = "0.15.0"
drift-rs = { path = "../../../drift-rs" }
env_logger = "0.11"
futures-util = "0.3.31"
solana-pubkey = "2"
tokio = "*"

```

## File: examples/swift-taker/Cargo.toml
```
[package]
name = "swift-taker-example"
version = "0.1.0"
edition = "2021"

[dependencies]
argh = "0.1.13"
base64 = "0.22.1"
bincode = "1"
dotenv = "0.15.0"
drift-rs = { path = "../../../drift-rs" }
env_logger = "0.11"
hex = "0.4.3"
nanoid = "0.4.0"
reqwest = "0.12.22"
serde_json = "1.0.140"
spl-associated-token-account = { version = "7.0.0", features = ["no-entrypoint"] }
tokio = "*"

```

## File: res/9Jtc.hex
```
9f755fe3ef973aece97752ef8e2801398b6809969b269f7dc22b3e38ad5bc882798f0cc17fa03b2e00000000000000000000000000000000000000000000000000000000000000004d61696e204163636f756e74202020202020202020202020202020202020202000000000000000000000000000000000000000000000000000000000000000000000000000000000a660730b0000000000c2eb0b00000000000000000000000000286bee0000000001000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003d3930f4ffffffff001f0afaffffffff1ed16a00000000001ed16a0000000000c0cf6a00000000000000000000000000001f0afaffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000092d4b50f00000000005a62020000000000e1f50500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000001000101000000000001000000000000a162b90f00000000005a62020000000000e1f50500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000001000101000000000001000000000000a162b90f0000000000e9a4350000000000e1f505000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000001010100010100010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f8d7620e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a162b90f0000000007000000000000000100000000010003010000000000000000000000000000000000000000000000
```

## File: res/drift.json
[Truncated - showing first 1000 chars of 416KB file]
```
{
  "version": "2.146.0",
  "name": "drift",
  "instructions": [
    {
      "name": "initializeUser",
      "accounts": [
        {
          "name": "user",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userStats",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "state",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "subAccountId",
          "type": "u16"
        },
        {
          "name": "name",
          "type"
```

## File: res/spot_market_1_76_0.hex
```
64b1086ba84141270000000000000000000000000000000000000000000000000000000000000000fe650f0367d4a7ef9815a593ea15d36593f0643aaaf0149bb04be67ab851decd000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000601de13700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010a5d4e800000000000000000000000000000000000000000000000000000000e40b5402000000000000000000000000e40b54020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e803000000000000e8030000000000000000000000000000000000000000000000000000000000000000000000000000401f000028230000e02e0000f82a000000000000e803000000000000000000000000000000000000090000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

## File: scripts/idl-update.sh
```
 curl -H 'Accept: application/vnd.github.v3.raw' 'https://api.github.com/repos/drift-labs/protocol-v2/contents/sdk/src/idl/drift.json' > res/drift.json
```

## File: tests/integration.rs
```
use std::time::Duration;

use anchor_lang::Discriminator;
use drift_rs::{
    constants::DEFAULT_PUBKEY,
    event_subscriber::RpcClient,
    grpc::grpc_subscriber::AccountFilter,
    math::constants::{BASE_PRECISION_I64, LAMPORTS_PER_SOL_I64, PRICE_PRECISION_U64},
    types::{accounts::User, Context, MarketId, NewOrder, PostOnlyParam, SettlePnlMode},
    utils::test_envs::{devnet_endpoint, mainnet_endpoint, test_keypair},
    DriftClient, GrpcSubscribeOpts, Pubkey, TransactionBuilder, Wallet,
};
use futures_util::StreamExt;
use solana_sdk::{clock::Slot, signature::Keypair};

#[tokio::test]
async fn client_sync_subscribe_all_devnet() {
    let client = DriftClient::new(
        Context::DevNet,
        RpcClient::new(devnet_endpoint()),
        Keypair::new().into(),
    )
    .await
    .expect("connects");

    tokio::try_join!(
        client.subscribe_all_markets(),
        client.subscribe_all_oracles(),
    )
    .expect("subscribes");
    let all_markets = client.get_all_market_ids();
    for market in all_markets {
        let price = client.oracle_price(market).await.expect("ok");
        assert!(price > 0);
        dbg!(market, price);
    }
}

#[tokio::test]
async fn client_sync_subscribe_devnet() {
    let _ = env_logger::try_init();
    let client = DriftClient::new(
        Context::DevNet,
        RpcClient::new(devnet_endpoint()),
        Keypair::new().into(),
    )
    .await
    .expect("connects");
    let markets = [
        MarketId::spot(1),
        MarketId::spot(2),
        MarketId::perp(0),
        MarketId::perp(1),
        MarketId::perp(2),
    ];
    tokio::try_join!(
        client.subscribe_markets(&markets),
        client.subscribe_oracles(&markets),
    )
    .expect("subscribes");

    let price = client.oracle_price(MarketId::perp(1)).await.expect("ok");
    assert!(price > 0);
    dbg!(price);
    let price = client.oracle_price(MarketId::spot(2)).await.expect("ok");
    assert!(price > 0);
    dbg!(price);
}

#[tokio::test]
async fn client_sync_subscribe_mainnet() {
    let _ = env_logger::try_init();
    let client = DriftClient::new(
        Context::MainNet,
        RpcClient::new(mainnet_endpoint()),
        Keypair::new().into(),
    )
    .await
    .expect("connects");
    let markets = [
        MarketId::spot(1),
        MarketId::spot(2),
        MarketId::perp(0),
        MarketId::perp(1),
        MarketId::perp(2),
        MarketId::perp(4),
        MarketId::spot(32),
    ];
    tokio::try_join!(
        client.subscribe_markets(&markets),
        client.subscribe_oracles(&markets),
    )
    .expect("subscribes");

    let price = client.oracle_price(MarketId::perp(1)).await.expect("ok");
    assert!(price > 0);
    dbg!(price);
    let price = client.oracle_price(MarketId::perp(4)).await.expect("ok");
    assert!(price > 0);
    dbg!(price);
    let price = client.oracle_price(MarketId::spot(32)).await.expect("ok");
    assert!(price > 0);
    dbg!(price);
}

#[tokio::test(flavor = "multi_thread", worker_threads = 5)]
async fn client_sync_subscribe_mainnet_grpc() {
    let _ = env_logger::try_init();
    let client = DriftClient::new(
        Context::MainNet,
        RpcClient::new(mainnet_endpoint()),
        Keypair::new().into(),
    )
    .await
    .expect("connects");

    let (slot_update_tx, mut slot_update_rx) = tokio::sync::mpsc::channel::<Slot>(1);
    let (user_update_tx, mut user_update_rx) = tokio::sync::mpsc::channel::<Pubkey>(1);

    assert!(client
        .grpc_subscribe(
            "https://api.rpcpool.com".into(),
            std::env::var("TEST_GRPC_X_TOKEN").expect("TEST_GRPC_X_TOKEN set"),
            GrpcSubscribeOpts::default()
                .usermap_on()
                .on_slot(move |new_slot| {
                    println!("slot: {new_slot}");
                    let _ = slot_update_tx.try_send(new_slot);
                })
                .on_account(
                    AccountFilter::partial().with_discriminator(User::DISCRIMINATOR),
                    move |account| {
                        println!("account: {}", account.pubkey);
                        let _ = user_update_tx.try_send(account.pubkey);
                    }
                ),
            true,
        )
        .await
        .is_ok());

    // oracle map subscribed
    for market in client.get_all_spot_market_ids() {
        let rpc_fetched_price = client.oracle_price(market).await.unwrap();
        log::info!("fetching market: {market:?}");
        let x = client.try_get_oracle_price_data_and_slot(market).unwrap();
        assert!(x.data.price == rpc_fetched_price);
    }

    for market in client.get_all_perp_market_ids() {
        let rpc_fetched_price = client.oracle_price(market).await.unwrap();
        log::info!("fetching market: {market:?}");
        let x = client.try_get_oracle_price_data_and_slot(market).unwrap();
        assert!(x.data.price == rpc_fetched_price);
    }

    // wait for updates
    tokio::time::sleep(Duration::from_secs(4)).await;

    // markets available
    assert!(client.try_get_perp_market_account(0).is_ok());
    assert!(client.try_get_spot_market_account(1).is_ok());

    // slot update received
    assert!(slot_update_rx.try_recv().is_ok_and(|s| s > 0));

    // user update received
    assert!(user_update_rx.try_recv().is_ok_and(|u| u != DEFAULT_PUBKEY));

    client.grpc_unsubscribe();
}

#[tokio::test]
async fn place_and_cancel_orders() {
    let _ = env_logger::try_init();
    let btc_perp = MarketId::perp(1);
    let sol_spot = MarketId::spot(1);

    let wallet: Wallet = test_keypair().into();
    let client = DriftClient::new(
        Context::DevNet,
        RpcClient::new(devnet_endpoint()),
        wallet.clone(),
    )
    .await
    .expect("connects");

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");
    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .cancel_all_orders()
    .place_orders(vec![
        NewOrder::limit(btc_perp)
            .amount(1 * BASE_PRECISION_I64)
            .price(40 * PRICE_PRECISION_U64)
            .post_only(PostOnlyParam::MustPostOnly)
            .build(),
        NewOrder::limit(sol_spot)
            .amount(-1 * LAMPORTS_PER_SOL_I64)
            .price(400 * PRICE_PRECISION_U64)
            .post_only(PostOnlyParam::MustPostOnly)
            .build(),
    ])
    .cancel_orders(btc_perp.to_parts(), None)
    .cancel_orders(sol_spot.to_parts(), None)
    .build();

    dbg!(tx.clone());

    let result = client.sign_and_send(tx).await;
    dbg!(&result);
    assert!(result.is_ok());
}

#[ignore]
#[tokio::test]
async fn place_and_take() {
    let wallet: Wallet = test_keypair().into();
    let client = DriftClient::new(
        Context::DevNet,
        RpcClient::new(devnet_endpoint()),
        wallet.clone(),
    )
    .await
    .expect("connects");

    let sol_perp = client.market_lookup("sol-perp").expect("exists");

    let order = NewOrder::limit(sol_perp)
        .amount(1 * BASE_PRECISION_I64)
        .price(40 * PRICE_PRECISION_U64)
        .build();
    let tx = client
        .init_tx(&wallet.default_sub_account(), false)
        .await
        .unwrap()
        .place_and_take(order, &[], None, None, None)
        .build();

    let result = client.sign_and_send(tx).await;
    dbg!(&result);
    // TODO: add a place and make to match against
    assert!(result.is_err());
}

#[tokio::test]
async fn client_subscribe_swift_orders() {
    let _ = env_logger::try_init();
    let client = DriftClient::new(
        Context::DevNet,
        RpcClient::new(devnet_endpoint()),
        Keypair::new().into(),
    )
    .await
    .expect("connects");

    let all_markets = client.get_all_perp_market_ids();
    let mut order_stream = client
        .subscribe_swift_orders(all_markets.as_slice(), Some(true), Some(false), None)
        .await
        .unwrap();
    let mut recv_count = 0;
    while let Some(swift_order) = order_stream.next().await {
        if recv_count > 5 {
            break;
        }
        dbg!(swift_order.order_uuid());
        recv_count += 1;
    }
}

#[tokio::test]
async fn oracle_source_mixed_precision() {
    let _ = env_logger::try_init();
    let client = DriftClient::new(
        Context::MainNet,
        RpcClient::new(mainnet_endpoint()),
        Keypair::new().into(),
    )
    .await
    .expect("connects");

    let price = client
        .get_oracle_price_data_and_slot(MarketId::perp(4))
        .await
        .unwrap()
        .data
        .price;
    println!("Bonk: {price}");
    assert!(price % 100_000 > 0);

    tokio::time::sleep(Duration::from_secs(1)).await;
    assert!(client.subscribe_oracles(&[MarketId::perp(4)]).await.is_ok());

    let price = client
        .try_get_oracle_price_data_and_slot(MarketId::perp(4))
        .unwrap()
        .data
        .price;

    println!("Bonk: {price}");
    assert!(price % 100_000 > 0);
}

#[tokio::test]
async fn settle_pnl_txs() {
    let wallet = Wallet::read_only(
        "DxoRJ4f5XRMvXU9SGuM4ZziBFUxbhB3ubur5sVZEvue2"
            .parse()
            .unwrap(),
    );
    let client = DriftClient::new(
        Context::MainNet,
        RpcClient::new(mainnet_endpoint()),
        wallet.clone(),
    )
    .await
    .expect("connects");

    let doge_perp = client.market_lookup("doge-perp").expect("exists");

    let tx = client
        .init_tx(&wallet.default_sub_account(), false)
        .await
        .unwrap()
        .settle_pnl(doge_perp.index(), None, None)
        .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    assert!(result.is_ok_and(|x| x.err.is_none()));

    let sol_perp = client.market_lookup("sol-perp").expect("exists");
    let tx = client
        .init_tx(&wallet.default_sub_account(), false)
        .await
        .unwrap()
        .with_priority_fee(1, Some(2 * 200_000))
        .settle_pnl_multi(
            &[sol_perp.index(), doge_perp.index()],
            SettlePnlMode::MustSettle,
            None,
            None,
        )
        .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    assert!(result.is_ok_and(|x| x.err.is_none()));
}

#[tokio::test]
async fn pyth_pull_update_atomic() {
    let vaa_proof = "UE5BVQEAAAADuAEAAAAEDQCGP2Fjz2LFIX48Qqm/paFzO/iEtFgH5sC1FHhNroyIC2fuzsISzz9IHbvBrlknA0UvM8r9UHSvsAwaqzquhzFsAALnhRblTgAMLanjq38YctnwqDsdV39WviJ0QAnWgRn+a2i4ljPkbVQl1+MM47qcsua4+1L6jo8i3LPMivVx+HQgAQRRADMkx28oGLPnNZnaZp8wtsxckjtx1GvXi+l9d89Yu1DJnYEGkVF4TzZSKtIQe+5OoUPAaIpnEauGVe0AEeh7AAYzopa5UFEUji5zKjTRRUxlQWAWDq3LuGMeV7osio6L/jyD0jMxpYMR0r/dqIdUi2a4GP0uF15k9yFMkANh7OCRAAgb/WNBqaYjLjZsqRqEFKbG3ZVR2vS5ph7EO6D8TKP2gg3Mk3Mhyr2O21KAboy061vKPbHTjX1w3dq8ipnz6EacAQpOpdNfjx1LhMu7ZaMfSM6IFqHOZnQqGxQOQHwh5lAd50Vj8LVu3rng211UchelGHtROvhN1IapTkVSEhD0dbeeAQs+IYIUBk8EahKpPnD0hk6E2d8ge3gKDcgakWgDhRMunArMASyVWkWw0N3p9FvOobXg4V4L5Tim6L1AhHf5Rj0YAAxsygUAwlhGQPEThxT72eY0HVbi8C1LATsBXrW6jksUNTllCqWWbRwgwDSlgibrk05BKtO1pjFCjkWRZZ+TCvrsAA05LnYl0RwpRYUs31y5Lbk8mZHrFDj02MkTC05rGcjVzmddlNcj5/IIp8Hc44GJFZ4XZO3kx7jW3vuF6RQm6RPmAA6xLKcvzZllJT8kxn/LI4AYUuCIOVyLMG/kVodeXWkOKSrkXr0SNwMFsLfl9xvPk2dCa7SyicGwMTUfKP4P8cyeAQ9Q5G4EDpPCq/A0J3luHRoCnSDpCuCu4zTzESAmRe80aSwDl7tN4wSn369Nu4iD6JSyUx/y3bHF7BgvlyGfQYHjABCZpnivKtKFNYpaLR627OKG//Vv3zol7gdCoMOXRcIxLhwSuhn5QlVHgeoOrHiLtOBlTzpz4bwa8btRxvU43pCgABK2TIKVKUnv5OyTjkQh8N5IMpaRK83UH3hpvsJKejNpJQK2zR/WfCkrYjy6pYQfhenZYHi4GCMQ0ALSh9cojaDlAGaVh0wAAAAAABrhAfrtrFhR4yubI7X5QRqMK6xKrj7U3XuBHdGnLqSqcQAAAAAEHJOLAUFVV1YAAAAAAAknGqgAACcQdoC/4vcjI21wyoVC1q3FUZH0FpwBAFUALy0Xq7weeBvYe0pdUsiyhWiG9cSC+jWTzr9nlQQKsLYAAAAAAICwNAAAAAAAAS4k////+AAAAABmlYdMAAAAAGaVh0sAAAAAAH6C+QAAAAAAAPFsCz2Sz2/hyAOSwCA+M8lRiOs+jGuZp6wcFR4rTAFuR2bAYNycVYQFeCxlkQJrEKDSba6FxQXgPZ7wBb/43EHuHHKQaaGb3NVsxnHFnLHefZDbF235q+aRnadgJfm6gqckqb0IczoHBaSuyrVYfSEbPuyNjXE7V++G/OwwVrwQOWqD6ti/nzLgnQ+qCVpEBto25YvZQzkmfYMKg1tJepxs/Sbgyx2fayAJtK8pRlJIixSTRbLiQX408KCq/ElVNzOSqt6Aw1KrAg81sLzKSjMEqnhbdFxgSzqncj8kPFw=";
    let feed_id =
        hex_literal::hex!("2f2d17abbc1e781bd87b4a5d52c8b2856886f5c482fa3593cebf6795040ab0b6");

    let _ = env_logger::try_init();
    let wallet: Wallet = test_keypair().into();
    let client = DriftClient::new(
        Context::MainNet,
        RpcClient::new(mainnet_endpoint()),
        wallet.clone(),
    )
    .await
    .expect("connects");

    let tx = client
        .init_tx(&wallet.default_sub_account(), false)
        .await
        .unwrap()
        .post_pyth_pull_oracle_update_atomic(vaa_proof, &feed_id, None)
        .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    assert!(result.is_ok_and(|x| x.err.is_none()));
}

```

## File: tests/jupiter.rs
```
use drift_rs::{
    event_subscriber::RpcClient,
    jupiter::{JupiterSwapApi, SwapMode},
    types::{accounts::User, Context, MarketId},
    utils::test_envs::{mainnet_endpoint, mainnet_test_keypair},
    DriftClient, TransactionBuilder, Wallet,
};
use solana_sdk::{
    instruction::InstructionError, native_token::LAMPORTS_PER_SOL, transaction::TransactionError,
};
use tokio::sync::OnceCell;

const DRIFT_CLIENT: OnceCell<DriftClient> = OnceCell::const_new();

async fn drift_client() -> DriftClient {
    DRIFT_CLIENT
        .get_or_init(|| async move {
            let wallet: Wallet = mainnet_test_keypair().into();
            DriftClient::new(
                Context::MainNet,
                RpcClient::new(mainnet_endpoint()),
                wallet.clone(),
            )
            .await
            .unwrap()
        })
        .await
        .clone()
}

#[tokio::test]
async fn jupiter_swap_exact_in_udsc_to_sol() {
    let _ = env_logger::try_init();
    let client = drift_client().await;
    let wallet = client.wallet();

    let token_in = MarketId::QUOTE_SPOT;
    let token_out = MarketId::spot(1);

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");

    let jupiter_swap_info = client
        .jupiter_swap_query(
            wallet.authority(),
            10_000_000,
            SwapMode::ExactIn,
            10,
            token_in.index(),
            token_out.index(),
            Some(true),
            None,
            None,
        )
        .await
        .expect("got jup swap ixs");

    let in_market = client
        .program_data()
        .spot_market_config_by_index(token_in.index())
        .unwrap();
    let out_market = client
        .program_data()
        .spot_market_config_by_index(token_out.index())
        .unwrap();

    let in_token_account = Wallet::derive_associated_token_address(&wallet.authority(), &in_market);
    let out_token_account =
        Wallet::derive_associated_token_address(&wallet.authority(), &out_market);

    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .jupiter_swap(
        jupiter_swap_info,
        &in_market,
        &out_market,
        &in_token_account,
        &out_token_account,
        None,
        None,
    )
    .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    let err = result.expect("sim ok").err;
    match err {
        Some(err) => {
            assert_eq!(
                err,
                TransactionError::InstructionError(4, InstructionError::Custom(6157))
            )
        }
        None => assert!(true),
    }
}

#[tokio::test]
async fn jupiter_swap_exact_out_udsc_to_sol() {
    let _ = env_logger::try_init();
    let client = drift_client().await;
    let wallet = client.wallet();

    let token_in = MarketId::QUOTE_SPOT;
    let token_out = MarketId::spot(1);

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");

    let jupiter_swap_info = client
        .jupiter_swap_query(
            wallet.authority(),
            LAMPORTS_PER_SOL / 10,
            SwapMode::ExactOut,
            10,
            token_in.index(),
            token_out.index(),
            Some(true),
            None,
            None,
        )
        .await
        .expect("got jup swap ixs");

    let in_market = client
        .program_data()
        .spot_market_config_by_index(token_in.index())
        .unwrap();
    let out_market = client
        .program_data()
        .spot_market_config_by_index(token_out.index())
        .unwrap();

    let in_token_account = Wallet::derive_associated_token_address(&wallet.authority(), &in_market);
    let out_token_account =
        Wallet::derive_associated_token_address(&wallet.authority(), &out_market);

    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .jupiter_swap(
        jupiter_swap_info,
        &in_market,
        &out_market,
        &in_token_account,
        &out_token_account,
        None,
        None,
    )
    .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    // either swap OK or it would incur borrow which is fine (test account missing 'token in' amount)
    let err = result.expect("sim ok").err;
    match err {
        Some(err) => {
            assert_eq!(
                err,
                TransactionError::InstructionError(2, InstructionError::Custom(6157))
            )
        }
        None => assert!(true),
    }
}

#[tokio::test]
async fn jupiter_swap_exact_out_udsc_jto() {
    let _ = env_logger::try_init();
    let client = drift_client().await;
    let wallet = client.wallet();

    let token_in = MarketId::QUOTE_SPOT;
    let token_out = client.market_lookup("JTO").unwrap();

    let in_market = client
        .program_data()
        .spot_market_config_by_index(token_in.index())
        .unwrap();
    let out_market = client
        .program_data()
        .spot_market_config_by_index(token_out.index())
        .unwrap();

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");

    let jupiter_swap_info = client
        .jupiter_swap_query(
            wallet.authority(),
            5 * 10_u64.pow(out_market.decimals),
            SwapMode::ExactOut,
            10,
            token_in.index(),
            token_out.index(),
            Some(true),
            None,
            None,
        )
        .await
        .expect("got jup swap ixs");

    let in_token_account = Wallet::derive_associated_token_address(&wallet.authority(), &in_market);
    let out_token_account =
        Wallet::derive_associated_token_address(&wallet.authority(), &out_market);

    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .jupiter_swap(
        jupiter_swap_info,
        &in_market,
        &out_market,
        &in_token_account,
        &out_token_account,
        None,
        None,
    )
    .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    let err = result.expect("sim ok").err;
    // either swap OK or it would incur borrow which is fine (test account missing 'token in' amount)
    match err {
        Some(err) => {
            assert_eq!(
                err,
                TransactionError::InstructionError(4, InstructionError::Custom(6157))
            )
        }
        None => assert!(true),
    }
}

#[tokio::test]
async fn jupiter_swap_sol_unwrap() {
    let _ = env_logger::try_init();
    let client = drift_client().await;
    let wallet = client.wallet();

    let token_in = client.market_lookup("SOL").unwrap();
    let token_out = client.market_lookup("mSOL").unwrap();

    let in_market = client
        .program_data()
        .spot_market_config_by_index(token_in.index())
        .unwrap();
    let out_market = client
        .program_data()
        .spot_market_config_by_index(token_out.index())
        .unwrap();

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");

    let jupiter_swap_info = client
        .jupiter_swap_query(
            wallet.authority(),
            LAMPORTS_PER_SOL / 10,
            SwapMode::ExactIn,
            10,
            token_in.index(),
            token_out.index(),
            Some(true),
            None,
            None,
        )
        .await
        .expect("got jup swap ixs");

    let in_token_account = Wallet::derive_associated_token_address(&wallet.authority(), &in_market);
    let out_token_account =
        Wallet::derive_associated_token_address(&wallet.authority(), &out_market);

    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .jupiter_swap(
        jupiter_swap_info,
        &in_market,
        &out_market,
        &in_token_account,
        &out_token_account,
        None,
        None,
    )
    .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    let err = result.expect("sim ok").err;
    // either swap OK or it would incur borrow which is fine (test account missing 'token in' amount)
    match err {
        Some(err) => {
            assert_eq!(
                err,
                TransactionError::InstructionError(4, InstructionError::Custom(6157))
            )
        }
        None => assert!(true),
    }
}

```

## File: tests/titan.rs
```
#![cfg(feature = "titan")]

use drift_rs::{
    event_subscriber::RpcClient,
    titan::{Provider, SwapMode, TitanSwapApi},
    types::{accounts::User, Context, MarketId},
    utils::test_envs::{mainnet_endpoint, mainnet_test_keypair},
    DriftClient, TransactionBuilder, Wallet,
};
use solana_sdk::{instruction::InstructionError, transaction::TransactionError};
use tokio::sync::OnceCell;

const DRIFT_CLIENT: OnceCell<DriftClient> = OnceCell::const_new();

async fn drift_client() -> DriftClient {
    DRIFT_CLIENT
        .get_or_init(|| async move {
            let wallet: Wallet = mainnet_test_keypair().into();
            DriftClient::new(
                Context::MainNet,
                RpcClient::new(mainnet_endpoint()),
                wallet.clone(),
            )
            .await
            .unwrap()
        })
        .await
        .clone()
}

#[tokio::test]
async fn titan_swap_exact_in_usdc_to_sol() {
    let _ = env_logger::try_init();
    let client = drift_client().await;
    let wallet = client.wallet();

    let token_in = MarketId::QUOTE_SPOT;
    let token_out = MarketId::spot(1);

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");

    let titan_swap_info = client
        .titan_swap_query(
            wallet.authority(),
            10_000_000,
            None,
            SwapMode::ExactIn,
            100,
            token_in.index(),
            token_out.index(),
            Some(true),
            None,
            None,
        )
        .await
        .expect("got titan swap ixs");

    let in_market = client
        .program_data()
        .spot_market_config_by_index(token_in.index())
        .unwrap();
    let out_market = client
        .program_data()
        .spot_market_config_by_index(token_out.index())
        .unwrap();

    let in_token_account = Wallet::derive_associated_token_address(&wallet.authority(), &in_market);
    let out_token_account =
        Wallet::derive_associated_token_address(&wallet.authority(), &out_market);

    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .titan_swap(
        titan_swap_info,
        &in_market,
        &out_market,
        &in_token_account,
        &out_token_account,
        None,
        None,
    )
    .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    let err = result.expect("sim ok").err;
    match err {
        Some(err) => {
            assert_eq!(
                err,
                TransactionError::InstructionError(4, InstructionError::Custom(6157))
            )
        }
        None => assert!(true),
    }
}

#[tokio::test]
async fn titan_swap_exact_in_usdc_jto() {
    let _ = env_logger::try_init();
    let client = drift_client().await;
    let wallet = client.wallet();

    let token_in = MarketId::QUOTE_SPOT;
    let token_out = client.market_lookup("JTO").unwrap();

    let in_market = client
        .program_data()
        .spot_market_config_by_index(token_in.index())
        .unwrap();
    let out_market = client
        .program_data()
        .spot_market_config_by_index(token_out.index())
        .unwrap();

    let user: User = client
        .get_user_account(&wallet.default_sub_account())
        .await
        .expect("exists");

    let titan_swap_info = client
        .titan_swap_query(
            wallet.authority(),
            5 * 10_u64.pow(out_market.decimals),
            Some(50),
            SwapMode::ExactIn,
            100,
            token_in.index(),
            token_out.index(),
            Some(true),
            None,
            Some(Provider::Titan),
        )
        .await
        .expect("got titan swap ixs");

    let in_token_account = Wallet::derive_associated_token_address(&wallet.authority(), &in_market);
    let out_token_account =
        Wallet::derive_associated_token_address(&wallet.authority(), &out_market);

    let tx = TransactionBuilder::new(
        client.program_data(),
        wallet.default_sub_account(),
        std::borrow::Cow::Borrowed(&user),
        false,
    )
    .titan_swap(
        titan_swap_info,
        &in_market,
        &out_market,
        &in_token_account,
        &out_token_account,
        None,
        None,
    )
    .build();

    let result = client.simulate_tx(tx).await;
    dbg!(&result);
    let err = result.expect("sim ok").err;
    match err {
        Some(err) => {
            assert_eq!(
                err,
                TransactionError::InstructionError(4, InstructionError::Custom(6157))
            )
        }
        None => assert!(true),
    }
}

```


---

# Repository Tree (with token estimates)

📁 ./ (~3,845 tokens)
   └─ .rustfmt.toml (~16 tokens)
   └─ build.rs (~2,162 tokens)
   └─ Cargo.toml (~514 tokens)
   └─ README.md (~1,153 tokens)
📁 .github/workflows/ (~2,850 tokens)
   └─ build.yml (~668 tokens)
   └─ manual-idl-update.yml (~178 tokens)
   └─ on-libdrift-update.yml (~554 tokens)
   └─ on-program-update.yml (~838 tokens)
   └─ release.yml (~612 tokens)
📁 crates/drift-idl-gen/ (~315 tokens)
   └─ Cargo.toml (~88 tokens)
   └─ README.md (~227 tokens)
📁 crates/drift-idl-gen/src/ (~6,973 tokens)
   └─ custom_types.rs (~758 tokens)
   └─ lib.rs (~6,215 tokens)
📁 crates/pubsub-client/ (~191 tokens)
   └─ Cargo.toml (~169 tokens)
   └─ README.md (~22 tokens)
📁 crates/pubsub-client/src/ (~7,062 tokens)
   └─ lib.rs (~7,062 tokens)
📁 crates/src/ (~99,833 tokens)
   └─ account_map.rs (~4,135 tokens)
   └─ async_utils.rs (~737 tokens)
   └─ auction_subscriber.rs (~822 tokens)
   └─ blockhash_subscriber.rs (~1,478 tokens)
   └─ constants.rs (~4,297 tokens)
   └─ drift_idl.rs (~250 tokens) [truncated]
   └─ event_subscriber.rs (~13,730 tokens)
   └─ ffi.rs (~23,354 tokens)
   └─ jit_client.rs (~4,621 tokens)
   └─ jupiter.rs (~1,300 tokens)
   └─ lib.rs (~250 tokens) [truncated]
   └─ market_state.rs (~1,813 tokens)
   └─ marketmap.rs (~4,364 tokens)
   └─ memcmp.rs (~397 tokens)
   └─ oraclemap.rs (~7,878 tokens)
   └─ polled_account_subscriber.rs (~1,272 tokens)
   └─ priority_fee_subscriber.rs (~2,366 tokens)
   └─ slot_subscriber.rs (~1,352 tokens)
   └─ swift_order_subscriber.rs (~7,603 tokens)
   └─ titan.rs (~1,148 tokens)
   └─ types.rs (~5,962 tokens)
   └─ usermap.rs (~1,671 tokens)
   └─ utils.rs (~4,064 tokens)
   └─ wallet.rs (~1,977 tokens)
   └─ websocket_account_subscriber.rs (~1,531 tokens)
   └─ websocket_program_account_subscriber.rs (~1,461 tokens)
📁 crates/src/dlob/ (~29,757 tokens)
   └─ builder.rs (~1,116 tokens)
   └─ mod.rs (~18,601 tokens)
   └─ tests.rs (~250 tokens) [truncated]
   └─ types.rs (~5,893 tokens)
   └─ util.rs (~3,897 tokens)
📁 crates/src/grpc/ (~9,879 tokens)
   └─ grpc_subscriber.rs (~7,472 tokens)
   └─ mod.rs (~2,407 tokens)
📁 crates/src/math/ (~17,338 tokens)
   └─ account_list_builder.rs (~2,168 tokens)
   └─ auction.rs (~715 tokens)
   └─ constants.rs (~1,130 tokens)
   └─ leverage.rs (~2,675 tokens)
   └─ liquidation.rs (~8,032 tokens)
   └─ mod.rs (~2,196 tokens)
   └─ order.rs (~422 tokens)
📁 examples/dlob-builder/ (~96 tokens)
   └─ Cargo.toml (~96 tokens)
📁 examples/dlob-builder/src/ (~9,178 tokens)
   └─ clob.html (~7,561 tokens)
   └─ main.rs (~1,617 tokens)
📁 examples/dlob-matching/ (~100 tokens)
   └─ Cargo.toml (~66 tokens)
   └─ README.md (~34 tokens)
📁 examples/dlob-matching/src/ (~1,584 tokens)
   └─ main.rs (~1,584 tokens)
📁 examples/drift-client-callbacks/ (~700 tokens)
   └─ Cargo.toml (~94 tokens)
   └─ README.md (~606 tokens)
📁 examples/drift-client-callbacks/src/ (~1,024 tokens)
   └─ main.rs (~1,024 tokens)
📁 examples/event-subscriber/ (~189 tokens)
   └─ Cargo.toml (~64 tokens)
   └─ README.md (~125 tokens)
📁 examples/event-subscriber/src/ (~718 tokens)
   └─ main.rs (~718 tokens)
📁 examples/market-maker/ (~234 tokens)
   └─ Cargo.toml (~70 tokens)
   └─ README.md (~164 tokens)
📁 examples/market-maker/src/ (~4,175 tokens)
   └─ grpc_marker.rs (~2,037 tokens)
   └─ main.rs (~211 tokens)
   └─ ws_maker.rs (~1,927 tokens)
📁 examples/place-and-take/ (~88 tokens)
   └─ Cargo.toml (~88 tokens)
📁 examples/place-and-take/src/ (~1,322 tokens)
   └─ main.rs (~1,322 tokens)
📁 examples/simple-margin-calculation/ (~32 tokens)
   └─ Cargo.toml (~32 tokens)
📁 examples/simple-margin-calculation/src/ (~508 tokens)
   └─ main.rs (~508 tokens)
📁 examples/swift-maker/ (~280 tokens)
   └─ Cargo.toml (~57 tokens)
   └─ README.md (~223 tokens)
📁 examples/swift-maker/src/ (~1,170 tokens)
   └─ main.rs (~1,170 tokens)
📁 examples/swift-taker/ (~218 tokens)
   └─ Cargo.toml (~97 tokens)
   └─ README.md (~121 tokens)
📁 examples/swift-taker/src/ (~1,594 tokens)
   └─ main.rs (~1,594 tokens)
📁 res/ (~2,826 tokens)
   └─ 9Jtc.hex (~2,188 tokens)
   └─ drift.json (~250 tokens) [truncated]
   └─ spot_market_1_76_0.hex (~388 tokens)
📁 scripts/ (~38 tokens)
   └─ idl-update.sh (~38 tokens)
📁 tests/ (~6,613 tokens)
   └─ integration.rs (~3,202 tokens)
   └─ jupiter.rs (~2,221 tokens)
   └─ titan.rs (~1,190 tokens)

---

# Complete File Paths (untruncated)

.github/workflows/build.yml (~668 tokens)
.github/workflows/manual-idl-update.yml (~178 tokens)
.github/workflows/on-libdrift-update.yml (~554 tokens)
.github/workflows/on-program-update.yml (~838 tokens)
.github/workflows/release.yml (~612 tokens)
.rustfmt.toml (~16 tokens)
build.rs (~2,162 tokens)
Cargo.toml (~514 tokens)
crates/drift-idl-gen/Cargo.toml (~88 tokens)
crates/drift-idl-gen/README.md (~227 tokens)
crates/drift-idl-gen/src/custom_types.rs (~758 tokens)
crates/drift-idl-gen/src/lib.rs (~6,215 tokens)
crates/pubsub-client/Cargo.toml (~169 tokens)
crates/pubsub-client/README.md (~22 tokens)
crates/pubsub-client/src/lib.rs (~7,062 tokens)
crates/src/account_map.rs (~4,135 tokens)
crates/src/async_utils.rs (~737 tokens)
crates/src/auction_subscriber.rs (~822 tokens)
crates/src/blockhash_subscriber.rs (~1,478 tokens)
crates/src/constants.rs (~4,297 tokens)
crates/src/dlob/builder.rs (~1,116 tokens)
crates/src/dlob/mod.rs (~18,601 tokens)
crates/src/dlob/tests.rs (~250 tokens) [truncated]
crates/src/dlob/types.rs (~5,893 tokens)
crates/src/dlob/util.rs (~3,897 tokens)
crates/src/drift_idl.rs (~250 tokens) [truncated]
crates/src/event_subscriber.rs (~13,730 tokens)
crates/src/ffi.rs (~23,354 tokens)
crates/src/grpc/grpc_subscriber.rs (~7,472 tokens)
crates/src/grpc/mod.rs (~2,407 tokens)
crates/src/jit_client.rs (~4,621 tokens)
crates/src/jupiter.rs (~1,300 tokens)
crates/src/lib.rs (~250 tokens) [truncated]
crates/src/market_state.rs (~1,813 tokens)
crates/src/marketmap.rs (~4,364 tokens)
crates/src/math/account_list_builder.rs (~2,168 tokens)
crates/src/math/auction.rs (~715 tokens)
crates/src/math/constants.rs (~1,130 tokens)
crates/src/math/leverage.rs (~2,675 tokens)
crates/src/math/liquidation.rs (~8,032 tokens)
crates/src/math/mod.rs (~2,196 tokens)
crates/src/math/order.rs (~422 tokens)
crates/src/memcmp.rs (~397 tokens)
crates/src/oraclemap.rs (~7,878 tokens)
crates/src/polled_account_subscriber.rs (~1,272 tokens)
crates/src/priority_fee_subscriber.rs (~2,366 tokens)
crates/src/slot_subscriber.rs (~1,352 tokens)
crates/src/swift_order_subscriber.rs (~7,603 tokens)
crates/src/titan.rs (~1,148 tokens)
crates/src/types.rs (~5,962 tokens)
crates/src/usermap.rs (~1,671 tokens)
crates/src/utils.rs (~4,064 tokens)
crates/src/wallet.rs (~1,977 tokens)
crates/src/websocket_account_subscriber.rs (~1,531 tokens)
crates/src/websocket_program_account_subscriber.rs (~1,461 tokens)
examples/dlob-builder/Cargo.toml (~96 tokens)
examples/dlob-builder/src/clob.html (~7,561 tokens)
examples/dlob-builder/src/main.rs (~1,617 tokens)
examples/dlob-matching/Cargo.toml (~66 tokens)
examples/dlob-matching/README.md (~34 tokens)
examples/dlob-matching/src/main.rs (~1,584 tokens)
examples/drift-client-callbacks/Cargo.toml (~94 tokens)
examples/drift-client-callbacks/README.md (~606 tokens)
examples/drift-client-callbacks/src/main.rs (~1,024 tokens)
examples/event-subscriber/Cargo.toml (~64 tokens)
examples/event-subscriber/README.md (~125 tokens)
examples/event-subscriber/src/main.rs (~718 tokens)
examples/market-maker/Cargo.toml (~70 tokens)
examples/market-maker/README.md (~164 tokens)
examples/market-maker/src/grpc_marker.rs (~2,037 tokens)
examples/market-maker/src/main.rs (~211 tokens)
examples/market-maker/src/ws_maker.rs (~1,927 tokens)
examples/place-and-take/Cargo.toml (~88 tokens)
examples/place-and-take/src/main.rs (~1,322 tokens)
examples/simple-margin-calculation/Cargo.toml (~32 tokens)
examples/simple-margin-calculation/src/main.rs (~508 tokens)
examples/swift-maker/Cargo.toml (~57 tokens)
examples/swift-maker/README.md (~223 tokens)
examples/swift-maker/src/main.rs (~1,170 tokens)
examples/swift-taker/Cargo.toml (~97 tokens)
examples/swift-taker/README.md (~121 tokens)
examples/swift-taker/src/main.rs (~1,594 tokens)
README.md (~1,153 tokens)
res/9Jtc.hex (~2,188 tokens)
res/drift.json (~250 tokens) [truncated]
res/spot_market_1_76_0.hex (~388 tokens)
scripts/idl-update.sh (~38 tokens)
tests/integration.rs (~3,202 tokens)
tests/jupiter.rs (~2,221 tokens)
tests/titan.rs (~1,190 tokens)

---
# End of llms.txt
# Included: 90 files, 842,795 characters (~214,010 tokens)
# Skipped: 0 files (binary or in excluded directories)
# Truncated: 4 files (showing first 1000 chars of large files)
